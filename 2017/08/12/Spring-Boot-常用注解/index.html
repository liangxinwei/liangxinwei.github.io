<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Spring Boot 常用注解 | 梁新维</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spring Boot 常用注解</h1><a id="logo" href="/.">梁新维</a><p class="description">sometimes code， sometimes design</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Spring Boot 常用注解</h1><div class="post-meta">Aug 12, 2017<span> | </span><span class="category"><a href="/categories/后端/">后端</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="常见注解"><a href="#常见注解" class="headerlink" title="常见注解"></a>常见注解</h2><ol>
<li>@SpringBootApplication 申明让spring boot自动给程序进行必要的配置，<br> 等价于以默认属性使用@Configuration，@EnableAutoConfiguration和@ComponentScan</li>
<li>@Configuration 相当于把该类作为spring的xml配置文件中的<beans>，作用为：配置spring容器(应用上下文)<br> 凡是被Spring管理的类，实现接口 EnvironmentAware 重写方法 setEnvironment 可以在工程启动时，<br> 获取到系统环境变量和application配置文件中的变量</beans></li>
<li>@EnableScheduling 在 Spring Boot 的配置类中，标注上这个注解，就可以对项目中的方法某些方法使用@Schedule注解，将其变为定时自动执行。<br> 但只有两种注解共同使用时，才能达到本注解应有的作用。</li>
<li>@Qualifier 限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者</li>
<li>@ImportResource 用来加载xml配置文件。</li>
<li>@Autowired 自动导入依赖的bean</li>
<li>@RestController 返回json字符串的数据，直接可以编写RESTFul的接口</li>
<li>@ComponentScan 表示将该类自动发现（扫描）并注册为Bean，可以自动收集所有的Spring组件,<br> 包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。<br> 如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。</li>
<li>@ServletComponentScan spring能够扫描到自己编写的servlet和filter，<br> SpringBootApplication 上使用@ServletComponentScan注解后，Servlet、Filter、Listener，<br> 可以直接通过 @WebServlet、@WebFilter、@WebListener 注解自动注册，无需其他代码</li>
<li>@Import({DynamicDataSourceRegister.class}) 注册动态多数据源</li>
<li>@PropertySource(value = “classpath:spring/config.properties”)<br>通过@PropertySource注解将properties配置文件中的值存储到Spring的 Environment中，Environment接口提供方法去读取配置文件中的值，<br>参数是properties文件中定义的key值。上面是读取一个配置文件，如果你想要读取多个配置文件，请看下面代码片段<br>@PropertySource(value = {“classpath:spring/config.properties”,”classpath:spring/news.properties”})</li>
<li>@EnableWebSocketMessageBroker 表示开启使用STOMP协议来传输基于代理的消息，Broker就是代理的意思。</li>
<li>@Repository<br>@Repository、@Service、@Controller，它们分别对应存储层 Bean，业务层 Bean，和展示层 Bean，将类标识为 Bean；<br>分别用于软件系统的不同层次：<br>@Component 是一个泛化的概念，仅仅表示一个组件 (Bean) ，可以作用在任何层次。<br>@Service 通常作用在业务层，但是目前该功能与 @Component 相同。<br>@Constroller 通常作用在控制层，但是目前该功能与 @Component 相同。<br>通过在类上使用 @Repository、@Component、@Service 和 @Constroller 注解，Spring会自动创建相应的 BeanDefinition 对象，<br>并注册到 ApplicationContext 中。这些类就成了 Spring 受管组件。这三个注解除了作用于不同软件层次的类，<br>其使用方式与 @Repository 是完全相同的。</li>
<li>@Value(“${spring.datasource.url}”) 获取 application 配置文件中的变量</li>
<li>@ConfigurationProperties 读取application属性配置文件中的属性</li>
<li>@ControllerAdvice 全局异常处理类，以将对于控制器的全局配置放在同一个位置。<ul>
<li>注解了@Controller的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上。</li>
<li>ControllerAdvice注解将作用在所有注解了@RequestMapping的控制器的方法上</li>
<li>ExceptionHandler：用于全局处理控制器里的异常。</li>
<li>InitBinder：用来设置WebDataBinder，用于自动绑定前台请求参数到Model中。</li>
<li>ModelAttribute：本来作用是绑定键值对到Model中，此处让全局的@RequestMapping都能获得在此处设置的键值对。</li>
</ul>
</li>
<li>@WebFilter 将一个实现了javax.servlet.Filter接口的类定义为过滤器<ul>
<li>属性filterName声明过滤器的名称,可选</li>
<li>属性urlPatterns指定要过滤的URL模式,也可使用属性value来声明.(指定要过滤的URL模式是必选属性)</li>
</ul>
</li>
<li>@Service <ul>
<li>声明类是一个 bean，其他的类才可以使用 @Autowired 将其作为一个成员变量自动注入</li>
<li>Zoo.java 在 bean 中的 id 是 “zoo”，即类名且首字母小写</li>
</ul>
</li>
<li>@Scope(“prototype”) Spring默认产生的bean是单例的，”prototype” 表示原型即每次都会new一个新的出来</li>
<li>@Bean标注在方法上(返回某个实例的方法)，作用为注册bean对象<ul>
<li>@Bean注解在返回实例的方法上，如果未通过@Bean指定bean的名称，则默认与标注的方法名相同； </li>
<li>@Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域； </li>
<li>既然@Bean的作用是注册bean对象，那么完全可以使用@Component、@Controller、@Service、@Ripository等<br>  注解注册bean，当然需要配置@ComponentScan注解进行自动扫描。<h2 id="RestController-相关"><a href="#RestController-相关" class="headerlink" title="RestController 相关"></a>RestController 相关</h2></li>
</ul>
</li>
<li>@RestController 返回json字符串的数据，直接可以编写RESTFul的接口，@ResponseBody和@Controller的合集</li>
<li>@PathVariable 当使用@RequestMapping URI template 样式映射时，即 someUrl/{paramId},<br> 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上</li>
<li>@RequestHeader 可以把Request请求header部分的值绑定到方法的参数上如<code>(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding){}</code>。</li>
<li>@CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上如<code>(@CookieValue(&quot;JSESSIONID&quot;) String cookie){}</code>。</li>
<li>@RequestParam<ul>
<li>常用来处理简单类型的绑定，通过 Request.getParameter() 获取的String可直接转换为简单类型的情况<br>（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；<br>因为使用request.getParameter()方式获取参数，所 以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；</li>
<li>用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST；</li>
<li>该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；</li>
</ul>
</li>
<li>@RequestBody 通过使用HandlerAdapter默认配置的HttpMessageConverters来解析Request请求的Body部分数据并将相应的数据绑定到Controller中方法的参数上，其常用来处理Content-Type不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等。<ul>
<li>它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。</li>
<li>因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个<code>MultiValueMap&lt;String, String&gt;</code>里，这种情况在某些特殊需求下使用。</li>
</ul>
</li>
<li>@SessionAttributes 用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。<br> 该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象</li>
<li>@ModelAttribute  该注解有两个用法，一个是用于方法上，一个是用于参数上：<ul>
<li>用于方法上时：  通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model；</li>
<li>用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于：<ul>
<li>@SessionAttributes 启用的attribute 对象上；</li>
<li>@ModelAttribute 用于方法上时指定的model对象；</li>
<li>上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中，<br>  这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account）</li>
</ul>
</li>
</ul>
</li>
<li>@Controller 用于定义控制器类，控制器负责将用户发来的URL请求转发到对应的服务接口（service层），<br> 一般这个注解在类中，通常方法需要配合注解@RequestMapping<h2 id="JPA-相关"><a href="#JPA-相关" class="headerlink" title="JPA 相关"></a>JPA 相关</h2></li>
<li>@Entity 注释声明该类为持久类,最好实现序列化，此时,默认情况下,所有的类属性都为映射到数据表的持久性字段</li>
<li>@Table(name=””,catalog=””,schema=””) 持久性映射的表,通常和@Entity 配合使用，只能标注在实体的 class 定义处，<br> 表示实体对应的数据库表的信息。<ul>
<li>name - 可选，表示表的名称，默认地，表名和实体名称一致，只有在不一致的情况下才需要指定表名</li>
<li>catalog - 可选，表示Catalog名称，默认为 Catalog(“”).</li>
<li>schema - 可选 , 表示 Schema 名称 , 默认为Schema(“”).</li>
</ul>
</li>
<li>@Id 注释可以表明哪种属性是该类中的独特标识符(即相当于数据表的主键)。</li>
<li>@GeneratedValue 定义自动增长的主键的生成策略.</li>
<li>@Transient 将忽略这些字段和属性,不用持久化到数据库.</li>
<li>@Temporal(TemporalType.TIMESTAMP) 声明时间格式 </li>
<li>@Enumerated 声明枚举 </li>
<li>@Version 声明添加对乐观锁定的支持 </li>
<li>@OneToOne 可以建立实体bean之间的一对一的关联 </li>
<li>@OneToMany 可以建立实体bean之间的一对多的关联 </li>
<li>@ManyToOne 可以建立实体bean之间的多对一的关联 </li>
<li>@ManyToMany 可以建立实体bean之间的多对多的关联 </li>
<li>@Formula 一个SQL表达式，这种属性是只读的,不在数据库生成属性(可以使用sum、average、max等) </li>
<li>@OrderBy Many端某个字段排序(List)</li>
<li>@Column注解设置，包含的设置如下 <ul>
<li>name：字段名 </li>
<li>unique：是否唯一 </li>
<li>nullable：是否可以为空 </li>
<li>inserttable：是否可以插入 </li>
<li>updateable：是否可以更新 </li>
<li>columnDefinition: 定义建表时创建此列的DDL </li>
<li>secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字。</li>
</ul>
</li>
<li>@JoinColumn(name = “”, referencedColumnName = “”) 设置对应数据表的列名和引用的数据表的列名</li>
<li>@Lob 注解属性将被持久化为 Blog 或 Clob 类型,根据get方法的返回值不同,自动进行Clob和Blob的转换。<br>因为这两种类型的数据一般占用的内存空间比较大，所以通常使用延迟加载的方式，与@Basic标记同时使用，设置加载方式为FetchType.LAZY。<ul>
<li>Clob（Character Large Ojects）类型是长字符串类型，具体的java.sql.Clob, Character[], char[] 和 java.lang.String 将被持久化为 Clob 类型。</li>
<li>Blob（Binary Large Objects）类型是字节类型，具体的java.sql.Blob, Byte[], byte[] 和 serializable type 将被持久化为 Blob 类型。</li>
</ul>
</li>
<li>@Basic<br> 实体Bean中所有的非Static 非transient的属性都可以被持久化，没有定义注解属性的等价于在其上添加了@Basic注解。<br> 通过@Basic注解可以声明属性的获取策略(lazy与否)，默认的是即时获取(early fetch)。<br> 通常不需要对简单属性设置延迟获取，如需要定义@Basic(fetch=FetchType.LAZY)<br> 在MySQL中没有Clob，用Text代替了，而且分为了tinytext， text，mediumtext，longtext。Blob也按这种方式分成了四种。</li>
<li>@Transactional注解<ul>
<li>rollbackFor 表示当该方法中抛出指定的异常时数据回滚</li>
<li>dontRollbackOn 表示当该方法中抛出指定的异常时数据不回滚</li>
</ul>
</li>
</ol>
<h2 id="hibernate-validator"><a href="#hibernate-validator" class="headerlink" title="hibernate-validator"></a>hibernate-validator</h2><ol>
<li>@size (min=3, max=20, message=”用户名长度只能在3-20之间”)</li>
<li>@size (min=6, max=20, message=”密码长度只能在6-20之间”)</li>
<li>@pattern (regexp=”[a-za-z0-9._%+-]+@[a-za-z0-9.-]+\.[a-za-z]{2,4}”, message=”邮件格式错误”)</li>
<li>@Length(min = 5, max = 20, message = “用户名长度必须位于5到20之间”)</li>
<li>@Email(message = “比如输入正确的邮箱”)</li>
<li>@NotNull(message = “用户名称不能为空”)</li>
<li>@Max(value = 100, message = “年龄不能大于100岁”)</li>
<li>@Min(value= 18 ,message= “必须年满18岁！” )</li>
<li>@AssertTrue(message = “bln4 must is true”)</li>
<li>@AssertFalse(message = “blnf must is falase”)</li>
<li>@DecimalMax(value=”100”,message=”decim最大值是100”)</li>
<li>@DecimalMin(value=”100”,message=”decim最小值是100”)</li>
<li>@NotNull(message = “身份证不能为空”)</li>
<li>@Pattern(regexp=”^(\d{18,18}|\d{15,15}|(\d{17,17}[x|X]))$”, message=”身份证格式错误”)<h2 id="Service-VS-Bean-和-Configuration"><a href="#Service-VS-Bean-和-Configuration" class="headerlink" title="@Service VS @Bean 和 @Configuration"></a>@Service VS @Bean 和 @Configuration</h2>@Service实际上表示了DDD中的无状态的，独立的，以接口的形式提供的一个操作。采用@Bean和@Configuration配合的方式，Bean的创建交给了单独的类，而Service的标识给了Java中的Interface以及类的名字。这点在Spring Data也有所体现，比如Repository就是通过名字来标识，如CrudRepository。因此Service也通过名字来体现。具体层次定义，通过名字而不依赖Spring提供的注解，便于根据项目提供更多的层次，比如Mapper层，Validator层等。另外，本身Bean和Service就是两个维度的概念。一个关于具体实现，另一个关于DDD中的概念。使用@Bean的方式，能够创建库里面的类的实例。如果使用@Service的方式，没办法在库里面对应的类上添加@Service注解。<h2 id="Resource、-Autowired、-Qualifier-区别"><a href="#Resource、-Autowired、-Qualifier-区别" class="headerlink" title="@Resource、@Autowired、@Qualifier 区别"></a>@Resource、@Autowired、@Qualifier 区别</h2>@Resource和@Autowired都可以来完成注入依赖，但它们之间是有区 别的：</li>
<li>@Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入；</li>
<li>@Autowired默认是按照类型装配注入的，如果想按照名称来转配注入，则需要结合@Qualifier一起使用；</li>
<li>@Resource注解是又J2EE提供，而@Autowired是由Spring提供，故减少系统对spring的依赖建议使用@Resource的方式；</li>
<li>@Resource和@Autowired都可以书写标注在字段或者该字段的setter方法之上</li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2017/09/28/记一次管理系统和路由系统的整合/">记一次管理系统和路由系统的整合</a><a class="next" href="/2017/07/28/fatal-Could-not-read-from-remote-repository-的解决办法/">fatal: Could not read from remote repository.的解决办法</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小程序/">小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/01/2020Flag/">2020Flag</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/31/2019年终总结/">2019年终总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/B端产品经理长成读书笔记/">B端产品经理长成读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/九败一胜读书笔记/">九败一胜读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/11/roadhog-1-3-X-打包慢的解决办法/">roadhog 1.3.X 打包慢的解决办法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/30/webpack各配置项全解析/">webpack各配置项全解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/小程序和h5页面之间的互相跳转/">小程序和h5页面之间的互相跳转</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/17/微信订阅号开发之获取网页授权/">微信订阅号开发之获取网页授权</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/浏览器-iframe-全屏、退出全屏/">浏览器/iframe 全屏、退出全屏</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/javaweb常见HTTP状态码/">javaweb常见HTTP状态码</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/liangxinwei" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">梁新维.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" color="0,0,0" opacity="0.5" zindex="-2" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>