<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>一些容易被忽略的 JavaScript 知识点 | 梁新维</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">一些容易被忽略的 JavaScript 知识点</h1><a id="logo" href="/.">梁新维</a><p class="description">主业上班，副业理财</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">一些容易被忽略的 JavaScript 知识点</h1><div class="post-meta">2017-05-10<span> | </span><span class="category"><a href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReferenceError%E5%92%8CTypeError"><span class="toc-number">1.</span> <span class="toc-text">ReferenceError和TypeError</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">立即执行函数表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#let"><span class="toc-number">3.</span> <span class="toc-text">let</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E5%8D%87"><span class="toc-number">4.</span> <span class="toc-text">提升</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AD%E5%8C%85"><span class="toc-number">5.</span> <span class="toc-text">作用域闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#typeof-null-%E2%80%9Cobject%E2%80%9D"><span class="toc-number">6.</span> <span class="toc-text">typeof null &#x3D; “object”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array"><span class="toc-number">7.</span> <span class="toc-text">Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Number"><span class="toc-number">8.</span> <span class="toc-text">Number()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boolean"><span class="toc-number">9.</span> <span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E7%89%B9%E7%9A%84-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">10.</span> <span class="toc-text">奇特的 ~ 运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C"><span class="toc-number">11.</span> <span class="toc-text">&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">12.</span> <span class="toc-text">逗号操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%85%B3%E7%B3%BB%E6%AF%94%E8%BE%83-a-lt-b"><span class="toc-number">13.</span> <span class="toc-text">抽象关系比较 a &lt; b</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">14.</span> <span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toString-NaN"><span class="toc-number">15.</span> <span class="toc-text">toString</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">16.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind-%E5%AE%9E%E7%8E%B0"><span class="toc-number">17.</span> <span class="toc-text">bind 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-create-%E5%AE%9E%E7%8E%B0"><span class="toc-number">18.</span> <span class="toc-text">Object.create() 实现</span></a></li></ol></div></div><div class="post-content"><h2 id="ReferenceError和TypeError"><a href="#ReferenceError和TypeError" class="headerlink" title="ReferenceError和TypeError"></a>ReferenceError和TypeError</h2><p>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常。如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p>
<h2 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h2><p>由于函数被包含在一对 () 括号内部，因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个()将函数变成表达式，第二个()执行了这个函数。</p>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地了所在的块作用域。使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在” 。for 循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</p>
<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>考虑以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 2;</span><br><span class="line">var a;</span><br><span class="line">console.log(a);// 2</span><br></pre></td></tr></table></figure>
<p>考虑另外一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);// undefined</span><br><span class="line">var a = 2;</span><br></pre></td></tr></table></figure>
<p>过程： 当你看到 var a = 2; 时，JavaScript 实际上会将其看成两个声明： var a; 和 a = 2; 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。第一个代码片段会以如下形式进行处理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">a = 2;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure>
<p>其中第一部分是编译，而第二部分是执行。第二个代码片段实际是按照以下流程处理的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">console.log(a);</span><br><span class="line">a = 2;</span><br></pre></td></tr></table></figure>
<p>这个过程就叫作提升。但是函数表达式却不会被提升。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); // 不是 ReferenceError, 而是 TypeError!</span><br><span class="line">var foo = function bar() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域） ，因此foo()不会导致 ReferenceError 。但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值） 。 foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。<br>同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(); // TypeError</span><br><span class="line">bar(); // ReferenceError</span><br><span class="line">var foo = function bar() &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个代码片段经过提升后，实际上会被理解为以下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo;</span><br><span class="line">foo(); // TypeError</span><br><span class="line">bar(); // ReferenceError</span><br><span class="line">foo = function() &#123;</span><br><span class="line">    var bar = ...self...</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数声明和变量声明都会被提升。但是是函数会首先被提升，然后才是变量。考虑以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo(); // 1</span><br><span class="line">var foo;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">foo = function() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">foo(); // 1</span><br><span class="line">foo = function() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意， var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了） ，因为函数声明会被提升到普通变量之前。尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p>
<h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><p>定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。下面这段代码清晰地展示了闭包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">    var a = 2;</span><br><span class="line">    function bar() &#123;</span><br><span class="line">        console.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    return bar;</span><br><span class="line">&#125;</span><br><span class="line">var baz = foo();</span><br><span class="line">baz(); // 2 —— 这就是闭包的效果。</span><br></pre></td></tr></table></figure>
<p>bar() 显然可以被正常执行，但是它在自己定义的词法作用域以外的地方执行。看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p>
<h2 id="typeof-null-“object”"><a href="#typeof-null-“object”" class="headerlink" title="typeof null = “object”"></a>typeof null = “object”</h2><p>不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为  object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“ object ” 。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>使用 delete 运算符可以将单元从数组中删除，单元删除后，数组的 length 属性并不会发生变化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];</span><br><span class="line">a[0] = 1;</span><br><span class="line">//  此处没有设置 a[1] 单元</span><br><span class="line">a[2] = 3;</span><br><span class="line">a[1]; // undefined</span><br><span class="line">a.length; // 3</span><br></pre></td></tr></table></figure>
<p>上面的代码可以正常运行，但其中的 “ 空白单元 ” （ empty slot ）可能会导致出人意料的结果。另外：如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a = [ ];</span><br><span class="line">a[&quot;13&quot;] = 42;</span><br><span class="line">a.length; // 14</span><br></pre></td></tr></table></figure>

<h2 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h2><p>对于 . 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。<br><strong>true 转换为 1 ， false 转换为 0 。 undefined 转换为 NaN ， null 转换为 0。</strong><br>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null ，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换。看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//  无效语法：因为 . 被视为常量 42. 的一部分，所以没有. 属性访问运算符来调用 tofixed 方法</span><br><span class="line">42.toFixed(3);    // SyntaxError</span><br><span class="line">//  下面的语法都有效：</span><br><span class="line">(42).toFixed(3);  // &quot;42.000&quot;</span><br><span class="line">0.42.toFixed(3);  // &quot;0.420&quot;</span><br><span class="line">42..toFixed(3);   // &quot;42.000&quot;</span><br><span class="line">42 .toFixed(3);     // &quot;42.000&quot;</span><br><span class="line"></span><br><span class="line">var a = &#123;</span><br><span class="line">valueOf: function()&#123;</span><br><span class="line">    return &quot;42&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">var b = &#123;</span><br><span class="line">    toString: function()&#123;</span><br><span class="line">        return &quot;42&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var c = [4,2];</span><br><span class="line">c.toString = function()&#123;</span><br><span class="line">    return this.join(&quot;&quot;); // &quot;42&quot;</span><br><span class="line">&#125;;</span><br><span class="line">Number(a); // 42</span><br><span class="line">Number(b); // 42</span><br><span class="line">Number(c); // 42</span><br><span class="line">Number(&quot;&quot;); // 0</span><br><span class="line">Number([]); // 0</span><br><span class="line">Number([&quot;abc&quot;]); // NaN</span><br></pre></td></tr></table></figure>

<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><ol>
<li>假值 undefined,null,false,+0,-0,NaN,””。<strong>假值列表以外的值都是真值</strong></li>
<li>假值对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = new Boolean(false);</span><br><span class="line">var b = new Number(0);</span><br><span class="line">var c = new String(&quot;&quot;);</span><br><span class="line">var d = Boolean(a &amp;&amp; b &amp;&amp; c);</span><br><span class="line">d; // true 说明 a 、 b 、 c 都为 true </span><br></pre></td></tr></table></figure>
虽然 JavaScript  代码中会出现假值对象，但它实际上并不属于 JavaScript  语言的范畴。浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是 “ 假值对象 ” 。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 。最常见的例子是 document.all ，它是一个类数组对象，包含了页面上的所有元素，由 DOM （而不是 JavaScript  引擎）提供给 JavaScript  程序使用。它以前曾是一个真正意义上的对象，布尔强制类型转换结果为 true ，不过现在它是一个假值对象。document.all 并不是一个标准用法，早就被废止了。</li>
</ol>
<h2 id="奇特的-运算符"><a href="#奇特的-运算符" class="headerlink" title="奇特的 ~ 运算符"></a>奇特的 ~ 运算符</h2><p><strong>1. 类型转换</strong></p>
<p>它首先将值强制类型转换为 32 位数字，然后执行字位操作 “非” （对每一个字位进行反转）。这与<code>!</code>很相像，不仅将值强制类型转换为布尔值<code>&lt;</code>，还对其做字位反转。对<code>~</code>还可以有另外一种诠释，源自早期的计算机科学和离散数学：<code>~</code>返回 2 的补码。<code>~x</code>大致等同于<code>-(x+1)</code>。<br><code>~</code>和<code>indexOf()</code>一起可以将结果强制类型转换（实际上仅仅是转换）为真 /  假值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = &quot;Hello World&quot;;</span><br><span class="line">~a.indexOf(&quot;lo&quot;); // -4 &lt;--  真值 !</span><br><span class="line">if (~a.indexOf(&quot;lo&quot;)) &#123; // true</span><br><span class="line">    //  找到匹配！</span><br><span class="line">&#125;</span><br><span class="line">~a.indexOf(&quot;ol&quot;); // 0 &lt;--  假值 !</span><br><span class="line">!~a.indexOf(&quot;ol&quot;); // true</span><br><span class="line">if (!~a.indexOf(&quot;ol&quot;)) &#123; // true</span><br><span class="line">    //  没有找到匹配！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 indexOf(..) 返回 -1 ，<code>~</code>将其转换为假值 0，其他情况一律转换为真值。</p>
<p><strong>2. 字位截除</strong></p>
<p>使用 <code>~~</code> 来截除数字值的小数部分，以为这和<code>Math.floor(..)</code>的效果一样，实际上并非如此。<code>~~</code>中的第一个<code>~</code>执行<code>ToInt32</code>并反转字位，然后第二个<code>~</code>再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是<code>ToInt32</code>的结果。<code>~~</code>和<code>!!</code>很相似，它只适用于 32 位数字，更重要的是它对负数的处理与<code>Math.floor(..)</code>不同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.floor(-49.6); // -50</span><br><span class="line">~~-49.6; // -49</span><br></pre></td></tr></table></figure>
<p><code>~~x</code>能将值截除为一个 32 位整数，<code>x | 0</code>也可以，而且看起来还更简洁。出于对运算符优先级的考虑，我们可能更倾向于使用 <code>~~x</code> 。</p>
<h2 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h2><p>常见的误区是：“ == 检查值是否相等， === 检查值和类型是否相等 ” 。听起来蛮有道理，然而还不够准确。<br>正确的解释是：“ == 允许在相等比较中进行强制类型转换，而 === 不允许。”<br>两种解释的区别：<br>根据第一种解释（不准确的版本）， === 似乎比 == 做的事情更多，因为它还要检查值的类型。第二种解释中 == 的工作量更大一些，因为如果值的类型不同还需要进行强制类型转换。有人觉得 == 会比 === 慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级（百万分之一秒）的差别而已。如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript  引擎实现上的细微差别之外，它们之间并没有什么不同。== 和 === 都会检查操作数的类型。区别在于<strong>操作数类型不同时它们的处理方式不同</strong>。</p>
<h2 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h2><p>逗号操作符可以在一条语句中执行多个操作，常用于申明多个变量，还可以用于赋值（总会返回表达式中的最后一项）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num1 = 1, num2 = 2, num3 = 3;</span><br><span class="line">var num = (5, 1, 4, 8, 0); // num 为 0</span><br></pre></td></tr></table></figure>

<h2 id="抽象关系比较-a-lt-b"><a href="#抽象关系比较-a-lt-b" class="headerlink" title="抽象关系比较 a &lt; b"></a>抽象关系比较 a &lt; b</h2><p>分为两个部分：比较双方都是字符串（后半部分）和其他情况（前半部分）。比较双方首先调用 ToPrimitive ，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [ 42 ];</span><br><span class="line">var b = [ &quot;43&quot; ];</span><br><span class="line">a &lt; b; // true</span><br><span class="line">b &lt; a; // false</span><br></pre></td></tr></table></figure>
<p> -0 和 NaN 的相关规则在这里也适用。如果比较双方都是字符串，则按字母顺序来进行比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a = [ &quot;42&quot; ];</span><br><span class="line">var b = [ &quot;043&quot; ];</span><br><span class="line">a &lt; b; // false</span><br><span class="line"></span><br><span class="line">var a = [ 4, 2 ];</span><br><span class="line">var b = [ 0, 4, 3 ];</span><br><span class="line">a &lt; b; // false</span><br><span class="line"></span><br><span class="line">var a = &#123; b: 42 &#125;;</span><br><span class="line">var b = &#123; b: 43 &#125;;</span><br><span class="line">a &lt; b; // ??</span><br><span class="line">// 结果还是 false ，因为 a 是 [object Object] ，b 也是 [object Object]，所以按照字母顺序 a &lt; b 并不成立。</span><br><span class="line"></span><br><span class="line">// 下面的例子就有些奇怪了:</span><br><span class="line">var a = &#123; b: 42 &#125;;</span><br><span class="line">var b = &#123; b: 43 &#125;;</span><br><span class="line">a &lt; b; // false</span><br><span class="line">a == b; // false</span><br><span class="line">a &gt; b; // false</span><br><span class="line">a &lt;= b; // true</span><br><span class="line">a &gt;= b; // true</span><br></pre></td></tr></table></figure>
<p>因为根据规范 a &lt;= b 被处理为 b &lt; a ，然后将结果反转。因为 b &lt; a 的结果是 false ，所以 a &lt;= b 的结果是 true。实际上 JavaScript  中 &lt;= 是 “ 不大于 ” 的意思（即 !(a &gt; b) ，处理为 !(b &lt; a) ）。同理 a &gt;= b 处理为 b &lt;= a 。</p>
<h2 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h2><p>在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。任何操作数与NaN进行关系比较，结果都是 false。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;23&quot; &lt; &quot;3&quot;      // false “2” 的字符编码是 50，“3” 是 51 </span><br><span class="line">&quot;a&quot; &lt; 2         // false 因为 “a” 被转换成了 NaN</span><br></pre></td></tr></table></figure>

<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[] + &#123;&#125;; // &quot;[object Object]&quot;</span><br><span class="line">&#123;&#125; + []; // 0</span><br><span class="line">[null].toString() // &quot;&quot;</span><br><span class="line">[undefined].toString() // &quot;&quot;</span><br><span class="line">[null, undefined].toString() // &quot;,&quot;</span><br></pre></td></tr></table></figure>
<p>第一行代码中， {} 出现在 + 运算符表达式中，因此它被当作一个值（空对象）来处理。 [] 会被强制类型转换为 “” ，而 {} 会被强制类型转换为 “[object Object]” 。<br>但在第二行代码中， {} 被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换为 0 。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Person = function(name) &#123; this.name = name;</span><br><span class="line">&#125;;</span><br><span class="line">// 实例化一个Person</span><br><span class="line">var alice = new Person(&#x27;alice&#x27;);</span><br><span class="line">// 不要这么做!</span><br><span class="line">Person(&#x27;bob&#x27;); //=&gt; undefined</span><br></pre></td></tr></table></figure>
<p>这个函数只会返回 undefined，并且执行上下文是 window(全局)对象，你无意间创建了一个全局变量 name。调用构造函数时不要丢掉 new 关键字。当使用 new 关键字来调用构造函数时，执行上下文从全局对象(window)变成一个空的 上下文，这个上下文代表了新生成的实例。因此，this 关键字指向当前创建的实例。默认情况下，如果你的构造函数中没有返回任何内容，就会返回 this——当前的上下文。 要不然就返回任意非原始类型的值。</p>
<h2 id="bind-实现"><a href="#bind-实现" class="headerlink" title="bind 实现"></a>bind 实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = Function.prototype.bind || function (obj) &#123;</span><br><span class="line">    var slice = [].slice,</span><br><span class="line">        args = slice.call(arguments, 1), self = this,</span><br><span class="line">        nop = function () &#123;&#125;,</span><br><span class="line">        bound = function () &#123;</span><br><span class="line">            return self.apply(this instanceof nop ? this : (obj || &#123;&#125;), args.concat(slice.call(arguments)));</span><br><span class="line">        &#125;;</span><br><span class="line">    nop.prototype = self.prototype; bound.prototype = new nop();</span><br><span class="line">    return bound; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Object-create-实现"><a href="#Object-create-实现" class="headerlink" title="Object.create() 实现"></a>Object.create() 实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.create = Object.create || function(o) &#123;</span><br><span class="line">    function F() &#123;&#125;;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2017/11/08/js/javascript%E5%BE%AA%E7%8E%AF%E4%B8%8E%E9%97%AD%E5%8C%85/">javascript循环与闭包</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%A7%E5%93%81/">产品</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E9%87%91/">基金</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/08/12/pm/%E4%BF%9E%E5%86%9B%E4%BA%A7%E5%93%81%E6%96%B9%E6%B3%95%E8%AE%BA%E7%AC%94%E8%AE%B0/">俞军产品方法论-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/08/pm/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E7%AC%94%E8%AE%B0/">用户体验要素-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/08/pm/%E4%BA%A7%E5%93%81%E4%B9%A6%E7%B1%8D/">产品书籍</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/29/fund/note/%E5%BD%BC%E5%BE%97%E6%9E%97%E5%A5%87%E7%9A%84%E6%88%90%E5%8A%9F%E6%8A%95%E8%B5%84/">彼得林奇的成功投资-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/22/fund/%E8%B0%83%E4%BB%93%E8%AE%B0%E5%BD%95%E8%A1%A8/">天天基金【10年之后】组合调仓记录表</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/22/fund/note/%E8%B6%85%E9%A2%9D%E6%94%B6%E7%9B%8A%EF%BC%9A%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E5%9C%A8%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">超额收益：价值投资在中国的最佳实践.刘哲（502的牛）-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/19/fund/note/%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E8%AE%A9%E8%B4%A2%E5%AF%8C%E6%BB%9A%E9%9B%AA%E7%90%83/">基金定投让财富滚雪球.老罗-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/14/fund/note/%E6%8A%95%E8%B5%84%E4%B8%AD%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B/">投资中最简单的事.邱国鹭-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/27/fund/note/%E5%BD%BC%E5%BE%97%E6%9E%97%E5%A5%87%E6%95%99%E4%BD%A0%E7%90%86%E8%B4%A2/">彼得林奇教你理财-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/fund/note/%E8%AF%81%E5%88%B8%E5%88%86%E6%9E%90%E4%B8%8A/">证券分析上-笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/liangxinwei" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">梁新维</a></div></div></div><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>