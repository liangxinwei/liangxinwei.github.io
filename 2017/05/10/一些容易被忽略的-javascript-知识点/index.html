<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>一些容易被忽略的 javascript 知识点 | 梁新维</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">一些容易被忽略的 javascript 知识点</h1><a id="logo" href="/.">梁新维</a><p class="description">sometimes code， sometimes design</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">一些容易被忽略的 javascript 知识点</h1><div class="post-meta">May 10, 2017<span> | </span><span class="category"><a href="/categories/前端/">前端</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h2 id="ReferenceError和TypeError"><a href="#ReferenceError和TypeError" class="headerlink" title="ReferenceError和TypeError"></a>ReferenceError和TypeError</h2><p>如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError<br>异常。如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，<br>比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的<br>属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。</p>
<h2 id="立即执行函数表达式"><a href="#立即执行函数表达式" class="headerlink" title="立即执行函数表达式"></a>立即执行函数表达式</h2><p>由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个()将函数变成表达式，第二个()执行了这个函数。</p>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地了所在的块作用域。使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在” 。for 循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。</p>
<h2 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h2><p>考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log( a );<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>考虑另外一段代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log( a );<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>过程： 当你看到 var a = 2; 时，JavaScript 实际上会将其看成两个声明： var a; 和 a = 2; 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。<br>第一个代码片段会以如下形式进行处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br></pre></td></tr></table></figure>

<p>其中第一部分是编译，而第二部分是执行。<br>第二个代码片段实际是按照以下流程处理的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log( a );</span><br><span class="line">a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>这个过程就叫作提升。但是函数表达式却不会被提升。例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 不是 ReferenceError, 而是 TypeError!</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域） ，因此foo()不会导致 ReferenceError 。但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值） 。 foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。<br>同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line">bar(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个代码片段经过提升后，实际上会被理解为以下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line">foo(); <span class="comment">// TypeError</span></span><br><span class="line">bar(); <span class="comment">// ReferenceError</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> bar = ...self...</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数声明和变量声明都会被提升。但是是函数会首先被提升，然后才是变量。<br>考虑以下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="number">2</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意， var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽<br>略了） ，因为函数声明会被提升到普通变量之前。尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p>
<h2 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h2><p>定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用<br>域之外执行。<br>下面这段代码清晰地展示了闭包：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( a );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz(); <span class="comment">// 2 —— 这就是闭包的效果。</span></span><br></pre></td></tr></table></figure>

<p>bar() 显然可以被正常执行，但是它在自己定义的词法作用域以外的地方执行。看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p>
<h2 id="typeof-null-“object”"><a href="#typeof-null-“object”" class="headerlink" title="typeof null = “object”"></a>typeof null = “object”</h2><p>不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为  object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“ object ” 。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>使用 delete 运算符可以将单元从数组中删除，单元删除后，数组的 length 属性并不会发生变化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ ];</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//  此处没有设置 a[1] 单元</span></span><br><span class="line">a[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">a[<span class="number">1</span>]; <span class="comment">// undefined</span></span><br><span class="line">a.length; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面的代码可以正常运行，但其中的 “ 空白单元 ” （ empty slot ）可能会导致出人意料的结果。另外：如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ ];</span><br><span class="line">a[<span class="string">"13"</span>] = <span class="number">42</span>;</span><br><span class="line">a.length; <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>

<h2 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h2><p>对于 . 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。<br>true 转换为 1 ， false 转换为 0 。 undefined 转换为 NaN ， null 转换为 0。<br>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。<br>使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null ，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换。看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  无效语法：因为 . 被视为常量 42. 的一部分，所以没有. 属性访问运算符来调用 tofixed 方法</span></span><br><span class="line"><span class="number">42.</span>toFixed( <span class="number">3</span> );    <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="comment">//  下面的语法都有效：</span></span><br><span class="line">(<span class="number">42</span>).toFixed( <span class="number">3</span> );  <span class="comment">// "42.000"</span></span><br><span class="line"><span class="number">0.42</span>.toFixed( <span class="number">3</span> );  <span class="comment">// "0.420"</span></span><br><span class="line"><span class="number">42.</span>.toFixed( <span class="number">3</span> );   <span class="comment">// "42.000"</span></span><br><span class="line"><span class="number">42</span> .toFixed(<span class="number">3</span>);     <span class="comment">// "42.000"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"42"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> c = [<span class="number">4</span>,<span class="number">2</span>];</span><br><span class="line">c.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.join( <span class="string">""</span> ); <span class="comment">// "42"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Number</span>( a ); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">Number</span>( b ); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">Number</span>( c ); <span class="comment">// 42</span></span><br><span class="line"><span class="built_in">Number</span>( <span class="string">""</span> ); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>( [] ); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Number</span>( [ <span class="string">"abc"</span> ] ); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><ol>
<li>假值 undefined,null,false,+0,-0,NaN,””。<strong>假值列表以外的值都是真值</strong></li>
<li>假值对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> );</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>( <span class="number">0</span> );</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">String</span>( <span class="string">""</span> );</span><br><span class="line"><span class="keyword">var</span> d = <span class="built_in">Boolean</span>( a &amp;&amp; b &amp;&amp; c );</span><br><span class="line">d; <span class="comment">// true 说明 a 、 b 、 c 都为 true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>虽然 JavaScript  代码中会出现假值对象，但它实际上并不属于 JavaScript  语言的范畴。<br>浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是 “ 假值对象 ” 。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 。最常见的例子是 document.all ，它是一个类数组对象，包含了页面上的所有元素，由 DOM （而不是 JavaScript  引擎）提供给 JavaScript  程序使用。它以前曾是一个真正意义上的对象，布尔强制类型转换结果为 true ，不过现在它是一个假值对象。document.all 并不是一个标准用法，早就被废止了。</p>
<h2 id="奇特的-运算符"><a href="#奇特的-运算符" class="headerlink" title="奇特的 ~ 运算符"></a>奇特的 ~ 运算符</h2><ol>
<li><p>类型转换<br>它首先将值强制类型转换为 32  位数字，然后执行字位操作 “ 非 ” （对每一个字位进行反转）。这与 ! 很相像，不仅将值强制类型转换为布尔值 &lt; ，还对其做字位反转。对 ~ 还可以有另外一种诠释，源自早期的计算机科学和离散数学： ~ 返回 2  的补码。~x 大致等同于 -(x+1) 。<br>~ 和 indexOf() 一起可以将结果强制类型转换（实际上仅仅是转换）为真 /  假值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"Hello World"</span>;</span><br><span class="line">~a.indexOf( <span class="string">"lo"</span> ); <span class="comment">// -4 &lt;--  真值 !</span></span><br><span class="line"><span class="keyword">if</span> (~a.indexOf( <span class="string">"lo"</span> )) &#123; <span class="comment">// true</span></span><br><span class="line"><span class="comment">//  找到匹配！</span></span><br><span class="line">&#125;</span><br><span class="line">~a.indexOf( <span class="string">"ol"</span> ); <span class="comment">// 0 &lt;--  假值 !</span></span><br><span class="line">!~a.indexOf( <span class="string">"ol"</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (!~a.indexOf( <span class="string">"ol"</span> )) &#123; <span class="comment">// true</span></span><br><span class="line"><span class="comment">//  没有找到匹配！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 indexOf(..) 返回 -1 ， ~ 将其转换为假值 0 ，其他情况一律转换为真值。</p>
</li>
<li><p>字位截除<br>使用 <del>~ 来截除数字值的小数部分，以为这和 Math.floor(..) 的效果一样，实际上并非如此。</del> 中的第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。~~ 和 !! 很相似，它只适用于 32 位数字，更重要的是它对负数的处理与 Math.floor(..) 不同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.floor( <span class="number">-49.6</span> ); <span class="comment">// -50</span></span><br><span class="line">~~<span class="number">-49.6</span>; <span class="comment">// -49</span></span><br></pre></td></tr></table></figure>

<p><del>x 能将值截除为一个 32  位整数， x | 0 也可以，而且看起来还更简洁。出于对运算符优先级的考虑，我们可能更倾向于使用 ~</del>x 。</p>
<h2 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h2><p>常见的误区是：“ == 检查值是否相等， === 检查值和类型是否相等 ” 。听起来蛮有道理，然而还不够准确。<br>正确的解释是：“ == 允许在相等比较中进行强制类型转换，而 === 不允许。”<br>两种解释的区别：<br>根据第一种解释（不准确的版本）， === 似乎比 == 做的事情更多，因为它还要检查值的类型。第二种解释中 == 的工作量更大一些，因为如果值的类型不同还需要进行强制类型转换。有人觉得 == 会比 === 慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级（百万分之一秒）的差别而已。如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript  引擎实现上的细微差别之外，它们之间并没有什么不同。<br>== 和 === 都会检查操作数的类型。区别在于<strong>操作数类型不同时它们的处理方式不同</strong>。</p>
</li>
</ol>
<h2 id="抽象关系比较-a-lt-b"><a href="#抽象关系比较-a-lt-b" class="headerlink" title="抽象关系比较 a &lt; b"></a>抽象关系比较 a &lt; b</h2><p>分为两个部分：比较双方都是字符串（后半部分）和其他情况（前半部分）。比较双方首先调用 ToPrimitive ，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ <span class="number">42</span> ];</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="string">"43"</span> ];</span><br><span class="line">a &lt; b; <span class="comment">// true</span></span><br><span class="line">b &lt; a; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p> -0 和 NaN 的相关规则在这里也适用。如果比较双方都是字符串，则按字母顺序来进行比较</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [ <span class="string">"42"</span> ];</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="string">"043"</span> ];</span><br><span class="line">a &lt; b; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [ <span class="number">4</span>, <span class="number">2</span> ];</span><br><span class="line"><span class="keyword">var</span> b = [ <span class="number">0</span>, <span class="number">4</span>, <span class="number">3</span> ];</span><br><span class="line">a &lt; b; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">b</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">b</span>: <span class="number">43</span> &#125;;</span><br><span class="line">a &lt; b; <span class="comment">// ??</span></span><br><span class="line"><span class="comment">// 结果还是 false ，因为 a 是 [object Object] ，b 也是 [object Object]，所以按照字母顺序 a &lt; b 并不成立。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的例子就有些奇怪了:</span></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">b</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = &#123; <span class="attr">b</span>: <span class="number">43</span> &#125;;</span><br><span class="line">a &lt; b; <span class="comment">// false</span></span><br><span class="line">a == b; <span class="comment">// false</span></span><br><span class="line">a &gt; b; <span class="comment">// false</span></span><br><span class="line">a &lt;= b; <span class="comment">// true</span></span><br><span class="line">a &gt;= b; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因为根据规范 a &lt;= b 被处理为 b &lt; a ，然后将结果反转。因为 b &lt; a 的结果是 false ，所以 a &lt;= b 的结果是 true。实际上 JavaScript  中 &lt;= 是 “ 不大于 ” 的意思（即 !(a &gt; b) ，处理为 !(b &lt; a) ）。同理 a &gt;= b 处理为 b &lt;= a 。</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[] + &#123;&#125;; <span class="comment">// "[object Object]"</span></span><br><span class="line">&#123;&#125; + []; <span class="comment">// 0</span></span><br><span class="line">[<span class="literal">null</span>].toString() <span class="comment">// ""</span></span><br><span class="line">[<span class="literal">undefined</span>].toString() <span class="comment">// ""</span></span><br><span class="line">[<span class="literal">null</span>, <span class="literal">undefined</span>].toString() <span class="comment">// ","</span></span><br></pre></td></tr></table></figure>

<p>第一行代码中， {} 出现在 + 运算符表达式中，因此它被当作一个值（空对象）来处理。 [] 会被强制类型转换为 “” ，而 {} 会被强制类型转换为 “[object Object]” 。<br>但在第二行代码中， {} 被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换为 0 。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例化一个Person</span></span><br><span class="line"><span class="keyword">var</span> alice = <span class="keyword">new</span> Person(<span class="string">'alice'</span>);</span><br><span class="line"><span class="comment">// 不要这么做!</span></span><br><span class="line">Person(<span class="string">'bob'</span>); <span class="comment">//=&gt; undefined</span></span><br></pre></td></tr></table></figure>

<p>这个函数只会返回 undefined，并且执行上下文是 window(全局)对象，你无意间创建了一个全局变量 name。调用构造函数时不要丢掉 new 关键字。当使用 new 关键字来调用构造函数时，执行上下文从全局对象(window)变成一个空的 上下文，这个上下文代表了新生成的实例。因此，this 关键字指向当前创建的实例。默认情况下，如果你的构造函数中没有返回任何内容，就会返回 this——当前的上下文。 要不然就返回任意非原始类型的值。</p>
<h2 id="bind-实现"><a href="#bind-实现" class="headerlink" title="bind 实现"></a>bind 实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="built_in">Function</span>.prototype.bind || <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> slice = [].slice,</span><br><span class="line">		args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), self = <span class="keyword">this</span>,</span><br><span class="line">		nop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">		bound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> self.apply( <span class="keyword">this</span> <span class="keyword">instanceof</span> nop ? <span class="keyword">this</span> : (obj || &#123;&#125;), args.concat(slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">		&#125;;</span><br><span class="line">	nop.prototype = self.prototype; bound.prototype = <span class="keyword">new</span> nop();</span><br><span class="line">	<span class="keyword">return</span> bound; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Object-create-实现"><a href="#Object-create-实现" class="headerlink" title="Object.create() 实现"></a>Object.create() 实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create = <span class="built_in">Object</span>.create || <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">	F.prototype = o;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2017/06/08/搭建一个包含-redux、router、国际化的前端项目框架/">搭建一个包含 redux、router、国际化的前端项目框架</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/小程序/">小程序</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书笔记/">读书笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/01/2020Flag/">2020Flag</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/31/2019年终总结/">2019年终总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/12/B端产品经理长成读书笔记/">B端产品经理长成读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/19/九败一胜读书笔记/">九败一胜读书笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/11/roadhog-1-3-X-打包慢的解决办法/">roadhog 1.3.X 打包慢的解决办法</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/30/webpack各配置项全解析/">webpack各配置项全解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/23/小程序和h5页面之间的互相跳转/">小程序和h5页面之间的互相跳转</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/10/17/微信订阅号开发之获取网页授权/">微信订阅号开发之获取网页授权</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/15/浏览器-iframe-全屏、退出全屏/">浏览器/iframe 全屏、退出全屏</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/23/javaweb常见HTTP状态码/">javaweb常见HTTP状态码</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/liangxinwei" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">梁新维.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>