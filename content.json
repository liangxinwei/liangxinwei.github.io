{"meta":{"title":"梁新维","subtitle":"sometimes code， sometimes design","description":null,"author":"liangxinwei","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-12-29T13:14:25.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"简介前端工程师，在向全栈工程师努力中··· 联系方式邮箱：liangxw6004@qq.comGitHub：https://github.com/liangxinwei"},{"title":"分类","date":"2019-12-29T13:13:10.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-29T13:13:46.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2019年终总结","slug":"2019年终总结","date":"2019-12-30T10:56:06.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2019/12/30/2019年终总结/","link":"","permalink":"http://yoursite.com/2019/12/30/2019年终总结/","excerpt":"","text":"","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]},{"title":"2020Flag","slug":"2020Flag","date":"2019-12-29T10:56:06.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2019/12/29/2020Flag/","link":"","permalink":"http://yoursite.com/2019/12/29/2020Flag/","excerpt":"","text":"工作 Icon 独立为项目（React、Vue）各一份、便于代码复用 DDL：2020-04-30 看技术书籍、设计书籍、产品书籍 DDL：2020-12-31 一个月一本 技术书籍： 计算机网络 软件工程 设计书籍： 写给大家看的设计书 简约至上 dont make me think 点石成金 产品书籍： 《幕后产品》王诗沐 《有效需求分析》徐锋 学习 TypeScript 并能有配套练习项目 DDL：2020-06-30 学习Node.js 后台并能有配套练习项目 DDL：2020-12-31，2020-06-30 完成 70% 学习MySQL、redis、MongoDB并能有配套练习项目 DDL：2020-12-31，2020-06-30 完成 70% 其他 搭建自己的GitHub Pages博客 练字，达到字迹工整、美观的效果 读一些哲学方面的书 健身，年中能有8块腹肌 学英语，单词量10000，不看字母能听懂英文电影","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[]},{"title":"B端产品经理长成读书笔记","slug":"B端产品经理长成读书笔记","date":"2019-09-12T14:51:34.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2019/09/12/B端产品经理长成读书笔记/","link":"","permalink":"http://yoursite.com/2019/09/12/B端产品经理长成读书笔记/","excerpt":"","text":"PMBOK：项目管理知识体系 Project Management Body Of Knowledge 产品的规则设计：1、精神理念：什么最重要2、目标：产品要达成什么目标3、谁更重要：多方冲突时保护谁4、鼓励什么：什么事再产品中会受到认可和激励5、拒绝什么：什么事不能在产品中做？禁止和惩罚什么？ 方案出错，90%是问题出错了问题-拆解-方案-结论 原则1、定义问题，2、拆解问题，3、导出方案，4、评估得出结论 更高的时间和行动成本会拉低用户对产品的需求 RFM模型RFM是最经典的客户消费行为特征分析模型，RFM代表Recency（最近一次消费时间），Frequency（某一个时间范围内的消费频次），Monetary（某一个时间范围内的平均客单价或累计交易额）。根据公司实际数据情况，将这三个指标划分成几档，可以形成多种组合（假设每个指标分五档，则可产生5x5x5个组合），对这些组合进行聚类分析，提炼出行为模式类似的多个群体，实现对客户消费特征的群体细分。 数据集市 DM Data Mart数据仓库 DW Data WarehouseBI Business Intelligence 数据仓库和大数据是两个完全不同的概念,它们在理念、技术方案、应用领域方面都完全不同,具体如下。·理念:数据仓库源于交易数据,对数据的准确性要求高,适合做离线分析;大数据源于日志的行为数据,对数据准确性要求不高,适合做自动化策略。技术方案:数据仓库采用传统的、经典的数据分析思路,即抽样、分析、预测;大数据基于海量数据和运算能力,不做抽样而做全量研究,不做分析而做模型应用。应用领域:数据仓库主要用来做企业经营分析;大数据主要用来做各种业务自动化应用。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[]},{"title":"九败一胜读书笔记","slug":"九败一胜读书笔记","date":"2019-08-19T14:02:58.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2019/08/19/九败一胜读书笔记/","link":"","permalink":"http://yoursite.com/2019/08/19/九败一胜读书笔记/","excerpt":"","text":"获取的长期经验不是最重要的，快速学习能力是决定一个人发展现状及未来前景的重要因素。 总重契约精神，总重大家共同制订好的游戏规则，没有这个，创业就无从谈起。 CEO不可被人代替的指责是：设计公司整体愿景和所有战略，确保传达给所有利益相关方，不仅是管理层，包括所有员工，不仅是公司内部人，包括股东、消费者、商户和所有合作伙伴；招到并留住最优秀的人；确保公司要有足够的资金。 以身作则不是塑造公司价值观的最好办法，而是唯一办法。 把所有东西考虑清楚再去讨论能不能做。 2004-2009校内网给他们的经验和教训： 创业团队必须分工明确，CEO必须解放出来，关注整个业界、时代、社会发展的潮流。 快速推广很重要。 没有盲目地自我创新，快速学习别人的优点。比如模仿Facebook，在节省成本的同时，让用户有了当时一流的UI体验。 对资本的看法太过理想化了。应该更早的接触资本，降低姿态，做一些妥协。 必须和信任的人一起创业。唯有信任才能在遇到低潮的情况下让团队依旧坚持稳固。 O2O 线上线下：线上交易，线下消费 保持对未知的世界充满好奇，先把更多的会放进自己的视，才有抉择的余地。 对于社会能产生真实价值的东西，是事业最稳定的基石。不管这种东西是解决人与人的关系，还是解决人与物的关系。 互联网时代是”产品为王”的时代，是完美主义者有着系统性优势的时代。只有完美主义的人，才能把产品打磨的那么出色，产品出色，整个公司就赢了。 任何一个部门，一年只要做对一件事就能获得成功 招聘进来的人的水准应该比现有团队50%的人高，整个团队才会越来越强 对未来越有信心，对现在越有耐心。 一家老有新闻的企业并非好事，在那些枯燥，平凡的日常管理细节里，每天前进一点，日积月累，短期内看不出公司发生了多少变化，把观察时间放长一点，三五年，你就会发现这家公司可能已经脱胎换骨了。这同样适用于每个人。 未来是不确定的，只能战战兢兢，如履薄冰。 一如既往的好奇心，超强的学习能力。 免费的根本问题在于真正的免费如何盈利。 想要构建产品壁垒，就最好做自己擅长的部分。 无数平庸的细节堆积出来的，就是平庸的产品。 如果你希望在一个好的创业公司一路高歌猛进的话，每一年都是关键的一年。 小公司做起来的关键是抓住了一个机会，中等公司的关键是有一批比较强的高管，大公司的关键是要有正确的流程和价值观。 企业创始人的价值观决定整个企业其他人对待整个市场的方式。美团网价值观的排序是：消费者第一、商家第二、员工第三、股东第四、王兴第五。 核心价值观的渗透度越高，整个企业的人员稳定性才越强。公司的使命、愿景、价值观，这些看起来是虚无缥缈的东西，确是团队精神生长的坚实土地。 CEO履行好自己的指责，其他事情都应该找最专业、最好的人来做。 团队的组件原则：招进来的人，水准应该比现有团队50%的人高。只要按照这个标准，整个团队会越来越强。 公司越来越大，为了保障公司的正常运转，需要一套行之有效的组织架构和严密的流程。系统和流程保障了分工明确、权责到位，不易出差错；另一方面却让跨部门合作变得越来越困难，效率在沟通中损耗，创新的热情和机会就有可能在这些损耗中溜掉。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/categories/读书笔记/"}],"tags":[]},{"title":"roadhog 1.3.X 打包慢的解决办法","slug":"roadhog-1-3-X-打包慢的解决办法","date":"2019-06-11T11:01:51.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2019/06/11/roadhog-1-3-X-打包慢的解决办法/","link":"","permalink":"http://yoursite.com/2019/06/11/roadhog-1-3-X-打包慢的解决办法/","excerpt":"","text":"背景：公司的后台管理系统项目基于 Antd Pro 早期版本，使用的脚手架是 roadhog，虽然接入了 dva 等框架，方便了我们把工作重心集中在业务上，但是随着项目的庞大，问题随之而来，首当其冲的就是线上部署的时候打包慢的问题。因为 road 的扩展不太灵活，其本身的初衷就是尽可能减少webpack的配置，所以如何降低打包的速度就成了亟需解决的问题。 项目依赖58个，打包之后140个文件。 网上搜了一圈，发现没有令人满意的解决方案，只好自己来解决。仔细缕了一遍思路后发现，还是有解决办法的。 以下改动仅适用于公司的后台管理系统项目。 删除项目中没有用到或废弃的代码 利用好 roadhog 支持的 webpack 配置项 自己改 roadhog 的源码，然后发布为 npm 包，替换掉 roadhog 第一项不用说。 第二项是设置 webpack 的 externals，由于项目中用到了 g2、d3、echarts、@antv/data-set、moment、g-cloud、g2-plugin-slider、cal-heatmap 等 js 库，所以把它们都配置到 externals 下： 12345678910111213141516171819202122232425262728&#123; \"entry\": \"src/index.js\", \"extraBabelPlugins\": [ \"transform-runtime\", \"transform-decorators-legacy\", \"transform-class-properties\", [\"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": true &#125;] ], \"env\": &#123; \"development\": &#123; \"extraBabelPlugins\": [ \"dva-hmr\" ] &#125; &#125;, \"externals\": &#123; \"g2\": \"G2\", \"echarts\": \"echarts\", \"@antv/data-set\": \"DataSet\", \"moment\": \"moment\", \"g-cloud\": \"Cloud\", \"g2-plugin-slider\": \"G2.Plugin.slider\" &#125;, \"ignoreMomentLocale\": true, \"theme\": \"./src/theme.js\", \"hash\": true, \"multipage\": true&#125; 在 .eslint.js 将其配置为全局变量： 1234567\"globals\": &#123; \"CalHeatMap\": true, \"DataSet\": true, \"moment\": true, \"echarts\": true, \"G2\": true&#125; 以上注意： 配置 &quot;multipage&quot;: true 后，roadhog 才会把超过2次引用的依赖打为 common 包 “dva-hmr” 设置在 development 才会避免生产环境下将其打包，因为生产环境下不会用到 将这些 js 库文件（不用包涵g-cloud、g2-plugin-slider）下载下来，放到项目根目录下 public/js 下，roadhog 作者约定 public 目录下的文件会在 server 和 build 时被自动 copy 到输出目录（默认是 ./dist）下。所以可以在这里存放 favicon, iconfont, html, html 里引用的图片等。 手动在 index.ejs 里面将其引入 第三项 主要改动的地方： common.js 下 HtmlWebpackPlugin 插件配置的地方，给它配置 public 下的所有 js 文件和 css 文件的路径和环境变量：1234567891011if (existsSync(join(paths.appSrc, 'index.ejs'))) &#123; const scripts = glob.sync(path.resolve(paths.appPublic) + '/js/*.js').map(filePath =&gt; path.basename(filePath)); const stylesheets = glob.sync(path.resolve(paths.appPublic) + '/stylesheets/*.css').map(filePath =&gt; path.basename(filePath)); ret.push(new HtmlWebpackPlugin(&#123; template: 'src/index.ejs', inject: true, scripts, stylesheets, env: JSON.stringify(NODE_ENV) &#125;));&#125; 然后在你的项目的 index.ejs 中引入： 12345678910111213&lt;head&gt; &lt;% var stylesheets = htmlWebpackPlugin.options.stylesheets || [] %&gt; &lt;% for(var i = 0; i &lt; stylesheets.length; i++) &#123; %&gt; &lt;link rel=\"stylesheet\" href=\"&lt;%= 'stylesheets/' + stylesheets[i] %&gt;\"&gt; &lt;% &#125; %&gt;&lt;/head&gt;&lt;body&gt; &lt;% var scripts = htmlWebpackPlugin.options.scripts || [] %&gt; &lt;% for(var i = 0; i &lt; scripts.length; i++) &#123; %&gt; &lt;script type=\"text/javascript\" src=\"&lt;%= 'js/' + scripts[i] %&gt;\"&gt;&lt;/script&gt; &lt;% &#125; %&gt;&lt;/body&gt; 修改 webpack.config.prod.js 替换 webpack.optimize.UglifyJsPlugin 为： 12345678910...(debug ? [] : [new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, &#125;, &#125;, cache: true, sourceMap: false, parallel: true,&#125;)]), UglifyJsPlugin 的好处不必多说，大家自己 google。 删掉 webpack.optimize.CommonsChunkPlugin 配置，参考 vue-cli2 的配置项： 12345678910111213141516171819202122232425262728293031323334if (config.multipage) &#123; // Support hash const name = config.hash ? 'common.[hash]' : 'common'; // ret.push(new webpack.optimize.CommonsChunkPlugin(&#123; // name: 'common', // filename: `$&#123;name&#125;.js`, // &#125;)); ret = ret.concat([ // split vendor js into its own file // 将所有从node_modules中引入的js提取到vendor.js，即抽取库文件 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks(module) &#123; return (module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf(paths.appNodeModules) === 0); &#125;, &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated // 从vendor中提取出manifest，原因如上 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', minChunks: Infinity, &#125;), // This instance extracts shared chunks from code splitted chunks and bundles them // in a separate chunk, similar to the vendor chunk // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk new webpack.optimize.CommonsChunkPlugin(&#123; name, async: 'vendor-async', children: true, minChunks: 3, &#125;), ]);&#125; 然后，运行 npm run test，npm run build，编译好之后，发布到 npm 仓库如 liangxinwei_roadhog。 最后，删掉项目下的 package.json 里面 roadhog 相关的依赖，替换为 &quot;liangxinwei_roadhog&quot;: &quot;^1.0.0&quot;： 12345\"devDependencies\": &#123; - \"roadhog\": \"^1.3.1\", - \"roadhog-api-doc\": \"^0.1.0\", + \"liangxinwei_roadhog\": \"^1.0.0\",&#125;, 修改启动和打包命令： 12\"start\": \"node --max_old_space_size=4096 node_modules/liangxinwei_roadhog/lib/server.js\",\"build\": \"node --max_old_space_size=4096 node_modules/liangxinwei_roadhog/lib/build.js\" 经过我前后的数据比对，修改第二项之后，打包时间由原来的 20-30min 缩减到 5-6min，修改第三项之后，初次打包时间为 3-4min，再次打包时间缩减到 1min 之内。大功告成！ 前端开发长路漫漫，大家且行且珍惜。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"webpack各配置项全解析","slug":"webpack各配置项全解析","date":"2019-01-30T10:59:45.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2019/01/30/webpack各配置项全解析/","link":"","permalink":"http://yoursite.com/2019/01/30/webpack各配置项全解析/","excerpt":"","text":"以下所以内容摘自【深入浅出webpack】，包含每一项的具体配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259const path = require('path');module.exports = &#123; /** * entry 表示入口, Webpack 执行构建的第一步将从 Entry 开始,可抽象成输入，类型可以是 string、 object、 array */ // 只有 1 个入口,入口只有 1 个文件 entry: ' ./app/entry', // 只有1个入口,入口有两个文件 entry: ['./app/entry1', './app/entry2'], // 有两个入口 entry: &#123; a: './app/entry-a', b: ['./app/entry-bl', './app/entry-b2'] &#125;, /** * 如何输出结果 : 在 Webpack 经过一系列处理后,如何输出最终想要的代码 */ output: &#123; // 输出文件存放的目录,必须是 string 类型的绝对路径 path: path.resolve(dirname, ' dist '), // 输出文件的名称 // 完整的名称 filename: ' bundle.js', // 在配置了多个 entry 时,通过名称模板为不同的 entry 生成不同的文件名称 filename: ' [name].js', // 根据文件内容的 Hash 值生成文件的名称, 用于 浏览器长时间缓存文件 filename: ' [chunkhash].js', // 放到指定目录下 // 发布到线上的所有资源的 URL 前缀,为 string 类型 publicPath: '/assets/', // 放到根目录下 publicPath: '', // 放到 CDN 上 // 导出库的名称 , 为 string 类型, 不填它时,默认的输出格式是匿名的立即执行函数 publicPath: 'https://cdn.example.com/', library: ' MyLibrary ', // 导出库的类型,为枚举类型,默认是 var // 可以是umd、 umd2、 commonjs2、 commonjs、 amd、 this、 var、 assign、 window、global、jsonp libraryTarget: 'umd', // 是否包含有用的文件路径信息到生成的代码里 ,为 boolean 类型 pathinfo: true, // 附加 Chunk 的文件名称 chunkFilename: '[id].js', chunkFilename: '[chunkhash].js', // JSONP 异步加载资源时的回调函数名称,需要和服务端搭配使用 jsonpFunction: 'myWebpackJsonp', // 生成的 Source Map 文件的名称 // 浏览器开发者工具里显示的源码模块名称 sourceMapFilename: '[file].map', // 异步加载跨域的资源时使用的方式 devtoolModuleFilenameTemplate: 'webpack:lll[resource-path]', crossOriginLoading: 'use-credentials', crossOriginLoading: 'anonymous', crossOriginLoading: false &#125;, /** * 配置模块相关 */ module: &#123; // 不用解析和处理的模块，Webpack忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能 // 注意，被忽略掉的文件里不应该包含 import、 require、 define 等模块化语句，不\\然会导致在构建出的代码中包含无法在浏览器环境下执行的模块化语句。 //单独、完整的 、react.min.js、文件没有采用模块化，忽略对 、react.min.js、文件 的递归解析处理 noParse: [/react\\.min\\.js$/], // 配置 Loader rules: [ &#123; // 正则匹配命中要使用 Loader 的文件 test: /\\.jsx$/, // 只会命中这里面的文件 include: [ path.resolve(__dirname, 'src') ], // 忽略这里面的文件 exclude: [ path.resolve(__dirname, 'node_modules') ], // 使用哪些 Loader,有先后次序,从后向前执行 use: [ // style-loader会将 css代码转换成字符串后，注入 JavaScript代码中，通过 JavaScript 向 DOM 增加样式。 如果我们想将 css 代码提取到一个单独的文件中，而不是和 JavaScript 混在 一 起，则可以使用 ExtractTextPlugin 'style-loader', // css-loader 会找出 css 代码中 eimport 和 url ()这样的导入语句，告诉 Webpack 依赖这些资源 。 同时支持 CSS Modules、压缩 css 等功能 。处理完后再将结果交给 style-loader处理。 'css-loader', // 通过 sass-loader将 scss 源码转换为 css 代码，再将 css 代码交给 css-loader处理。 'sass-loader', // 直接使用 Loader 的名称 &#123; loader: 'css-loader', // 向 html-loader 传一些参数 options: &#123;&#125; &#125;, ], // 不用解析和处理的模块，Webpack忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能 noParse: [ // 用正则匹配 /special-library\\.js$/ ] &#125; ], /** * 配置插件 */ plugins: [], /** * 配置寻找模块的规则 */ resolve: &#123; // 寻找模块的根目录,为 array 类型,默认以 node_modules 为根目录 // 可以指明存放第三方模块的绝对路径，以减少寻找， dirname 表示当前工作目录 modules: [path.resolve(__dirname, 'node_modules')], modules: [ 'node modules ', path.resolve(__dirname, 'app') ], // 模块的后缀名，后缀尝试列表要尽可能小，频率出现最高的文件后缀要优先放在最前面 extensions: ['.js', 'json', 'jsx', '.css'], // 模块别名配置,用于映射模块，从而跳过耗时的递归解析操作。 alias: &#123; // 将 'module'映射成'new-module' ,同样, 'module/path/file'也会被映射 成'new-module/path/file' 'module': 'new-module', // 使用结尾符号$后 ,将 'only-module' 映射成 'new-module', // 但是不像上面的 ,' module/path/file '不会被映射成' new-module/path/file 'only-module$': 'new-modules', &#125;, // alias 还支持使用数组来更详细地进行配置 alias: [ &#123; // 老模块 name: 'module', // 新模块 alias: 'new-module ', // 是否只映射模块,如果是 true, 则只有' module '会被映射:如果是 false,则'module/inner/path '也会被映射 onlyModule: true, &#125; ], // 是否跟随文件的软链接去搜寻模块的路径 symlinks: true, // 模块的描述文件 descriptionFiles: [' package.json '], // 模块的描述文件里描述入口的文件的字段名 mainFields: [' main '], // 是否强制导入语句写明文件后缀 enforceExtension: false &#125;, /** * 输出文件的性能检查配置 */ performance: &#123; // 有性能问题时输出警告 hints: 'warning ', // 有性能问题时输出错误 hints: 'error ', // 关闭性能检查 hints: false, // 最大文件的大小(单位为 bytes) maxAssetSize: 200000, // 最大入口文件的大小 (单位为 bytes) maxEntrypointSize: 400000, // 过滤要检查的文件 assetFilter: function (assetFilename) &#123; return assetFilename.endsWith(' .css ') || assetFilename.endsWith('.js'); &#125; &#125;, // 配置 source-map 类型 devtool: ' source-map ', // Webpack 使用的根目录, string 类型必须是绝对路径 // 配置输出代码的运行环境 context: __dirname, // 浏览器,默认 target: 'web', // WebWorker target: 'webworker', // Node.js,使用 、require、语句加载 Chunk代码 target:'async-node', II Node.js,异步加载 Chunk代码 target: 'node', // nw.js target: 'node-webkit', // electron,主线程 target: 'electron-main', // electron,渲染线程 target: 'electron-renderer', // 使用来自 JavaScript 运行环境提供的全局变量 externals: &#123; jquery: 'jQuery' &#125; , /** * 控制台输出日志控制 */ stats: &#123; assets: true, colors: true, errors: true, errorDetails: true, hash: true &#125; , /** * DevServer 相关的配置 */ devServer: &#123; // 代理到后端服务接口 proxy: &#123; '/api': 'http:// localhost:3000' &#125; , // 配置 DevServer HTTP 服务器的文 件根目录 contentBase: path.join(__dirname, 'public'), // 是否开启 Gzip 压缩 compress: true, // 是否开发 HTMLS History API 网页 historyApiFallback: true, // 是否开启模块热替换功能 hot: true, // 是否开启 HTTPS 模式 https: false, // 是否捕捉 Webpack构建的性能信息,用于分析是什么原因导致构建性能不佳 profile: true, // 是否启用缓存来提升构建速度 cache: false, // 是否开始 watch: true, // 监听模式选项 // 不监听的文件或文件夹,支持正则匹配。默认为空 watchOptions: &#123; ignored: /node modules/, // 监听到变化发生后,等 300ms 再执行动作,截流,防止文件更新太快导致重新编 译频率太快。默认为 300ms aggregateTimeout: 300, // 不停地询问系统指定的文件有没有发生变化,默认每秒询问 1000 次 poll: 1000 &#125; &#125; &#125;&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"小程序和h5页面之间的互相跳转","slug":"小程序和h5页面之间的互相跳转","date":"2018-10-23T11:02:45.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2018/10/23/小程序和h5页面之间的互相跳转/","link":"","permalink":"http://yoursite.com/2018/10/23/小程序和h5页面之间的互相跳转/","excerpt":"","text":"小程序跳转到 h5 页面小程序代码： 1wx.navigateTo(&#123;url: &apos;/pages/webview?url=&apos; + encodeURIComponent(&apos;h5页面的 url&apos;)&#125;); webview.js 12345678910111213&lt;web-view src=&quot;&#123;&#123;url&#125;&#125;&quot; bindmessage=&quot;handlePostMessage&quot;&gt;&lt;/web-view&gt;onLoad: function (options) &#123; this.setData(&#123; url: decodeURIComponent(options.url), &#125;);&#125;,// 接收 h5 页面传递过来的参数handlePostMessage: function (e) &#123; const data = e.detail; console.log(data);&#125; h5 页面代码： 1234&lt;head&gt; ··· &lt;script type=&quot;text/javascript&quot; src=&quot;https://res.wx.qq.com/open/js/jweixin-1.3.2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 记得把 url 的 host 添加到后台的合法域名中。 h5 页面跳回小程序在 h5 页面的任何点击事件中： 12345678/* eslint-disable */ wx.miniProgram.getEnv(function (res) &#123; if (res.miniprogram) &#123; wx.miniProgram.switchTab(&#123;url: &apos;/pages/home/home&apos;&#125;); wx.miniProgram.postMessage(&#123;data: &#123;id: &apos;1234&apos;&#125;&#125;); // 传的参数 &#125; &#125;); /* eslint-enable */ 请注意，是wx.miniProgram，不是 window.wx.miniProgram","categories":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/categories/小程序/"}],"tags":[]},{"title":"微信订阅号开发之获取网页授权","slug":"微信订阅号开发之获取网页授权","date":"2018-10-17T11:02:20.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2018/10/17/微信订阅号开发之获取网页授权/","link":"","permalink":"http://yoursite.com/2018/10/17/微信订阅号开发之获取网页授权/","excerpt":"","text":"题记：项目（Vue）是h5页面，主要用于公众号里面的活动，目的是增加公众号关注人数，达到推广的目的，其中涉及到获取用户的昵称、头像、unionid等基本信息。由于微信公众号改版成订阅号之后，并没有获取用户信息的接口，服务号才有，详情可查看官方文档所以目前想到的思路是借用和订阅号关联的服务号获取 code，然后利用获取到的code 发送给后端再请求用户信息。首先，在 App.vue 的 created 中获取 code： 1234567891011import &#123;getUserOpenId&#125; from './utils';created() &#123; this.getUserInfo();&#125;,methods: &#123; getUserInfo(reRequest = false) &#123; const answerId = location.hash.startsWith('#/degenerate-test/result') &amp;&amp; Util.getURLHashParameter('answerId'); getUserOpenId(!answerId ? 'degenerate-test' : 'degenerate-test/result', !answerId ? '' : `answerId=$&#123;answerId&#125;`, reRequest); &#125;&#125; 其中，getUserOpenId 为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 获取 code * @param routePath * @param queryParam */function getCodeUrl(routePath = '', queryParam) &#123; let url = `$&#123;location.protocol&#125;//$&#123;location.host&#125;/h5/`; url += routePath ? `#/$&#123;routePath&#125;` : ''; url += queryParam ? `?$&#123;queryParam&#125;` : ''; url = encodeURIComponent(url); console.log('url:', url); console.log('redirect url:', `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;APP_ID&#125;&amp;redirect_uri=$&#123;url&#125;&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect`); window.location.href = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;APP_ID&#125;&amp;redirect_uri=$&#123;url&#125;&amp;response_type=code&amp;scope=snsapi_userinfo&amp;connect_redirect=1&amp;state=$&#123;Math.random().toString(16).substr(-6)&#125;#wechat_redirect`; // 因为 code 只能使用一次，所以为了确保每次请求到的 code 都是有效的值，此处设置 state 参数为 随机字符串&#125;/** * 获取 user openId * @param routePath * @param queryParam * @param reRequest */function getUserOpenId(routePath, queryParam, reRequest) &#123; const existedUnionId = localStorage.getItem('userUnionId'); if (existedUnionId) &#123; console.log('有 union_id:', existedUnionId, ', 不发请求'); user.actions.setUnionId(store, existedUnionId); new EventManager().trigger('onUserInfoReady'); return; &#125; const code = Util.getUrlSearchParameter('code'); console.log('code', code); if (code &amp;&amp; !reRequest) &#123; axiosInstance.post(Url.USER_INFO, &#123;code&#125;).then(res =&gt; &#123; console.log('用户信息 data', res); res.telephone != null &amp;&amp; user.actions.setTelephoneNumber(store, res.telephone); res.openid != null &amp;&amp; user.actions.setOpenId(store, res.openid); res.unionid != null &amp;&amp; user.actions.setUnionId(store, res.unionid); res.nickname != null &amp;&amp; user.actions.setNickname(store, res.nickname); res.headimgurl != null &amp;&amp; user.actions.setHeadImgUrl(store, res.headimgurl); new EventManager().trigger('onUserInfoReady'); &#125;).catch((res) =&gt; &#123; console.error('获取用户信息出错,', res); Vue.prototype.$toast((res &amp;&amp; res.msg) || '您的授权信息有误，请退出之后重新进入'); &#125;); &#125; else &#123; console.log('没有 code 或者 code 被使用过，微信即将重定向'); getCodeUrl(routePath, queryParam); &#125;&#125; 上面的 APP_ID 即为服务号的 app_id，然后微信会做一次重定向，出现授权弹框页点击授权之后，微信会将 code 以 URL 中 search 的形式传回，前端获取到 code 之后即可发给后端，后端拿到 code 之后，即可返回用户的信息，这个过程比较漫长，应为后端需要向微信获取信息，大概500ms，获取到之后，可以把 unionid 缓存下来，这样以后就不应频繁的请求了。要注意一个问题，因为获取用户信息是一个比较耗时的过程，所以如果活动主页（如 home.vue）有需要用 unionid 作为参数的请求的话，可能用户信息请求还没结束，home.vue 的 mounted 已经执行完毕了，所以会有 unionid 还未取到的情况出现，此处要注意。我使用的是事件管理器（最后面会写出来），等确保获取到 unionid 之后，事件管理器触发活动首页的请求，如果没有 unionid 的话，会重新走一遍上面的流程，先获取 code，然后再重新请求用户信息，这样能确保不会发生 unionid 为 null 的情况。ps: Vue 的执行顺序为 App created -&gt; home created -&gt; home mounted -&gt; app mounted但如果 home.vue 使用的是动态路由加载的话，就不是这个顺序了，此处要特别注意。home： 123456789101112131415161718192021222324computed: &#123; ...mapGetters(['unionId'])&#125;,mounted() &#123; new EventManager().on('onUserInfoReady', this.checkUnionId);&#125;,beforeDestroy() &#123; new EventManager().off('onUserInfoReady');&#125;,methods: &#123; checkUnionId() &#123; console.log('发送请求之前，unionId：', this.unionId); // this.$parent 即为 App.vue if (!this.unionId &amp;&amp; this.$parent.getUserInfo) &#123; this.$toast('获取信息中···'); this.$parent.getUserInfo(true); &#125; else &#123; this.requestData(); // 可利用 unionid 请求数据 &#125; &#125;, async requestData() &#123; // balabalabala &#125;&#125; 下面为 EventManager 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 通用全局事件管理器 单例模式 */let instance;class EventManager &#123; constructor() &#123; if (!instance) &#123; this.onObj = &#123;&#125;; this.oneObj = &#123;&#125;; instance = this; &#125; return instance; &#125; /** * 使用 on 进行订阅的函数，每次事件发生响应时都会被触发 */ on(key, fun) &#123; if (key &amp;&amp; fun &amp;&amp; typeof key === 'string' &amp;&amp; typeof fun === 'function') &#123; this.onObj[key] = this.onObj[key] || []; this.onObj[key].push(fun); &#125; else &#123; console.error('incorrect parameters: the type of parameter key must be string, and the type of parameter fun must be function'); &#125; &#125; /** * 使用 one 进行订阅的函数，只会触发一次 */ one(key, fun) &#123; if (key &amp;&amp; fun &amp;&amp; typeof key === 'string' &amp;&amp; typeof fun === 'function') &#123; this.oneObj[key] = this.oneObj[key] || []; this.oneObj[key].push(fun); &#125; else &#123; console.error('incorrect parameters: the type of parameter key must be string, and the type of parameter fun must be function'); &#125; &#125; /** * 解除所有订阅了某个事件的所有函数 */ off(key) &#123; if (key &amp;&amp; typeof key === 'string') &#123; this.oneObj[key] = []; this.onObj[key] = []; &#125; else &#123; console.error('incorrect parameters: the type of parameter key must be string'); &#125; &#125; /** * 解除所有 */ offAll() &#123; this.oneObj = &#123;&#125;; this.onObj = &#123;&#125;; &#125; /** * 用于发布者发布事件，将除第一参数（事件名）的其他参数，作为新的参数，触发使用 one 与 on 进行订阅的函数 */ trigger(key, ...args) &#123; if (key &amp;&amp; typeof key === 'string') &#123; if (this.onObj[key] !== undefined &amp;&amp; this.onObj[key].length &gt; 0) &#123; this.onObj[key].forEach(v =&gt; &#123; v.apply(null, args); &#125;); &#125; if (this.oneObj[key] !== undefined &amp;&amp; this.oneObj[key].length &gt; 0) &#123; this.oneObj[key].forEach(v =&gt; &#123; v.apply(null, args); &#125;); this.oneObj[key] = []; &#125; &#125; else &#123; console.error('incorrect parameters: the type of parameter key must be string'); &#125; &#125;&#125;export default EventManager; \b最后，贴一个我自己搭的通用公众号网页开发 Vue 项目框架","categories":[{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/categories/小程序/"}],"tags":[]},{"title":"浏览器/iframe 全屏、退出全屏","slug":"浏览器-iframe-全屏、退出全屏","date":"2018-08-15T10:56:06.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2018/08/15/浏览器-iframe-全屏、退出全屏/","link":"","permalink":"http://yoursite.com/2018/08/15/浏览器-iframe-全屏、退出全屏/","excerpt":"","text":"外面的 html 文件 index.html： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;fullScreen&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe allowfullscreen src=&quot;iframe.html&quot; frameborder=&quot;0&quot; style=&quot;width: 500px;height: 500px;background:#aaa&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 里面嵌套的 iframe.html 文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;iframe&lt;/h1&gt; &lt;button id=&quot;button&quot;&gt;全屏&lt;/button&gt; &lt;script&gt; // 判断是否允许全屏 var fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled; // 全屏 function launchFullscreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullScreen(); &#125; &#125; // 退出全屏 function exitFullscreen() &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if (document.msExitFullscreen) &#123; document.msExitFullscreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125; &#125; var btn = document.querySelector(&apos;#button&apos;); if (fullscreenEnabled) &#123; btn.addEventListener(&apos;click&apos;, function () &#123; var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement; if (fullscreenElement) &#123; exitFullscreen(); btn.innerHTML = &apos;全屏&apos;; &#125; else &#123; launchFullscreen(document.documentElement); btn.innerHTML = &apos;退出全屏&apos;; &#125; &#125;, false); &#125; // 监听全屏事件 document.addEventListener(&apos;webkitfullscreenchange&apos;, function fullscreenChange() &#123; if (document.fullscreenEnabled || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) &#123; console.log(&apos;enter fullscreen&apos;); &#125; else &#123; console.log(&apos;exit fullscreen&apos;); &#125; &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"javaweb常见HTTP状态码","slug":"javaweb常见HTTP状态码","date":"2017-12-23T10:53:27.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2017/12/23/javaweb常见HTTP状态码/","link":"","permalink":"http://yoursite.com/2017/12/23/javaweb常见HTTP状态码/","excerpt":"","text":"客户端 404 -Not Found 代表客户端错误，指的是服务器端无法找到所请求的资源 400 -请求无效，服务器不理解请求的语法 403 - 禁止访问 ，服务器拒绝请求 405 - 资源被禁止，禁用请求中指定的方法 406 - 无法接受 ，无法使用请求的内容特性响应请求的网页 407 - 要求代理身份验证 ，此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理 408 - 请求超时，服务器等候请求时发生超时 409 - 冲突，服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息 410 - 已删除，如果请求的资源已永久删除，服务器就会返回此响应。 411 - 需要有效长度， 服务器不接受不含有效内容长度标头字段的请求。 412 - 未满足前提条件， 服务器未满足请求者在请求中设置的其中一个前提条件。 413 - 请求实体过大，服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 - 请求的 URI 过长， 请求的 URI（通常为网址）过长，服务器无法处理。 415 - 不支持的媒体类型， 请求的格式不受请求页面的支持。 416 - 请求范围不符合要求，如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 - 未满足期望值，服务器未满足”期望”请求标头字段的要求 500 - 内部服务器错误，无法完成请求 501 - 未实现 ，服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码 502 - 网关错误 ，服务器作为网关或代理，从上游服务器收到无效响应 503 - 服务不可用，服务器目前无法使用，通常，这只是暂时状态 504 - 网关超时， 服务器作为网关或代理，但是没有及时从上游服务器收到请求 505 - HTTP 版本不受支持， 服务器不支持请求中所用的 HTTP 协议版本 服务端 2xx - 客户端请求已成功。 200 - 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页 201 - 已创建，请求成功并且服务器创建了新的资源 202 - 已接受，但尚未处理 203 - 非权威性信息，服务器已成功处理了请求，但返回的信息可能来自另一来源 204 - 无内容，服务器成功处理了请求，但没有返回任何内容 205 - 重置内容，服务器成功处理了请求，但没有返回任何内容 206 - 部分内容，服务器成功处理了部分 GET 请求 3xx - 重定向 302 - 对象已移动 304 - 未修改 307 - 临时重定向 附上全部状态码：HTTP response codes","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"javascript循环与闭包","slug":"javascript循环与闭包","date":"2017-11-08T10:54:53.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2017/11/08/javascript循环与闭包/","link":"","permalink":"http://yoursite.com/2017/11/08/javascript循环与闭包/","excerpt":"","text":"当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 下面我们来看一段代码，清晰地展示了闭包： 123456789function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 —— 这就是闭包的效果。 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz() ，实际上只是通过不同的标识符引用调用了内部的函数 bar() 。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。 要说明闭包， for 循环是最常见的例子。 12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000);&#125; 正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。 仔细想一下，延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0) ，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i 。 我们来试一下通过声明并立即执行一个函数来创建作用域 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function () &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000); &#125;)();&#125; 这样不行。但是为什么呢？我们现在显然拥有更多的词法作用域了。的确每个延迟函数都会将 IIFE（立即执行函数表达式） 在每次迭代中创建的作用域封闭起来。如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。它需要有自己的变量，用来在每个迭代中储存 i 的值： 12345678for (var i = 1; i &lt;= 5; i++) &#123; (function () &#123; var j = i; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)();&#125; 行了！它能正常工作了！。 可以对这段代码进行一些改进： 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function (j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)(i);&#125; 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 仔细思考我们对前面的解决方案的分析。我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。 let 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。因此，下面的代码可以正常运行了： 123456for (var i = 1; i &lt;= 5; i++) &#123; let j = i; // 是的，闭包的块作用域！ setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000);&#125; 但是，这还不是全部！for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000);&#125; 这样，问题解决了！","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"记一次管理系统和路由系统的整合","slug":"记一次管理系统和路由系统的整合","date":"2017-09-28T10:58:27.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2017/09/28/记一次管理系统和路由系统的整合/","link":"","permalink":"http://yoursite.com/2017/09/28/记一次管理系统和路由系统的整合/","excerpt":"","text":"需求：整合管理系统和路由系统UI：同 Ant Design Pro \b 分析由于左侧管理菜单内容在运行时才能确定，而且点击菜单要和右侧内容区联动，地址栏也要有相应的改变，而目前已有的路由系统都是要运行之前要确定具体的路由组建，因此采用 h5 的 history 和 传统的 document.location 结合的方式实现路由系统；整个项目的数据管理则因为考虑到左侧菜单对应的组件可能会使用包括 redux/mbox/dva/kao 之类的框架，如果也使用框架的话，可能会引起冲突，故通过 react 的 context 来实现。 路由系统 router.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889let instance = undefined;class Router &#123; constructor() &#123; if (!instance) &#123; this.history = window.history; this.location = window.location; instance = this; &#125; return instance; &#125; goBack = (cb) =&gt; &#123; this.history.back(); cb &amp;&amp; cb(); &#125; goForward = (cb) =&gt; &#123; this.history.forward(); cb &amp;&amp; cb(); &#125; go = (num, cb) =&gt; &#123; this.history.go(num); cb &amp;&amp; cb(); &#125; pushState = (url, state, cb) =&gt; &#123; url = url || ''; // 加 #，以 hash 的方式改变 url；如果不加，直接以 '/abc' 更改，刷新会报错，请求不到资源（js,css,···） url = url[0] === '/' ? `#$&#123;url&#125;` : `/#$&#123;url&#125;`; this.history.pushState(state || null, '', url); cb &amp;&amp; cb(); &#125; replaceState = (url, state, cb) =&gt; &#123; url = url || '/'; url = url[0] === '/' ? `#$&#123;url&#125;` : `/#$&#123;url&#125;`; this.history.replaceState(state || null, '', url); cb &amp;&amp; cb(); &#125; currentState = () =&gt; &#123; return this.history.state; &#125; currentUrl = () =&gt; &#123; let url = this.location.hash.replace('#', ''); if (url[0] === '/') &#123; url = url.replace('/', ''); &#125; return url; &#125; rootUrl = () =&gt; &#123; return this.location.host; &#125; originUrl = () =&gt; &#123; return this.location.origin; &#125; fullUrl = () =&gt; &#123; return this.location.href; &#125; historyLength = () =&gt; &#123; return this.history.length; &#125;&#125;/** * 拦截器 拦截读写权限 */const handler = &#123; set(target, key, value) &#123; throw new Error(`Setting the $&#123;key&#125; prototype is forbidden`); &#125;, deleteProperty(target, key) &#123; throw new Error(`Deleting the $&#123;key&#125; prototype is forbidden`); &#125;, defineProperty (target, key, descriptor) &#123; throw new Error(`Defining the $&#123;key&#125; prototype is forbidden`); &#125;, setPrototypeOf (target, proto) &#123; throw new Error('Changing the prototype is forbidden'); &#125;&#125;;const routerInstance = new Proxy(new Router(), handler); 路由装饰函数 withRouter.js12345678910111213141516171819202122232425262728293031323334353637383940414243const withRouter = (config = &#123;&#125;) =&gt; (WrapComponent) =&gt; &#123; return class Component extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; data: &#123;&#125; &#125;; &#125; componentDidMount() &#123; config.listenPopState === true &amp;&amp; window.addEventListener('popstate', this.handlePopState); &#125; handlePopState = (data) =&gt; &#123; this.setState(&#123;data: data&#125;); &#125; componentWillUnmount() &#123; config.listenPopState === true &amp;&amp; window.removeEventListener('popstate', this.handlePopState); &#125; render() &#123; const router = &#123; go: routerInstance.go, goBack: routerInstance.goBack, fullUrl: routerInstance.fullUrl, rootUrl: routerInstance.rootUrl, originUrl: routerInstance.originUrl, goForward: routerInstance.goForward, pushState: routerInstance.pushState, currentUrl: routerInstance.currentUrl, replaceState: routerInstance.replaceState, currentState: routerInstance.currentState, historyLength: routerInstance.historyLength &#125;; return React.createElement(WrapComponent, &#123; routerData: this.state.data, router: new Proxy(router, handler),// handler 上面定义的拦截器 ...this.props &#125;); &#125; &#125;;&#125;; 入口组建 App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import React from 'react';import PropTypes from 'prop-types';import &#123;Layout&#125; from 'antd';import GYSider from './GYSider';import GYHeader from './GYHeader';import GYContent from './GYContent';import Test_1 from '../app/Test_1';import Test_2 from '../app/Test_2';import Test_3 from '../app/Test_3';import Test_1_1_1 from '../app/Test_1_1_1';import &#123;withRouter&#125; from '../util/router';import Util from '../util/Util';const &#123;Header, Sider, Content&#125; = Layout;@withRouter()class App extends React.Component &#123; constructor(props) &#123; super(props); const propsState = props.initialState || &#123;&#125;; const initialState = &#123; menuList: [ &#123; path: 'test_1', icon: 'user', text: 'test_1', component: Test_1, children: [ &#123; path: 'test_1/test_1_1', text: 'test_1_1', children: [ &#123; path: 'test_1/test_1_1/test_1_1_1', component: Test_1_1_1, text: 'test_1_1_1' &#125; ] &#125; ] &#125;, &#123; path: 'test_2', icon: 'setting', text: 'test_2', component: Test_2 &#125;, &#123; path: 'test_3', icon: 'logout', text: 'test_3', component: Test_3 &#125; ] &#125;; this.state = &#123; store: &#123; menuList: initialState.menuList.concat(propsState.menuList || []) &#125;, collapsed: false, currentPath: '', currentComponent: GYContent &#125;; this.getAllComponent(this.state.store.menuList); &#125; /** * 保存所有的路由对应的组件 */ getAllComponent = (menuList = []) =&gt; &#123; this.allComponent = this.allComponent || new Map(); menuList.forEach(val =&gt; &#123; if (val.path &amp;&amp; Util.isReactComponent(val.component)) &#123; this.allComponent.set(val.path, val.component); &#125; if (Util.isArray(val.children)) &#123; this.getAllComponent(val.children); &#125; &#125;); &#125; static contextTypes = &#123; store: PropTypes.object, onClickAction: PropTypes.func &#125; static childContextTypes = &#123; store: PropTypes.object.isRequired, onClickAction: PropTypes.func.isRequired &#125; /** * 子组件获取 store */ getChildContext() &#123; return &#123; store: this.state.store, onClickAction: this.handleClickAction &#125;; &#125; /** * 更新 store 时需要返回合并之后的数据 */ handleClickAction = (data) =&gt; &#123; this.setState(Object.assign(this.state, data)); &#125; componentWillMount() &#123; // 刷新浏览器，跳转到相应页面 const currentPath = this.state.currentPath; const documentHref = this.props.router.currentUrl(); if (currentPath !== documentHref &amp;&amp; this.allComponent.has(documentHref)) &#123; this.setState(&#123; currentComponent: this.allComponent.get(documentHref) &#125;); &#125; &#125; onToggle = () =&gt; &#123; this.setState(&#123; collapsed: !this.state.collapsed &#125;); &#125; onCollapse = () =&gt; &#123; console.log('onCollapse'); &#125; render() &#123; const Component = this.state.currentComponent; return ( &lt;Layout className='gy-app-view'&gt; &lt;Sider collapsible breakpoint=\"md\" width=&#123;256&#125; collapsed=&#123;this.state.collapsed&#125; trigger=&#123;null&#125; onCollapse=&#123;this.onCollapse&#125; &gt; &lt;GYSider/&gt; &lt;/Sider&gt; &lt;Layout&gt; &lt;Header className='header'&gt; &lt;GYHeader collapsed=&#123;this.state.collapsed&#125; onToggle=&#123;this.onToggle&#125;/&gt; &lt;/Header&gt; &lt;Content className='gy-content'&gt; &lt;Component/&gt; &lt;/Content&gt; &lt;/Layout&gt; &lt;/Layout&gt; ); &#125;&#125;export default App; 侧边栏组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import React, &#123;Component&#125; from 'react';import &#123;Menu, Icon&#125; from 'antd';const SubMenu = Menu.SubMenu;import Util from '../util/Util';import &#123;withRouter&#125; from '../util/router';import connectStore from '../util/connectStore';@withRouter() // 接入路由@connectStore // 接入 storeclass GYSider extends Component &#123; constructor(props) &#123; super(props); &#125; componentWillReceiveProps(nextProps, nextContext) &#123; console.log('点击 subMenu 更新 store', nextContext.store); &#125; onMenuClick = (&#123;item, key, keyPath&#125;) =&gt; &#123; let self = this; const path = item.props.path; const currentUrl = this.props.router.currentUrl() || ''; path &amp;&amp; path !== currentUrl &amp;&amp; item.props.component &amp;&amp; self.props.router.pushState(`/$&#123;path&#125;`, &#123;path: `/$&#123;path&#125;`&#125;, () =&gt; &#123; self.context.onClickAction(&#123; currentPath: path, currentComponent: item.props.component &#125;); &#125;); &#125; /** * 更新 store 示例 */ onSubMenuClick = (&#123;key, domEvent&#125;) =&gt; &#123; let store = this.context.store; this.context.onClickAction(&#123;store: Object.assign(store, &#123;[key]: key&#125;)&#125;); &#125; createMenu = (arr = []) =&gt; &#123; return arr.map &amp;&amp; arr.map(val =&gt; &#123; if (!val.text) &#123; return undefined; &#125; else &#123; const key = val.path || Util.generateKey(); return Util.isArray(val.children) ? &lt;SubMenu key=&#123;key&#125; onTitleClick=&#123;this.onSubMenuClick&#125; title=&#123;&lt;span&gt;&#123;val.icon &amp;&amp; &lt;Icon type=&#123;`$&#123;val.icon&#125;`&#125;/&gt;&#125; &lt;span&gt; &#123;val.text&#125; &lt;/span&gt; &lt;/span&gt;&#125;&gt; &#123;this.createMenu(val.children)&#125; &lt;/SubMenu&gt; : &lt;Menu.Item path=&#123;val.path&#125; key=&#123;key&#125; component=&#123;val.component&#125;&gt; &#123;val.icon &amp;&amp; &lt;Icon type=&#123;`$&#123;val.icon&#125;`&#125;/&gt;&#125; &lt;span&gt; &#123;val.text&#125; &lt;/span&gt; &lt;/Menu.Item&gt;; &#125; &#125;).filter(val =&gt; val !== undefined); &#125; render() &#123; return ( &lt;div&gt; &lt;div className='logo'&gt;&lt;/div&gt; &lt;Menu theme=\"dark\" mode=\"inline\" onClick=&#123;this.onMenuClick&#125; style=&#123;&#123;margin: '16px 0', width: '100%'&#125;&#125; &gt; &#123;this.createMenu(this.context.store.menuList)&#125; &lt;/Menu&gt; &lt;/div&gt; ); &#125;&#125;export default GYSider; 接入 store 装饰函数 connectStore.js123456789101112import PropTypes from 'prop-types';export default function connectStore(Component) &#123; if (!Component || typeof Component !== 'function') &#123; console.error(`$&#123;Component &amp;&amp; Component.name&#125; is not a class`); return; &#125; Component.contextTypes = &#123; store: PropTypes.object, onClickAction: PropTypes.func &#125;;&#125; 使用示例1234567891011121314151617181920212223242526272829303132333435363738import React, &#123;Component&#125; from 'react';import 上面的入口组建 Appimport UMD from './UMD';class WrapView extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; let initialState = &#123; menuList: [ &#123; path: 'umd', //对应的地址栏 url icon: 'setting', //侧边栏的显示图标 text: 'umd', //侧边栏的显示文字 component: UMD //点击时对应的右侧内容区组件 &#125; ] &#125;; return ( &lt;App initialState=&#123;initialState&#125;/&gt; ); &#125;&#125;export default WrapView;···import React from 'react';import &#123;render&#125; from 'react-dom';import WrapView from './app/components/WrapView';/** * Main App View */render(&lt;WrapView /&gt;, document.getElementById('app')); 核心思路是通过 context 达到类似于 redux 管理数据的目的，App.js 提供 store（存储数据） 和 onClickAction（修改 store）给子组件，子组件通过 connectStore 装饰函数获取到 store 和 onClickAction，点击侧边栏的时候，先取到设置的 path 和 component，然后通过 onCLickAction 设置 currentComponent 和 currentPath，然后 setState 即可实现需求。目前还有一个问题，就是刷新浏览器的时候如何跳转到相应的页面呢？可以在 App.js 里面先获取到所有的 component 和 path 然后保存起来： 1234567891011121314/*** 保存所有的路由对应的组件*/getAllComponent = (menuList = []) =&gt; &#123; this.allComponent = this.allComponent || new Map(); menuList.forEach(val =&gt; &#123; if (val.path &amp;&amp; Util.isReactComponent(val.component)) &#123; this.allComponent.set(val.path, val.component); &#125; if (Util.isArray(val.children)) &#123; this.getAllComponent(val.children); &#125; &#125;);&#125; 再在 App.js 通过以下代码跳转： 12345678910componentWillMount() &#123; // 刷新浏览器，跳转到相应页面 const currentPath = this.state.currentPath; const documentHref = this.props.router.currentUrl(); if (currentPath !== documentHref &amp;&amp; this.allComponent.has(documentHref)) &#123; this.setState(&#123; currentComponent: this.allComponent.get(documentHref) &#125;); &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"Spring Boot 常用注解","slug":"Spring-Boot-常用注解","date":"2017-08-12T10:59:01.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2017/08/12/Spring-Boot-常用注解/","link":"","permalink":"http://yoursite.com/2017/08/12/Spring-Boot-常用注解/","excerpt":"","text":"常见注解 @SpringBootApplication 申明让spring boot自动给程序进行必要的配置， 等价于以默认属性使用@Configuration，@EnableAutoConfiguration和@ComponentScan @Configuration 相当于把该类作为spring的xml配置文件中的，作用为：配置spring容器(应用上下文) 凡是被Spring管理的类，实现接口 EnvironmentAware 重写方法 setEnvironment 可以在工程启动时， 获取到系统环境变量和application配置文件中的变量 @EnableScheduling 在 Spring Boot 的配置类中，标注上这个注解，就可以对项目中的方法某些方法使用@Schedule注解，将其变为定时自动执行。 但只有两种注解共同使用时，才能达到本注解应有的作用。 @Qualifier 限定描述符除了能根据名字进行注入，但能进行更细粒度的控制如何选择候选者 @ImportResource 用来加载xml配置文件。 @Autowired 自动导入依赖的bean @RestController 返回json字符串的数据，直接可以编写RESTFul的接口 @ComponentScan 表示将该类自动发现（扫描）并注册为Bean，可以自动收集所有的Spring组件, 包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。 如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类。 @ServletComponentScan spring能够扫描到自己编写的servlet和filter， SpringBootApplication 上使用@ServletComponentScan注解后，Servlet、Filter、Listener， 可以直接通过 @WebServlet、@WebFilter、@WebListener 注解自动注册，无需其他代码 @Import({DynamicDataSourceRegister.class}) 注册动态多数据源 @PropertySource(value = “classpath:spring/config.properties”)通过@PropertySource注解将properties配置文件中的值存储到Spring的 Environment中，Environment接口提供方法去读取配置文件中的值，参数是properties文件中定义的key值。上面是读取一个配置文件，如果你想要读取多个配置文件，请看下面代码片段@PropertySource(value = {“classpath:spring/config.properties”,”classpath:spring/news.properties”}) @EnableWebSocketMessageBroker 表示开启使用STOMP协议来传输基于代理的消息，Broker就是代理的意思。 @Repository@Repository、@Service、@Controller，它们分别对应存储层 Bean，业务层 Bean，和展示层 Bean，将类标识为 Bean；分别用于软件系统的不同层次：@Component 是一个泛化的概念，仅仅表示一个组件 (Bean) ，可以作用在任何层次。@Service 通常作用在业务层，但是目前该功能与 @Component 相同。@Constroller 通常作用在控制层，但是目前该功能与 @Component 相同。通过在类上使用 @Repository、@Component、@Service 和 @Constroller 注解，Spring会自动创建相应的 BeanDefinition 对象，并注册到 ApplicationContext 中。这些类就成了 Spring 受管组件。这三个注解除了作用于不同软件层次的类，其使用方式与 @Repository 是完全相同的。 @Value(“${spring.datasource.url}”) 获取 application 配置文件中的变量 @ConfigurationProperties 读取application属性配置文件中的属性 @ControllerAdvice 全局异常处理类，以将对于控制器的全局配置放在同一个位置。 注解了@Controller的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上。 ControllerAdvice注解将作用在所有注解了@RequestMapping的控制器的方法上 ExceptionHandler：用于全局处理控制器里的异常。 InitBinder：用来设置WebDataBinder，用于自动绑定前台请求参数到Model中。 ModelAttribute：本来作用是绑定键值对到Model中，此处让全局的@RequestMapping都能获得在此处设置的键值对。 @WebFilter 将一个实现了javax.servlet.Filter接口的类定义为过滤器 属性filterName声明过滤器的名称,可选 属性urlPatterns指定要过滤的URL模式,也可使用属性value来声明.(指定要过滤的URL模式是必选属性) @Service 声明类是一个 bean，其他的类才可以使用 @Autowired 将其作为一个成员变量自动注入 Zoo.java 在 bean 中的 id 是 “zoo”，即类名且首字母小写 @Scope(“prototype”) Spring默认产生的bean是单例的，”prototype” 表示原型即每次都会new一个新的出来 @Bean标注在方法上(返回某个实例的方法)，作用为注册bean对象 @Bean注解在返回实例的方法上，如果未通过@Bean指定bean的名称，则默认与标注的方法名相同； @Bean注解默认作用域为单例singleton作用域，可通过@Scope(“prototype”)设置为原型作用域； 既然@Bean的作用是注册bean对象，那么完全可以使用@Component、@Controller、@Service、@Ripository等 注解注册bean，当然需要配置@ComponentScan注解进行自动扫描。RestController 相关 @RestController 返回json字符串的数据，直接可以编写RESTFul的接口，@ResponseBody和@Controller的合集 @PathVariable 当使用@RequestMapping URI template 样式映射时，即 someUrl/{paramId}, 这时的paramId可通过 @Pathvariable注解绑定它传过来的值到方法的参数上 @RequestHeader 可以把Request请求header部分的值绑定到方法的参数上如(@RequestHeader(&quot;Accept-Encoding&quot;) String encoding){}。 @CookieValue 可以把Request header中关于cookie的值绑定到方法的参数上如(@CookieValue(&quot;JSESSIONID&quot;) String cookie){}。 @RequestParam 常用来处理简单类型的绑定，通过 Request.getParameter() 获取的String可直接转换为简单类型的情况（ String–&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所 以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值； 用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST； 该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定； @RequestBody 通过使用HandlerAdapter默认配置的HttpMessageConverters来解析Request请求的Body部分数据并将相应的数据绑定到Controller中方法的参数上，其常用来处理Content-Type不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等。 它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。 因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用。 @SessionAttributes 用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。 该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象 @ModelAttribute 该注解有两个用法，一个是用于方法上，一个是用于参数上： 用于方法上时： 通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model； 用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于： @SessionAttributes 启用的attribute 对象上； @ModelAttribute 用于方法上时指定的model对象； 上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中， 这种方式实际的效果就是在调用@RequestMapping的方法之前，为request对象的model里put（“account”， Account） @Controller 用于定义控制器类，控制器负责将用户发来的URL请求转发到对应的服务接口（service层）， 一般这个注解在类中，通常方法需要配合注解@RequestMappingJPA 相关 @Entity 注释声明该类为持久类,最好实现序列化，此时,默认情况下,所有的类属性都为映射到数据表的持久性字段 @Table(name=””,catalog=””,schema=””) 持久性映射的表,通常和@Entity 配合使用，只能标注在实体的 class 定义处， 表示实体对应的数据库表的信息。 name - 可选，表示表的名称，默认地，表名和实体名称一致，只有在不一致的情况下才需要指定表名 catalog - 可选，表示Catalog名称，默认为 Catalog(“”). schema - 可选 , 表示 Schema 名称 , 默认为Schema(“”). @Id 注释可以表明哪种属性是该类中的独特标识符(即相当于数据表的主键)。 @GeneratedValue 定义自动增长的主键的生成策略. @Transient 将忽略这些字段和属性,不用持久化到数据库. @Temporal(TemporalType.TIMESTAMP) 声明时间格式 @Enumerated 声明枚举 @Version 声明添加对乐观锁定的支持 @OneToOne 可以建立实体bean之间的一对一的关联 @OneToMany 可以建立实体bean之间的一对多的关联 @ManyToOne 可以建立实体bean之间的多对一的关联 @ManyToMany 可以建立实体bean之间的多对多的关联 @Formula 一个SQL表达式，这种属性是只读的,不在数据库生成属性(可以使用sum、average、max等) @OrderBy Many端某个字段排序(List) @Column注解设置，包含的设置如下 name：字段名 unique：是否唯一 nullable：是否可以为空 inserttable：是否可以插入 updateable：是否可以更新 columnDefinition: 定义建表时创建此列的DDL secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字。 @JoinColumn(name = “”, referencedColumnName = “”) 设置对应数据表的列名和引用的数据表的列名 @Lob 注解属性将被持久化为 Blog 或 Clob 类型,根据get方法的返回值不同,自动进行Clob和Blob的转换。因为这两种类型的数据一般占用的内存空间比较大，所以通常使用延迟加载的方式，与@Basic标记同时使用，设置加载方式为FetchType.LAZY。 Clob（Character Large Ojects）类型是长字符串类型，具体的java.sql.Clob, Character[], char[] 和 java.lang.String 将被持久化为 Clob 类型。 Blob（Binary Large Objects）类型是字节类型，具体的java.sql.Blob, Byte[], byte[] 和 serializable type 将被持久化为 Blob 类型。 @Basic 实体Bean中所有的非Static 非transient的属性都可以被持久化，没有定义注解属性的等价于在其上添加了@Basic注解。 通过@Basic注解可以声明属性的获取策略(lazy与否)，默认的是即时获取(early fetch)。 通常不需要对简单属性设置延迟获取，如需要定义@Basic(fetch=FetchType.LAZY) 在MySQL中没有Clob，用Text代替了，而且分为了tinytext， text，mediumtext，longtext。Blob也按这种方式分成了四种。 @Transactional注解 rollbackFor 表示当该方法中抛出指定的异常时数据回滚 dontRollbackOn 表示当该方法中抛出指定的异常时数据不回滚 hibernate-validator @size (min=3, max=20, message=”用户名长度只能在3-20之间”) @size (min=6, max=20, message=”密码长度只能在6-20之间”) @pattern (regexp=”[a-za-z0-9._%+-]+@[a-za-z0-9.-]+\\.[a-za-z]{2,4}”, message=”邮件格式错误”) @Length(min = 5, max = 20, message = “用户名长度必须位于5到20之间”) @Email(message = “比如输入正确的邮箱”) @NotNull(message = “用户名称不能为空”) @Max(value = 100, message = “年龄不能大于100岁”) @Min(value= 18 ,message= “必须年满18岁！” ) @AssertTrue(message = “bln4 must is true”) @AssertFalse(message = “blnf must is falase”) @DecimalMax(value=”100”,message=”decim最大值是100”) @DecimalMin(value=”100”,message=”decim最小值是100”) @NotNull(message = “身份证不能为空”) @Pattern(regexp=”^(\\d{18,18}|\\d{15,15}|(\\d{17,17}[x|X]))$”, message=”身份证格式错误”)@Service VS @Bean 和 @Configuration@Service实际上表示了DDD中的无状态的，独立的，以接口的形式提供的一个操作。采用@Bean和@Configuration配合的方式，Bean的创建交给了单独的类，而Service的标识给了Java中的Interface以及类的名字。这点在Spring Data也有所体现，比如Repository就是通过名字来标识，如CrudRepository。因此Service也通过名字来体现。具体层次定义，通过名字而不依赖Spring提供的注解，便于根据项目提供更多的层次，比如Mapper层，Validator层等。另外，本身Bean和Service就是两个维度的概念。一个关于具体实现，另一个关于DDD中的概念。使用@Bean的方式，能够创建库里面的类的实例。如果使用@Service的方式，没办法在库里面对应的类上添加@Service注解。@Resource、@Autowired、@Qualifier 区别@Resource和@Autowired都可以来完成注入依赖，但它们之间是有区 别的： @Resource默认是按照名称来装配注入的，只有当找不到与名称匹配的bean才会按照类型来装配注入； @Autowired默认是按照类型装配注入的，如果想按照名称来转配注入，则需要结合@Qualifier一起使用； @Resource注解是又J2EE提供，而@Autowired是由Spring提供，故减少系统对spring的依赖建议使用@Resource的方式； @Resource和@Autowired都可以书写标注在字段或者该字段的setter方法之上","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[]},{"title":"fatal: Could not read from remote repository.的解决办法","slug":"fatal-Could-not-read-from-remote-repository-的解决办法","date":"2017-07-28T11:01:01.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2017/07/28/fatal-Could-not-read-from-remote-repository-的解决办法/","link":"","permalink":"http://yoursite.com/2017/07/28/fatal-Could-not-read-from-remote-repository-的解决办法/","excerpt":"","text":"查看远端地址 git remote –v查看配置 git config --list 1234git add . // 暂存所有的更改git checkout . // 丢弃所有的更改git status // 查看文件状态git commit -m &quot;本次要提交的概要信息&quot; // 提交 设置远端仓库地址 git remote set-url origin 你的远端地址 git remote add origin_new 新的地址 git remote –v查看 git push origin_new master重新推送 下面是设置用户名 Git config –global user.name “用户名” git config –global user.email 邮箱地址 设置代理： git config --global https.proxy http://127.0.0.1:1080 取消设置代理：git config --global --unset https.proxy 取消git init操作时出现 rm: cannot remove ‘.git’: Is a directory是因为输入的命令是： rm -f .git解决办法：rm -rf .git 即删除整个.git目录 failed to push some refs to ‘git@github.com:***.git’ hint: Updates were rejected ···使用git push origin master的时候出现一下错误： 解决办法：git push -f origin master或者git pull下 恢复不小心删除的 git stash 文件： 123git fsck //找到dangling的对象git show id //上面列出的每一条记录的最后一个字符串，按 enter 查看具体信息git stash apply id git 回滚提交 123456//reset将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交, 让master分支向后回退了两个提交git checkout mastergit reset HEAD~2//Revert撤销一个提交的同时会创建一个新的提交, 找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。git revert HEAD~2 错误：Please enter a commit message to explain why this merge is necessary. 解决办法： （可选）按键盘字母 i 进入insert模式 （可选）修改最上面那行黄色合并信息 按键盘左上角”Esc” （退出insert模式） 输入”:wq”,按回车键即可（提交） gitignore notworking： 123git rm -r --cached .git add .git commit -m &quot;fixed untracked files&quot; git Failed to connect to www.google.com port 80: Timed out 可能是因为设置了代理： 12git config --global http.proxy //查看代理git config --global --unset http.proxy //取消代理 HTTP Basic access denied on Git： 123git config --global --unset credential.helpergit clone &apos;···&apos;login username，password rebase 和 merge 区别 1git pull --rebase origin master rebase 选项告诉 Git 把你的提交移到同步了中央仓库修改后的 master 分支的顶部。rebase 操作过程是把本地提交一次一个地迁移到更新了的中央仓库master分支之上。这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。反过来，简化了哪里引入Bug的分析，如果有必要，回滚修改也可以做到对项目影响最小。 1git pull origin master 如果没有 rebase， pull 操作仍然可以完成，但每次 pull 操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。合并玩冲突之后，git rebase --continue，Git 会继续一个一个地合并后面的提交，如其它的提交有冲突就重复这个过程。如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行git pull –rebase命令前的样子：git rebase --abort","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[]},{"title":"搭建一个包含 redux、router、国际化的前端项目框架","slug":"搭建一个包含-redux、router、国际化的前端项目框架","date":"2017-06-08T10:57:41.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2017/06/08/搭建一个包含-redux、router、国际化的前端项目框架/","link":"","permalink":"http://yoursite.com/2017/06/08/搭建一个包含-redux、router、国际化的前端项目框架/","excerpt":"","text":"目的搭建一个交互比较多的 react 前端项目框架，数据可预测，可路由跳转，可国际化，数据操作可控制 使用的主要类库 i18next 国际化 react-i18next i18next-browser-languagedetector immutability-helper immutable 处理数据 react react-dom react-redux 管理数据 react-router 路由 react-router-redux 路由接入 store redux说明 因为 router 是异步过程，所以注入到 store 中，通过 action 跳转路由 在 react-redux 原生 action、reducer 之上封装了一层，便于分发、匹配 action、reducer 执行顺序： action -&gt; 前置拦截器（return true）-&gt; reducer（修改 store）-&gt; componentWillReceiveProps -&gt; shouldComponentUpdate（return true）-&gt; render -&gt; 后置拦截器 项目地址：https://github.com/liangxinwei/redux-ele 项目布局12345678910111213141516171819202122232425262728293031323334353637383940├── cfg webpack 配置文件│ ├── base.js webpack 配置│ ├── default.js loader，plugin│ ├── dev.js dev 环境 │ └── dist.js dist 环境├── src 源码目录│ ├── app│ │ ├── component 具体业务组件，配合 routes 目录使用│ │ ├── config store 配置│ │ │ ├── AppActionRouter.js 分发相应 type 的 action│ │ │ ├── AppReducerCreator.js 匹配相应 type 的 action 的 reducer│ │ │ ├── ConfigureStore.js 生成 store│ │ │ └── index.js 统一导出│ │ ├── i18n 国际化配置│ │ │ ├── locales 中英文配置文件│ │ │ │ ├── en 英文配置│ │ │ │ └── zh 中文配置│ │ │ ├── i18n.js i18next 配置│ │ │ └── index.js 统一导出│ │ ├── middleware 中间件│ │ │ ├── AppMiddleWare.js 前置、后置拦截器业务代码│ │ │ ├── ComponentMiddleWare.js 操作拦截器中间件│ │ │ ├── index.js 中间件统一导出│ │ │ └── LoggerMiddleWare.js 日志中间件│ │ ├── routes 路由配置│ │ │ └── index.jsx│ │ └── App.jsx app 入口│ ├── index.ejs ejs 模板文件│ └── index.jsx 挂载 react dom├── test├── .babelrc babel 配置文件├── .editorconfig 跨平台编辑器配置文件├── .eslintignore eslintignore 配置文件├── .eslintrc eslint 配置文件├── .gitignore├── package.json ├── postcss.config.js postcss 配置文件 ├── server.js 本地服务（webpack-dev-server）├── webpack.config.js webpack 配置文件入口└── README.md App.jsx 项目入口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123;Component&#125; from &apos;react&apos;;import &#123;Provider&#125; from &apos;react-redux&apos;;import &#123;I18nextProvider&#125; from &apos;react-i18next&apos;;import &#123;syncHistoryWithStore&#125; from &apos;react-router-redux&apos;;import &#123;hashHistory&#125; from &apos;react-router&apos;;import &#123;reducers&#125; from &apos;./components&apos;; //合并之后的 reducerimport &#123;default as Store&#125; from &apos;./config/ConfigureStore&apos;;import appMiddleWares from &apos;./middleware/AppMiddleWare&apos;;import &#123;i18n, locales&#125; from &apos;./i18n&apos;; //见下面 i18n 配置import routes from &apos;./routes&apos;;import &apos;./style/index.scss&apos;;/** * App View */class App extends Component &#123; constructor(props) &#123; super(props); &#125; componentWillMount() &#123; // 添加i18n语言包 for (let ns in locales[&apos;zh&apos;]) &#123; if (locales[&apos;zh&apos;].hasOwnProperty(ns)) &#123; i18n.addResourceBundle(&apos;zh&apos;, ns, locales[&apos;zh&apos;][ns]); i18n.addResourceBundle(&apos;en&apos;, ns, locales[&apos;en&apos;][ns]); &#125; &#125; &#125; render() &#123; let storeOptions = &#123;&#125;; const defaultStates = &#123;&#125;; const allReducers = Object.assign(&#123;&#125;, reducers); //此处可以并入其它模块中的 reducer const preMiddleWares = Object.assign(&#123;&#125;, appMiddleWares.preMiddleWares); //此处可以并入其它模块中的 preMiddleWares const postMiddleWares = Object.assign(&#123;&#125;, appMiddleWares.postMiddleWares); //此处可以并入其它模块中的 postMiddleWares storeOptions.initialStates = defaultStates; storeOptions.reducers = allReducers; storeOptions.preMiddleWares = preMiddleWares; storeOptions.postMiddleWares = postMiddleWares; const store = Store.configureStore(storeOptions); const history = syncHistoryWithStore(hashHistory, store); return ( &lt;Provider store=&#123;store&#125;&gt; &lt;I18nextProvider i18n=&#123;i18n&#125;&gt; &#123;routes(history)&#125; &lt;/I18nextProvider&gt; &lt;/Provider&gt; ); &#125;&#125;export default App; routes 路由配置12345678910111213141516171819import React from &apos;react&apos;;import &#123;Router, Route&#125; from &apos;react-router&apos;;import &#123; HomeView, BusinessDetail&#125; from &apos;../components&apos;;const routes = (history) =&gt; &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;HomeView&#125;/&gt; &lt;Route path=&quot;/home&quot; component=&#123;HomeView&#125;/&gt; &lt;Route path=&quot;/business/:id&quot; component=&#123;BusinessDetail&#125;/&gt; &lt;/Router&gt; );&#125;;export default routes; ConfigureStore.js 构建 Store1234567891011121314151617181920212223242526272829303132333435import &#123;applyMiddleware, compose, createStore, combineReducers&#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import &#123;hashHistory&#125; from &apos;react-router&apos;;import &#123;routerReducer, routerMiddleware&#125; from &apos;react-router-redux&apos;;import &#123;componentMiddleWare, logger&#125; from &apos;../middleware&apos;;import appReducerCreator from &apos;./AppReducerCreator&apos;;/** * store 构建器 */export function configureStore(config) &#123; // 合并之后的 preMiddleWares, postMiddleWares, reducers let &#123;initialStates, preMiddleWares, postMiddleWares, reducers&#125; = config; let allReducer = Object.assign(&#123;&#125;, reducers); let appReducer = appReducerCreator(initialStates, allReducer); const finalReducer = combineReducers(&#123;appReducer, routing: routerReducer&#125;); const allMiddleWares = [ thunk, // 异步 action componentMiddleWare(preMiddleWares, postMiddleWares), // 具体业务拦截器 routerMiddleware(hashHistory), // router 注入到 store 中 logger ]; let enhancer = compose( applyMiddleware(...allMiddleWares) ); return createStore(finalReducer, &#123;&#125;, enhancer);&#125;const Store = &#123; configureStore&#125;;export default Store; AppReducerCreator.js123456789101112131415/** * 全局 Reducer 产生器 */function appReducerCreator(wrapInitialState, allReducerMap) &#123; function appReducer(state = wrapInitialState, action) &#123; if (action &amp;&amp; action.type &amp;&amp; allReducerMap[action.type]) &#123; return allReducerMap[action.type](state, action); &#125; else &#123; return state; &#125; &#125; return appReducer;&#125;export default appReducerCreator; ComponentMiddleWare.js action 拦截器1234567891011121314151617181920212223242526/** * 操作拦截器中间件 */export function componentMiddleWare(preMiddleWares, postMiddleWares) &#123; return function (&#123;getState&#125;) &#123; return next =&gt; (action) =&gt; &#123; // 前置拦截校验函数 let preInterceptFunc = preMiddleWares ? preMiddleWares[action.type] : null; // 进行拦截校验操作 if (preInterceptFunc &amp;&amp; !preInterceptFunc.call(this, action, getState())) &#123; console.error(&apos;Invalid action for preMiddleWares intercept!!&apos;); return; &#125; // 调用 middleware 链中下一个 middleware 的 dispatch。 const returnValue = next(action); // 后置拦截函数 let postInterceptFunc = postMiddleWares ? postMiddleWares[action.type] : null; // 进行拦截校验操作 postInterceptFunc &amp;&amp; postInterceptFunc.call(this, action, getState()); return returnValue; &#125;; &#125;;&#125; LoggerMiddleWare.js123456789101112/** * 日志 MiddleWare */export function logger(&#123;getState&#125;) &#123; return next =&gt; (action) =&gt; &#123; console.info(&apos;will dispatch&apos;, action); // 调用 middleware 链中下一个 middleware 的 dispatch。 const returnValue = next(action); console.info(&apos;after dispatch&apos;, getState()); return returnValue; &#125;;&#125; AppMiddleWare.js 具体业务中间件，构建 store 时注入123456789101112131415161718192021222324/** * 前置拦截器 */let preMiddleWares = &#123; TEST: (action, state) =&gt; &#123; return true;// false 则本次 action 无效，数据不会被修改 &#125;&#125;;/** * 后置拦截器 */let postMiddleWares = &#123; TEST: (action, state) =&gt; &#123; ··· // 此处修改之后不会立即在 ui 上体现出来，因为它在 render 之后执行。且因为参数 state 为引用，所以是直接修改，可做一些提示性的操作 &#125;&#125;;let appMiddleWares = &#123; preMiddleWares, postMiddleWares&#125;;export default appMiddleWares; connectToStore.js 组件接入 store decorator1234567891011121314151617181920import &#123;bindActionCreators&#125; from &apos;redux&apos;;import &#123;connect&#125; from &apos;react-redux&apos;;import appConfig from &apos;../config&apos;;// appConfig.router 即下面的 AppActionRouter.jsconst AppActionRouter = appConfig.router;function mapStateToProps(state) &#123; return &#123; store: state.appReducer || &#123;&#125;, routerStore: (state.routing &amp;&amp; state.routing.locationBeforeTransitions) || &#123;&#125; &#125;;&#125;function mapDispatchToProps(dispatch) &#123; return bindActionCreators(AppActionRouter, dispatch);&#125;export default function connectToStore(component) &#123; return connect(mapStateToProps, mapDispatchToProps)(component);&#125; AppActionRouter.js 分发 action1234567891011121314151617181920212223import &#123;actions&#125; from &apos;../components&apos;;// action 为合并之后的所有的 action/** * app action Router */function onClickWithoutCheck(action) &#123; return action;&#125;/** * 如果外部注入 action，那么直接使用 action 的操作即可。 * 如果外部没有注入 action， 使用 dispatch 操作。 */export function onClickAction(action, props) &#123; return function (dispatch, getState) &#123; if (action.type &amp;&amp; actions.hasOwnProperty(action.type)) &#123; actions[action.type].call(this, action, dispatch, props); &#125; else &#123; dispatch(onClickWithoutCheck(action)); &#125; &#125;;&#125; acion 示例1234567let homeActions = &#123;&#125;;homeActions[&apos;TEST&apos;] = function (action, dispatch, state) &#123; dispatch(action);&#125;;export default homeActions; reducer 示例1234567891011import Immutable from &apos;immutable&apos;;let homeReducers = &#123;&#125;;homeReducers[&apos;TEST&apos;] = function (state, action) &#123; let foo = Immutable.fromJS(state); let newArr = foo.mergeDeep(Immutable.fromJS(action.content)); return newArr.toJS();&#125;;export default homeReducers; i18n 配置12345678910111213141516171819202122232425import i18next from &apos;i18next&apos;;import LanguageDetector from &apos;i18next-browser-languagedetector&apos;;const i18n = i18next .use(LanguageDetector) .init(&#123; fallbackLng: &apos;zh&apos;, // have a common namespace used around the full app ns: [&apos;common&apos;], defaultNS: &apos;common&apos;, debug: false, interpolation: &#123; escapeValue: false // not needed for react!! &#125; &#125;, (err) =&gt; &#123; if (err) &#123; console.error(&apos;i18next&apos;, err); &#125; // console.log(&apos;i18next initialized and ready to go!&apos;); &#125;);export default i18n; i18n 英文配置1234const home = &#123; title: &apos;Home Page&apos;&#125;;export default &#123;home&#125;; i18n 中文配置1234const home = &#123; title: &apos;首页&apos;&#125;;export default &#123;home&#125;; i18n 中英文统一导出123456789import zh from &apos;./zh&apos;;import en from &apos;./en&apos;;const locales = &#123; zh: zh, en: en&#125;;export default locales; 组件实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, &#123;Component&#125; from &apos;react&apos;;import &#123;translate&#125; from &apos;react-i18next&apos;;import i18n from &apos;../i18n&apos;;@translate([&apos;home&apos;], &#123;wait: true&#125;) // 使用多语言@connectToStore // 组件介入 storeclass Test extends Component &#123; constructor(props) &#123; super(props); &#125; // 路由跳转 transformRouter = () =&gt; &#123; const &#123;onClickAction&#125; = this.props; // 见下面路由 acion let gotoAction = &#123; type: &apos;GOTO&apos;, content: &apos;/home&apos; &#125;; onClickAction(gotoAction, this.props); &#125; // 发送 action changeStore = () =&gt; &#123; const &#123;onClickAction, store&#125; = this.props; let action = &#123; type: &apos;TEST&apos;, content: &#123;data: &apos;test&apos;&#125; &#125;; onClickAction(action, this.props); &#125; // 切换语言 setLanguage = () =&gt; &#123; i18n.changeLanguage(&apos;zh&apos;); // or en &#125; render() &#123; const &#123;t, store&#125; = this.props; return ( &lt;div className=&apos;app-home&apos;&gt; &lt;div className=&apos;app-header&apos;&gt; &lt;span&gt;&#123;t(&apos;title&apos;)&#125;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; content &lt;/div&gt; &lt;Footer/&gt; &lt;/div&gt; ); &#125;&#125;export default Test; 路由 acion，不需要 路由 recuder123456789import &#123;push&#125; from &apos;react-router-redux&apos;;let routerActions = &#123;&#125;;routerActions[&apos;GOTO&apos;] = function (action, dispatch, state) &#123; dispatch(push(action[&apos;content&apos;]));&#125;;export default routerActions;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"一些容易被忽略的 javascript 知识点","slug":"一些容易被忽略的-javascript-知识点","date":"2017-05-10T10:55:37.000Z","updated":"2019-12-31T02:14:32.000Z","comments":true,"path":"2017/05/10/一些容易被忽略的-javascript-知识点/","link":"","permalink":"http://yoursite.com/2017/05/10/一些容易被忽略的-javascript-知识点/","excerpt":"","text":"ReferenceError和TypeError如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常。如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 立即执行函数表达式由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个()将函数变成表达式，第二个()执行了这个函数。 letlet 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地了所在的块作用域。使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在” 。for 循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。 提升考虑以下代码： 123a = 2;var a;console.log( a );// 2 考虑另外一段代码： 12console.log( a );// undefinedvar a = 2; 过程： 当你看到 var a = 2; 时，JavaScript 实际上会将其看成两个声明： var a; 和 a = 2; 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。第一个代码片段会以如下形式进行处理： 123var a;a = 2;console.log( a ); 其中第一部分是编译，而第二部分是执行。第二个代码片段实际是按照以下流程处理的： 123var a;console.log( a );a = 2; 这个过程就叫作提升。但是函数表达式却不会被提升。例如： 1234foo(); // 不是 ReferenceError, 而是 TypeError!var foo = function bar() &#123; // ...&#125;; 这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域） ，因此foo()不会导致 ReferenceError 。但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值） 。 foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用： 12345foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() &#123; // ...&#125;; 这个代码片段经过提升后，实际上会被理解为以下形式： 1234567var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() &#123;var bar = ...self... // ...&#125; 函数声明和变量声明都会被提升。但是是函数会首先被提升，然后才是变量。考虑以下代码： 12345678foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;; 会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式： 1234567function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;; 注意， var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了） ，因为函数声明会被提升到普通变量之前。尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。 作用域闭包定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。下面这段代码清晰地展示了闭包： 123456789function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;var baz = foo();baz(); // 2 —— 这就是闭包的效果。 bar() 显然可以被正常执行，但是它在自己定义的词法作用域以外的地方执行。看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 typeof null = “object”不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“ object ” 。 Array使用 delete 运算符可以将单元从数组中删除，单元删除后，数组的 length 属性并不会发生变化 123456var a = [ ];a[0] = 1;// 此处没有设置 a[1] 单元a[2] = 3;a[1]; // undefineda.length; // 3 上面的代码可以正常运行，但其中的 “ 空白单元 ” （ empty slot ）可能会导致出人意料的结果。另外：如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理 123var a = [ ];a[\"13\"] = 42;a.length; // 14 Number()对于 . 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。true 转换为 1 ， false 转换为 0 。 undefined 转换为 NaN ， null 转换为 0。为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null ，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换。看下面的例子： 12345678910111213141516171819202122232425262728// 无效语法：因为 . 被视为常量 42. 的一部分，所以没有. 属性访问运算符来调用 tofixed 方法42.toFixed( 3 ); // SyntaxError// 下面的语法都有效：(42).toFixed( 3 ); // \"42.000\"0.42.toFixed( 3 ); // \"0.420\"42..toFixed( 3 ); // \"42.000\"42 .toFixed(3); // \"42.000\"var a = &#123;valueOf: function()&#123; return \"42\";&#125;&#125;;var b = &#123; toString: function()&#123; return \"42\"; &#125;&#125;;var c = [4,2];c.toString = function()&#123; return this.join( \"\" ); // \"42\"&#125;;Number( a ); // 42Number( b ); // 42Number( c ); // 42Number( \"\" ); // 0Number( [] ); // 0Number( [ \"abc\" ] ); // NaN Boolean 假值 undefined,null,false,+0,-0,NaN,””。假值列表以外的值都是真值 假值对象12345var a = new Boolean( false );var b = new Number( 0 );var c = new String( \"\" );var d = Boolean( a &amp;&amp; b &amp;&amp; c );d; // true 说明 a 、 b 、 c 都为 true 虽然 JavaScript 代码中会出现假值对象，但它实际上并不属于 JavaScript 语言的范畴。浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是 “ 假值对象 ” 。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 。最常见的例子是 document.all ，它是一个类数组对象，包含了页面上的所有元素，由 DOM （而不是 JavaScript 引擎）提供给 JavaScript 程序使用。它以前曾是一个真正意义上的对象，布尔强制类型转换结果为 true ，不过现在它是一个假值对象。document.all 并不是一个标准用法，早就被废止了。 奇特的 ~ 运算符 类型转换它首先将值强制类型转换为 32 位数字，然后执行字位操作 “ 非 ” （对每一个字位进行反转）。这与 ! 很相像，不仅将值强制类型转换为布尔值 &lt; ，还对其做字位反转。对 ~ 还可以有另外一种诠释，源自早期的计算机科学和离散数学： ~ 返回 2 的补码。~x 大致等同于 -(x+1) 。~ 和 indexOf() 一起可以将结果强制类型转换（实际上仅仅是转换）为真 / 假值： 12345678910var a = \"Hello World\";~a.indexOf( \"lo\" ); // -4 &lt;-- 真值 !if (~a.indexOf( \"lo\" )) &#123; // true// 找到匹配！&#125;~a.indexOf( \"ol\" ); // 0 &lt;-- 假值 !!~a.indexOf( \"ol\" ); // trueif (!~a.indexOf( \"ol\" )) &#123; // true// 没有找到匹配！&#125; 如果 indexOf(..) 返回 -1 ， ~ 将其转换为假值 0 ，其他情况一律转换为真值。 字位截除使用 ~ 来截除数字值的小数部分，以为这和 Math.floor(..) 的效果一样，实际上并非如此。 中的第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。~~ 和 !! 很相似，它只适用于 32 位数字，更重要的是它对负数的处理与 Math.floor(..) 不同。 12Math.floor( -49.6 ); // -50~~-49.6; // -49 x 能将值截除为一个 32 位整数， x | 0 也可以，而且看起来还更简洁。出于对运算符优先级的考虑，我们可能更倾向于使用 ~x 。 == 和 ===常见的误区是：“ == 检查值是否相等， === 检查值和类型是否相等 ” 。听起来蛮有道理，然而还不够准确。正确的解释是：“ == 允许在相等比较中进行强制类型转换，而 === 不允许。”两种解释的区别：根据第一种解释（不准确的版本）， === 似乎比 == 做的事情更多，因为它还要检查值的类型。第二种解释中 == 的工作量更大一些，因为如果值的类型不同还需要进行强制类型转换。有人觉得 == 会比 === 慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级（百万分之一秒）的差别而已。如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎实现上的细微差别之外，它们之间并没有什么不同。== 和 === 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。 抽象关系比较 a &lt; b分为两个部分：比较双方都是字符串（后半部分）和其他情况（前半部分）。比较双方首先调用 ToPrimitive ，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。 1234var a = [ 42 ];var b = [ \"43\" ];a &lt; b; // trueb &lt; a; // false -0 和 NaN 的相关规则在这里也适用。如果比较双方都是字符串，则按字母顺序来进行比较 123456789101112131415161718192021var a = [ \"42\" ];var b = [ \"043\" ];a &lt; b; // falsevar a = [ 4, 2 ];var b = [ 0, 4, 3 ];a &lt; b; // falsevar a = &#123; b: 42 &#125;;var b = &#123; b: 43 &#125;;a &lt; b; // ??// 结果还是 false ，因为 a 是 [object Object] ，b 也是 [object Object]，所以按照字母顺序 a &lt; b 并不成立。// 下面的例子就有些奇怪了:var a = &#123; b: 42 &#125;;var b = &#123; b: 43 &#125;;a &lt; b; // falsea == b; // falsea &gt; b; // falsea &lt;= b; // truea &gt;= b; // true 因为根据规范 a &lt;= b 被处理为 b &lt; a ，然后将结果反转。因为 b &lt; a 的结果是 false ，所以 a &lt;= b 的结果是 true。实际上 JavaScript 中 &lt;= 是 “ 不大于 ” 的意思（即 !(a &gt; b) ，处理为 !(b &lt; a) ）。同理 a &gt;= b 处理为 b &lt;= a 。 toString12345[] + &#123;&#125;; // \"[object Object]\"&#123;&#125; + []; // 0[null].toString() // \"\"[undefined].toString() // \"\"[null, undefined].toString() // \",\" 第一行代码中， {} 出现在 + 运算符表达式中，因此它被当作一个值（空对象）来处理。 [] 会被强制类型转换为 “” ，而 {} 会被强制类型转换为 “[object Object]” 。但在第二行代码中， {} 被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换为 0 。 构造函数123456var Person = function(name) &#123; this.name = name;&#125;;// 实例化一个Personvar alice = new Person('alice');// 不要这么做!Person('bob'); //=&gt; undefined 这个函数只会返回 undefined，并且执行上下文是 window(全局)对象，你无意间创建了一个全局变量 name。调用构造函数时不要丢掉 new 关键字。当使用 new 关键字来调用构造函数时，执行上下文从全局对象(window)变成一个空的 上下文，这个上下文代表了新生成的实例。因此，this 关键字指向当前创建的实例。默认情况下，如果你的构造函数中没有返回任何内容，就会返回 this——当前的上下文。 要不然就返回任意非原始类型的值。 bind 实现12345678910Function.prototype.bind = Function.prototype.bind || function (obj) &#123; var slice = [].slice, args = slice.call(arguments, 1), self = this, nop = function () &#123;&#125;, bound = function () &#123; return self.apply( this instanceof nop ? this : (obj || &#123;&#125;), args.concat(slice.call(arguments))); &#125;; nop.prototype = self.prototype; bound.prototype = new nop(); return bound; &#125;; Object.create() 实现12345Object.create = Object.create || function(o) &#123; function F() &#123;&#125;; F.prototype = o; return new F();&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]}]}