{"meta":{"title":"梁新维","subtitle":"sometimes code， sometimes design","description":null,"author":"liangxinwei","url":"https://www.liangxinwei.cn","root":"/"},"pages":[{"title":"关于我","date":"2019-12-29T13:14:25.000Z","updated":"2020-04-22T02:18:01.808Z","comments":true,"path":"about/index.html","permalink":"https://www.liangxinwei.cn/about/index.html","excerpt":"","text":"简介前端工程师，在向全栈工程师努力中··· 进行中的项目hotdog(移动端) 前端项目 后端项目 联系方式邮箱：liangxw6004@qq.comGitHub：https://github.com/liangxinwei个人网站：https://www.liangxinwei.cn/"},{"title":"分类","date":"2019-12-29T13:13:10.000Z","updated":"2020-04-22T02:18:01.809Z","comments":true,"path":"categories/index.html","permalink":"https://www.liangxinwei.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-29T13:13:46.000Z","updated":"2020-04-22T02:18:01.860Z","comments":true,"path":"tags/index.html","permalink":"https://www.liangxinwei.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MySQL笔记（一）","slug":"MySQL笔记（一）","date":"2020-04-22T01:27:19.000Z","updated":"2020-04-22T02:18:01.801Z","comments":true,"path":"2020/04/22/MySQL笔记（一）/","link":"","permalink":"https://www.liangxinwei.cn/2020/04/22/MySQL笔记（一）/","excerpt":"","text":"引擎 InnoDB 是一个可靠的事务处理引擎，它不支持全文本搜索 MEMORY在功能等同于MyISAM，但由于数据存储在内存(不是磁盘) 中，速度很快(特别适合于临时表) MyISAM是一个性能极高的引擎，它支持全文本搜索(参见第18章)， 但不支持事务处理。 外键不能跨引擎混用引擎类型有一个大缺陷。外键(用于强制实施引用完整性)不能跨引擎，即使用一 个引擎的表不能引用具有使用不同引擎的表的外键。 使用 REGEXP：123// shop_name 是测试数据，包含 --，比如 商家--1SELECT `shop_name` FROM business WHERE `shop_name` REHEXP &apos;--1|--2&apos;;SELECT `shop_name` FROM business WHERE `shop_name` REHEXP &apos;--[0-9]&apos;; Concat() 拼接串，即把多个串连接起来形成一个较长的串Trim() 删除数据多余的空格，RTrim() 函数去掉值右边的所有空格，LTrim() 去掉串左边的空格常见的情景：报表中的名字按照name(location)的格式，而表中数据存储在两个列name和country中 1234SELECT Concat(Trim(`shop_name`), Trim(&apos; ( &apos;), Trim(`mail_type`), &apos; )&apos;) AS format_titleFROM business;// 标题--1(中通)` 但是拼接串它没有名字，它只是一个值，客户机没有办法引用它（一个未命名的列），解决办法是别名(alias)，是一个字段或值的替换名。别名用AS关键字赋予。 执行算术计算123456SELECT `shop_name`, `mail_type`， `distance`, `service_time`, `service_time` * `distance` as `total_price`FROM businessWHERE `mail_type` LIKE &apos;_通&apos;ORDER BY `distance`DESC;// 标题--9 中通 980 59 57820 常用的文本处理函数： Left() 返回串左边的字符，Right() 返回串右边的字符 Length() 返回串的长度 Locate() 找出串的一个子串 Lower() 将串转换为小写，Upper() 将串转换为大写 LTrim() 去掉串左边的空格，RTrim() 去掉串右边的空格 Soundex() 返回串的SOUNDEX值（SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法，如：Y.Lee -&gt; Y.Lie，SELECT shop_name FROM business WHERE Soundex(shop_name) = Soundex(&#39;Y.Lie&#39;)） SubString() 返回子串的字符 常用的日期处理函数 AddDate() 增加一个日期(天、周等) AddTime()增加一个时间(时、分等) CurDate()返回当前日期 CurTime()返回当前时间 Date()返回日期时间的日期部分 DateDiff()计算两个日期之差 Date_Add()高度灵活的日期运算函数 Date_Format()返回一个格式化的日期或时间串 Day()返回一个日期的天数部分 DayOfWeek()对于一个日期，返回对应的星期几 Hour()返回一个时间的小时部分 Minute()返回一个时间的分钟部分 Month()返回一个日期的月份部分 Now()返回当前日期和时间 Second()返回一个时间的秒部分 Time()返回一个日期时间的时间部分 Year()返回一个日期的年份部分 聚焦函数12345678910111213-- street 的行数SELECT COUNT(*) AS `street_count` FROM street;-- 最大值SELECT MAX(`distance`) AS max_distance,-- 最小值MIN(`distance`) AS min_distance,-- 平均值AVG(`distance`) AS avg_distance,-- 所有值的和SUM(`distance`) AS total_distance,-- 所有不同值的和（去重）SUM(DISTINCT `distance`) AS total_distance_distinctFROM business; GROUP BY GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套， 为数据分组提供更细致的控制。 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算(所以不能从个别的列取回数据)。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式(但不能是聚集函数)。如果在SELECT中使用表达式，则必须在 GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子 句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列 中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 使用WITH ROLLUP关键字，可以得到每个分组以 及每个分组汇总级别(针对每个分组)的值12345678SELECT `mail_type`, COUNT(*) AS `num_mail_type`FROM `business`GROUP BY `mail_type`;SELECT `mail_type`, COUNT(*) AS `num_mail_type`FROM `business`GROUP BY `mail_type`WITH ROLLUP; HAVING和WHERE的差别:WHERE过滤指定的是行而不是分组。事实上，WHERE没有分组的概念。WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。 联结表12345678910// 在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。// WHERE子句作为 过滤条件，它只包含那些匹配给定条件(这里是联结条件)的行。// 没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。SELECT p.name, c.name, d.name, s.nameFROM `province` p, `city` c, `district` d, `street` sWHERE s.parent_code = d.codeAND d.parent_code = c.codeAND c.parent_code = p.codeAND p.name = &apos;山西省&apos;ORDER BY c.name; UNION操作符来组合数条SQL查询，将它们的结果组合成单个结果集。规则： UNION必须由两条或两条以上的SELECT语句组成，语句之间用关 键字UNION分隔 UNION中的每个查询必须包含相同的列、表达式或聚集函数(不过各个列不需要以相同的次序列出)。 列数据类型必须兼容:类型不必完全相同，但必须是DBMS可以隐含地转换的类型(例如，不同的数值类型或不同的日期类型)。 UNION ALL返回所有匹配行，不取消重复的行123456789// 查询 `distance` &lt; 400 ｜｜ `mail_type` IN (&apos;顺丰&apos;, &apos;圆通&apos;)SELECT `shop_name`, `distance`FROM `business`WHERE `distance` &lt; 400UNIONSELECT `shop_name`, `distance`FROM `business`WHERE `mail_type` IN (&apos;顺丰&apos;, &apos;圆通&apos;)ORDER BY `distance`; 更新表：123UPDATE `business`SET `service_time` = round(rand() * 100)WHERE `service_time` &lt; 60; 创建用户123456789101112131415SELECT * FROM mysql.user;—- `hotdog`@`%`：用户名 hotdog，% 表示允许任何ip地址，IDENTIFIEDBY 指定的口令为纯文本，MySQL 将在保存到user表之前对其进行加密。CREATE USER `hotdog`@`%` IDENTIFIED BY ‘123456’;—- 配置权限：对 hotdog 数据库有所有权限，不能访问其他数据库，GRANT 的反操作为 REVOKEGRANT ALL PRIVILEGES ON hotdog.* TO `hotdog`@`%` IDENTIFIED BY &apos;123456&apos;;—- 删除用户DROP USER `hotdog`@`localhost`;—- 配置完权限之后刷新MySQL的系统权限相关表方可生效FLUSH PRIVILEGES;—- 删除用户DROP USER `username`;—- 查看赋予用户账号的权限SHOW GRANT FOR `username`;—- 更改口令，新口令必须传递到Password()函 数进行加密。SET PASSWORD FOR `username` = Password(`new_password`) created_at字段与updated_at字段关于自动更新与自动插入时间戳123456ALTER TABLE `user` ADD COLUMN `create_at` TIMESTAMP NOT NULL;ALTER TABLE `user` ADD COLUMN `update_at` TIMESTAMP NOT NULL;—- TIMESTAMP DEFAULT CURRENT_TIMESTAMP 表示插入的时候自动获取当前时间（格式为YY-mm-dd HH:ii:ss）ALTER TABLE `user` MODIFY `create_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL;—- TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 表示更新的时候自动获取当前时间（格式为YY-mm-dd HH:ii:ss）ALTER TABLE `user` MODIFY `update_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL; 新增外键1ALTER TABLE `products` ADD CONSTRAINT `fk_orders_customs` FOREIGN KEY (vend_id) REFERENCES `vendors` (vend_id); 视图 规则和限制 与表一样，视图必须唯一命名(不能给视图取与别的视图或表相 同的名字)。 对于可以创建的视图数目没有限制。 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。 视图不能索引，也不能有关联的触发器或默认值。 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。 性能问题：因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。 一些常见应用 重用SQL语句。 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。 使用表的组成部分而不是整个表。 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 数据库维护123456// 1. 用来检查表键是否正确ANALYZE TABLE `table_name`;// 2. CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对 索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。 CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最 彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删 除的链接并进行键检验，QUICK只进行快速扫描。如下所示，CHECK TABLE发现和修复问题CHECK TABLE `table_name`;// 3. 如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能。OPTIMIZE TABLE `table_name`; 字符集123456// 查看所支持的字符集完整列表SHOW CHARACTER SET;// 查看所支持校对的完整列表SHOW COLLATION;SHOW FULL COLUMNS FROM `village`;SHOW VARIABLES LIKE &apos;%char%&apos;; 改善性能123456781. 但过一段时间后你可能需要调整内存分配、缓冲区大 小等。查看当前设置：SHOW VARIABLES;SHOW STATUS;2. 显示所有活动进程(以及它们的线程ID和执行时间)SHOW PROCESSLIST；3. KILL命令终结某个特定的进程(使用这个命令需要作为管理员登录)。4. LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。5. 索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。(索引可根据需要添加和删除。) MySQL不允许对变长列(或一个列的可变部分)进行索引 MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2) MySQL 数据类型 串数据类型 数值数据类型 日期和时间数据类型 二进制数据类型 触发器 想要某条语句（或某些语句）在事件发生时自动执行。MySQL响应以下任意语句而 自动执行的一条MySQL语句(或位于BEGIN和END语句之间的一组语 句):DELETE; NSERT; UPDATE。 只有表才支持触发器，每个表最多支持6个触发器（每条INSERT、UPDATE 和DELETE的之前和之后），单一触发器不能与多个事件或多个表关联。 1234// 触发器将在INSERT语句成功执行后执行。从 NEW.order_num 取得这个值并返回它，此触发器必须按照AFTER INSERT执行CREATE TRIGGER `new_order` AFTER INSERT ON `orders` FOR EACH ROW SELECT NEW.order_num;// 删除触发器DROP TRIGGER `new_product`; INSERT触发器（在INSERT语句执行之前或之后执行）： 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被 插入的行; 在BEFORE INSERT触发器中，NEW中的值也可以被更新(允许更改 被插入的值); 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT 执行之后包含新的自动生成值。 DELETE触发器（在DELETE语句执行之前或之后执行）： 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访 问被删除的行; OLD中的值全都是只读的，不能更新。1234567// 在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值(要被删除的订单)// 保存到一个名为archive_ orders的存档表中CREATE TRIGGER `delete_order` BEFORE DELETE ON `orders` FOR EACH ROWBEGIN INSERT INTO `archive_orders`(`order_num`, `order_date`, `cust_id`) VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);END; UPDATE触发器（在UPDATE语句执行之前或之后执行）： 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问 以前(UPDATE语句前)的值，引用一个名为NEW的虚拟表访问新更新的值; 在BEFORE UPDATE触发器中，NEW中的值可能也被更新(允许更改 将要用于UPDATE语句中的值); OLD中的值全都是只读的，不能更新。123// 保证州名缩写总是大写CREATE TRIGGER `upper_vendor` BEFORE UPDATE ON `vendors` FOR EACH ROWSET NEW.vend_state = Upper(NEW.vend_state);","categories":[{"name":"mysql","slug":"mysql","permalink":"https://www.liangxinwei.cn/categories/mysql/"}],"tags":[]},{"title":"2020Flag","slug":"2020Flag","date":"2020-01-01T14:24:06.000Z","updated":"2020-04-22T02:18:01.800Z","comments":true,"path":"2020/01/01/2020Flag/","link":"","permalink":"https://www.liangxinwei.cn/2020/01/01/2020Flag/","excerpt":"","text":"工作 Icon 独立为项目（React、Vue）各一份、便于代码复用 DDL：2020-04-30 看技术书籍、设计书籍、产品书籍 DDL：2020-12-31 一个月一本 技术书籍： 计算机网络 软件工程 设计书籍： 写给大家看的设计书 简约至上 dont make me think 点石成金 产品书籍： 《幕后产品》王诗沐 《有效需求分析》徐锋 学习 TypeScript 并能有配套练习项目 DDL：2020-06-30 学习Node.js 后台并能有配套练习项目 DDL：2020-12-31，2020-06-30 完成 70% 学习MySQL、redis、MongoDB并能有配套练习项目 DDL：2020-12-31，2020-06-30 完成 70% 其他 搭建自己的GitHub Pages博客 练字，达到字迹美观工整、笔力苍劲 读一些哲学方面的书 健身，年中能有8块腹肌 学英语，单词量20000，不看字母能听懂英文电影 学习理财相关的知识，开始钱生钱","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.liangxinwei.cn/categories/随笔/"}],"tags":[]},{"title":"2019年终总结","slug":"2019年终总结","date":"2019-12-31T12:15:06.000Z","updated":"2020-04-22T02:18:01.800Z","comments":true,"path":"2019/12/31/2019年终总结/","link":"","permalink":"https://www.liangxinwei.cn/2019/12/31/2019年终总结/","excerpt":"","text":"今天是2019年12月31日，眨眼间，2019年过去了。 时间总是过的很快，尤其是走出象牙塔进入社会之后，刚毕业那会怀揣着简历到处面试的情景仍然记忆犹新。 这次的年终总结算是2018年到2019年的总结，从我入职现在的公司开始到现在，与我而言，算是很有收获的2年。 工作上这应该是挑战与机遇并存的2年，之前的工作中，我一直是只负责某一部分具体的业务，入职之后，刚开始是写C端小程序、H5活动页面，然后逐步负责公司整个B端相关系统的前端方面的工作，期间遇到过困难、经历过挑战。刚接手B端系统的时候，前同事写的比较随意，代码格式各不一样，维护起来很吃力，不过还好那会业务不算很忙，总算抽出时间重构了最核心的一部分逻辑，并且将打包时间从之前的恐怖的动辄20-30min缩短到2min之内，将webpack版本性能3升级到4，为此领导特意请我喝了一周的☕️，个人感觉还是挺有成就感的一件事。 团队中也有了新鲜的血液，不同同事之间的代码风格各不一样，如何保证代码质量就成了必须要考虑的一件事，所以我们商讨了一份内部使用的 ESLint 规则，以及code review，有利于以后的维护。 公司扩张之后，相应的，业务也随之而来，期间和另一位同事（大神）配合搭建起了针对线下各个门店的视频监控系统。第一次涉足视频领域，感觉挺不错。 工作外围随着公司的扩张，随之而来的招人和带新人就成了我工作之余的另一件事，慢慢的学会了怎么样面试别人，在这里特别感谢我的领导，总是在恰当的时间的提点我，令我感觉成长了很多，获益良多。 另外，得益于用户对移动端办公的迫切需求和小程序的急速发展，公司的B端系统也同步到了小程序上，我作为唯一的开发人员、测试人员、产品人员、UI，从申请小程序到上线第一版以及之后的版本迭代，期间未出现过重大BUG，被领导称做「全干工程师」😓。这样的经历也让我对前端开发有了更深一步的认识与理解，作为最接近用户的程序员，我们应该时刻站在用户的角度思考怎么样能让所开发的产品更易用、更简洁、交互更合理、操作更简单，并且在产品上线之后主动了解用户的反馈，并针对反馈做相应的改进，然后再上线、跟踪反馈、优化，达到整个流程的闭环。这种一个人负责所有的事情对我虽然是第一次，但是开发过程中下意识的思考UI、产品，开发完的测试，上线之后的跟踪反馈，让我耳目一新，原来前端开发人员还可以这样，为此还特意买了设计相关的书籍、B端产品相关的书籍，边看书边开发，美美哒。 前端团队成长方面，我组织公司的前端同事搭建起了前端团队的自我成长体系，并付诸于行动，每周（最长不超过2周）开一次前端分享（交流）会，包括并不限于JavaScript、CSS、React、Vue、产品、设计相关，相互督促学习，并实践与公司的项目中。以目前的反馈来看，效果挺好。通过学习，我相信不只是我，团队中的任何一位同事，都会在各个方面都有所成长。 情感上今年顺利收获女朋友一枚，工作也有了更大的动力。想给她更好的生活，就得更努力赚钱，努力工作，努力学习，一直成长。 其他最近因为一些原因，公司也开始了传说中的内部优化，虽然没有波及到研发部门，但是日渐空阔的办公室还是实时提醒着我，凛冬将至，这更让我觉得提升自己的能力才是最重要的，在这里告诫大家，一定要有危机意识，居安思危。 2020年目标明天又是新的一年，在这里立几个小目标： 前端技术方面有大的突破（多阅读源码） 学习Node.js、MongoDB、MySQL，并能有相应的后台练习项目 学习产品相关的知识 学习理财相关的知识，开始钱生钱 健身，年中能有8块腹肌 练字，达到字迹美观工整、笔力苍劲 学习英语，单词量能达到20000，慢英语能听懂 最后想说现在看来，那件事（前端团队的自我成长体系）到现在才运行起来，带给我的教训：要做成一件看起来很难的事，只是缺乏立即去做的决心，和坚持下去的恒心，仅此而已。 今年对自己整体的评价：技术方面，刚及格，主要是业务太繁忙，又刚交女朋友，学习的时间太少，其他方面，比如UI意识、产品意识等等，还算是比较满意，不再仅仅是前端开发，眼界开阔了不少，业余还看了一些理财方面的书籍，打算来年继续学习。 2020年，29岁了，希望能有更好的成长。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.liangxinwei.cn/categories/随笔/"}],"tags":[]},{"title":"B端产品经理长成读书笔记","slug":"B端产品经理长成读书笔记","date":"2019-09-12T14:51:34.000Z","updated":"2020-04-22T02:18:01.801Z","comments":true,"path":"2019/09/12/B端产品经理长成读书笔记/","link":"","permalink":"https://www.liangxinwei.cn/2019/09/12/B端产品经理长成读书笔记/","excerpt":"","text":"PMBOK：项目管理知识体系 Project Management Body Of Knowledge 产品的规则设计：1、精神理念：什么最重要2、目标：产品要达成什么目标3、谁更重要：多方冲突时保护谁4、鼓励什么：什么事再产品中会受到认可和激励5、拒绝什么：什么事不能在产品中做？禁止和惩罚什么？ 方案出错，90%是问题出错了问题-拆解-方案-结论 原则1、定义问题，2、拆解问题，3、导出方案，4、评估得出结论 更高的时间和行动成本会拉低用户对产品的需求 RFM模型RFM是最经典的客户消费行为特征分析模型，RFM代表Recency（最近一次消费时间），Frequency（某一个时间范围内的消费频次），Monetary（某一个时间范围内的平均客单价或累计交易额）。根据公司实际数据情况，将这三个指标划分成几档，可以形成多种组合（假设每个指标分五档，则可产生5x5x5个组合），对这些组合进行聚类分析，提炼出行为模式类似的多个群体，实现对客户消费特征的群体细分。 数据集市 DM Data Mart数据仓库 DW Data WarehouseBI Business Intelligence 数据仓库和大数据是两个完全不同的概念,它们在理念、技术方案、应用领域方面都完全不同,具体如下。·理念:数据仓库源于交易数据,对数据的准确性要求高,适合做离线分析;大数据源于日志的行为数据,对数据准确性要求不高,适合做自动化策略。技术方案:数据仓库采用传统的、经典的数据分析思路,即抽样、分析、预测;大数据基于海量数据和运算能力,不做抽样而做全量研究,不做分析而做模型应用。应用领域:数据仓库主要用来做企业经营分析;大数据主要用来做各种业务自动化应用。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.liangxinwei.cn/categories/读书笔记/"}],"tags":[]},{"title":"九败一胜读书笔记","slug":"九败一胜读书笔记","date":"2019-08-19T14:02:58.000Z","updated":"2020-04-22T02:18:01.804Z","comments":true,"path":"2019/08/19/九败一胜读书笔记/","link":"","permalink":"https://www.liangxinwei.cn/2019/08/19/九败一胜读书笔记/","excerpt":"","text":"获取的长期经验不是最重要的，快速学习能力是决定一个人发展现状及未来前景的重要因素。 总重契约精神，总重大家共同制订好的游戏规则，没有这个，创业就无从谈起。 CEO不可被人代替的指责是：设计公司整体愿景和所有战略，确保传达给所有利益相关方，不仅是管理层，包括所有员工，不仅是公司内部人，包括股东、消费者、商户和所有合作伙伴；招到并留住最优秀的人；确保公司要有足够的资金。 以身作则不是塑造公司价值观的最好办法，而是唯一办法。 把所有东西考虑清楚再去讨论能不能做。 2004-2009校内网给他们的经验和教训： 创业团队必须分工明确，CEO必须解放出来，关注整个业界、时代、社会发展的潮流。 快速推广很重要。 没有盲目地自我创新，快速学习别人的优点。比如模仿Facebook，在节省成本的同时，让用户有了当时一流的UI体验。 对资本的看法太过理想化了。应该更早的接触资本，降低姿态，做一些妥协。 必须和信任的人一起创业。唯有信任才能在遇到低潮的情况下让团队依旧坚持稳固。 O2O 线上线下：线上交易，线下消费 保持对未知的世界充满好奇，先把更多的会放进自己的视，才有抉择的余地。 对于社会能产生真实价值的东西，是事业最稳定的基石。不管这种东西是解决人与人的关系，还是解决人与物的关系。 互联网时代是”产品为王”的时代，是完美主义者有着系统性优势的时代。只有完美主义的人，才能把产品打磨的那么出色，产品出色，整个公司就赢了。 任何一个部门，一年只要做对一件事就能获得成功 招聘进来的人的水准应该比现有团队50%的人高，整个团队才会越来越强 对未来越有信心，对现在越有耐心。 一家老有新闻的企业并非好事，在那些枯燥，平凡的日常管理细节里，每天前进一点，日积月累，短期内看不出公司发生了多少变化，把观察时间放长一点，三五年，你就会发现这家公司可能已经脱胎换骨了。这同样适用于每个人。 未来是不确定的，只能战战兢兢，如履薄冰。 一如既往的好奇心，超强的学习能力。 免费的根本问题在于真正的免费如何盈利。 想要构建产品壁垒，就最好做自己擅长的部分。 无数平庸的细节堆积出来的，就是平庸的产品。 如果你希望在一个好的创业公司一路高歌猛进的话，每一年都是关键的一年。 小公司做起来的关键是抓住了一个机会，中等公司的关键是有一批比较强的高管，大公司的关键是要有正确的流程和价值观。 企业创始人的价值观决定整个企业其他人对待整个市场的方式。美团网价值观的排序是：消费者第一、商家第二、员工第三、股东第四、王兴第五。 核心价值观的渗透度越高，整个企业的人员稳定性才越强。公司的使命、愿景、价值观，这些看起来是虚无缥缈的东西，确是团队精神生长的坚实土地。 CEO履行好自己的指责，其他事情都应该找最专业、最好的人来做。 团队的组件原则：招进来的人，水准应该比现有团队50%的人高。只要按照这个标准，整个团队会越来越强。 公司越来越大，为了保障公司的正常运转，需要一套行之有效的组织架构和严密的流程。系统和流程保障了分工明确、权责到位，不易出差错；另一方面却让跨部门合作变得越来越困难，效率在沟通中损耗，创新的热情和机会就有可能在这些损耗中溜掉。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.liangxinwei.cn/categories/读书笔记/"}],"tags":[]},{"title":"roadhog 1.3.X 打包慢的解决办法","slug":"roadhog-1-3-X-打包慢的解决办法","date":"2019-06-11T11:01:51.000Z","updated":"2020-04-22T02:18:01.803Z","comments":true,"path":"2019/06/11/roadhog-1-3-X-打包慢的解决办法/","link":"","permalink":"https://www.liangxinwei.cn/2019/06/11/roadhog-1-3-X-打包慢的解决办法/","excerpt":"","text":"背景：公司的后台管理系统项目基于 Antd Pro 早期版本，使用的脚手架是 roadhog，虽然接入了 dva 等框架，方便了我们把工作重心集中在业务上，但是随着项目的庞大，问题随之而来，首当其冲的就是线上部署的时候打包慢的问题。因为 road 的扩展不太灵活，其本身的初衷就是尽可能减少webpack的配置，所以如何降低打包的速度就成了亟需解决的问题。 项目依赖58个，打包之后140个文件。 网上搜了一圈，发现没有令人满意的解决方案，只好自己来解决。仔细缕了一遍思路后发现，还是有解决办法的。 以下改动仅适用于公司的后台管理系统项目。 删除项目中没有用到或废弃的代码 利用好 roadhog 支持的 webpack 配置项 自己改 roadhog 的源码，然后发布为 npm 包，替换掉 roadhog 第一项不用说。 第二项是设置 webpack 的 externals，由于项目中用到了 g2、d3、echarts、@antv/data-set、moment、g-cloud、g2-plugin-slider、cal-heatmap 等 js 库，所以把它们都配置到 externals 下： 12345678910111213141516171819202122232425262728&#123; \"entry\": \"src/index.js\", \"extraBabelPlugins\": [ \"transform-runtime\", \"transform-decorators-legacy\", \"transform-class-properties\", [\"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": true &#125;] ], \"env\": &#123; \"development\": &#123; \"extraBabelPlugins\": [ \"dva-hmr\" ] &#125; &#125;, \"externals\": &#123; \"g2\": \"G2\", \"echarts\": \"echarts\", \"@antv/data-set\": \"DataSet\", \"moment\": \"moment\", \"g-cloud\": \"Cloud\", \"g2-plugin-slider\": \"G2.Plugin.slider\" &#125;, \"ignoreMomentLocale\": true, \"theme\": \"./src/theme.js\", \"hash\": true, \"multipage\": true&#125; 在 .eslint.js 将其配置为全局变量： 1234567\"globals\": &#123; \"CalHeatMap\": true, \"DataSet\": true, \"moment\": true, \"echarts\": true, \"G2\": true&#125; 以上注意： 配置 &quot;multipage&quot;: true 后，roadhog 才会把超过2次引用的依赖打为 common 包 “dva-hmr” 设置在 development 才会避免生产环境下将其打包，因为生产环境下不会用到 将这些 js 库文件（不用包涵g-cloud、g2-plugin-slider）下载下来，放到项目根目录下 public/js 下，roadhog 作者约定 public 目录下的文件会在 server 和 build 时被自动 copy 到输出目录（默认是 ./dist）下。所以可以在这里存放 favicon, iconfont, html, html 里引用的图片等。 手动在 index.ejs 里面将其引入 第三项 主要改动的地方： common.js 下 HtmlWebpackPlugin 插件配置的地方，给它配置 public 下的所有 js 文件和 css 文件的路径和环境变量：1234567891011if (existsSync(join(paths.appSrc, 'index.ejs'))) &#123; const scripts = glob.sync(path.resolve(paths.appPublic) + '/js/*.js').map(filePath =&gt; path.basename(filePath)); const stylesheets = glob.sync(path.resolve(paths.appPublic) + '/stylesheets/*.css').map(filePath =&gt; path.basename(filePath)); ret.push(new HtmlWebpackPlugin(&#123; template: 'src/index.ejs', inject: true, scripts, stylesheets, env: JSON.stringify(NODE_ENV) &#125;));&#125; 然后在你的项目的 index.ejs 中引入： 12345678910111213&lt;head&gt; &lt;% var stylesheets = htmlWebpackPlugin.options.stylesheets || [] %&gt; &lt;% for(var i = 0; i &lt; stylesheets.length; i++) &#123; %&gt; &lt;link rel=\"stylesheet\" href=\"&lt;%= 'stylesheets/' + stylesheets[i] %&gt;\"&gt; &lt;% &#125; %&gt;&lt;/head&gt;&lt;body&gt; &lt;% var scripts = htmlWebpackPlugin.options.scripts || [] %&gt; &lt;% for(var i = 0; i &lt; scripts.length; i++) &#123; %&gt; &lt;script type=\"text/javascript\" src=\"&lt;%= 'js/' + scripts[i] %&gt;\"&gt;&lt;/script&gt; &lt;% &#125; %&gt;&lt;/body&gt; 修改 webpack.config.prod.js 替换 webpack.optimize.UglifyJsPlugin 为： 12345678910...(debug ? [] : [new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, &#125;, &#125;, cache: true, sourceMap: false, parallel: true,&#125;)]), UglifyJsPlugin 的好处不必多说，大家自己 google。 删掉 webpack.optimize.CommonsChunkPlugin 配置，参考 vue-cli2 的配置项： 12345678910111213141516171819202122232425262728293031323334if (config.multipage) &#123; // Support hash const name = config.hash ? 'common.[hash]' : 'common'; // ret.push(new webpack.optimize.CommonsChunkPlugin(&#123; // name: 'common', // filename: `$&#123;name&#125;.js`, // &#125;)); ret = ret.concat([ // split vendor js into its own file // 将所有从node_modules中引入的js提取到vendor.js，即抽取库文件 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks(module) &#123; return (module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf(paths.appNodeModules) === 0); &#125;, &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated // 从vendor中提取出manifest，原因如上 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', minChunks: Infinity, &#125;), // This instance extracts shared chunks from code splitted chunks and bundles them // in a separate chunk, similar to the vendor chunk // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk new webpack.optimize.CommonsChunkPlugin(&#123; name, async: 'vendor-async', children: true, minChunks: 3, &#125;), ]);&#125; 然后，运行 npm run test，npm run build，编译好之后，发布到 npm 仓库如 liangxinwei_roadhog。 最后，删掉项目下的 package.json 里面 roadhog 相关的依赖，替换为 &quot;liangxinwei_roadhog&quot;: &quot;^1.0.0&quot;： 12345\"devDependencies\": &#123; - \"roadhog\": \"^1.3.1\", - \"roadhog-api-doc\": \"^0.1.0\", + \"liangxinwei_roadhog\": \"^1.0.0\",&#125;, 修改启动和打包命令： 12\"start\": \"node --max_old_space_size=4096 node_modules/liangxinwei_roadhog/lib/server.js\",\"build\": \"node --max_old_space_size=4096 node_modules/liangxinwei_roadhog/lib/build.js\" 经过我前后的数据比对，修改第二项之后，打包时间由原来的 20-30min 缩减到 5-6min，修改第三项之后，初次打包时间为 3-4min，再次打包时间缩减到 1min 之内。大功告成！ 前端开发长路漫漫，大家且行且珍惜。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.liangxinwei.cn/categories/前端/"}],"tags":[]},{"title":"webpack各配置项全解析","slug":"webpack各配置项全解析","date":"2019-01-30T10:59:45.000Z","updated":"2020-04-22T02:18:01.803Z","comments":true,"path":"2019/01/30/webpack各配置项全解析/","link":"","permalink":"https://www.liangxinwei.cn/2019/01/30/webpack各配置项全解析/","excerpt":"","text":"以下内容摘自【深入浅出webpack】，包含每一项的具体配置。 entry表示入口, Webpack 执行构建的第一步将从 Entry 开始,可抽象成输入，类型可以是 string、 object、 array 123456789101112// 只有 1 个入口,入口只有 1 个文件entry: &apos; ./app/entry&apos;,// 只有1个入口,入口有两个文件entry: [ &apos;./app/entry1&apos;, &apos;./app/entry2&apos;],// 有两个入口entry: &#123; a: &apos;./app/entry-a&apos;, b: [&apos;./app/entry-bl&apos;, &apos;./app/entry-b2&apos;]&#125;, output如何输出结果 : 在 Webpack 经过一系列处理后,如何输出最终想要的代码 12345678910111213141516171819202122232425262728293031323334353637&#123; // 输出文件存放的目录,必须是 string 类型的绝对路径 path: path.resolve(dirname, &apos; dist &apos;), // 输出文件的名称 // 完整的名称 filename: &apos; bundle.js&apos;, // 在配置了多个 entry 时,通过名称模板为不同的 entry 生成不同的文件名称 filename: &apos; [name].js&apos;, // 根据文件内容的 Hash 值生成文件的名称, 用于 浏览器长时间缓存文件 filename: &apos; [chunkhash].js&apos;, // 放到指定目录下 // 发布到线上的所有资源的 URL 前缀,为 string 类型 publicPath: &apos;/assets/&apos;, // 放到根目录下 publicPath: &apos;&apos;, // 放到 CDN 上 // 导出库的名称 , 为 string 类型, 不填它时,默认的输出格式是匿名的立即执行函数 publicPath: &apos;https://cdn.example.com/&apos;, library: &apos; MyLibrary &apos;, // 导出库的类型,为枚举类型,默认是 var // 可以是umd、 umd2、 commonjs2、 commonjs、 amd、 this、 var、 assign、 window、global、jsonp libraryTarget: &apos;umd&apos;, // 是否包含有用的文件路径信息到生成的代码里 ,为 boolean 类型 pathinfo: true, // 附加 Chunk 的文件名称 chunkFilename: &apos;[id].js&apos;, chunkFilename: &apos;[chunkhash].js&apos;, // JSONP 异步加载资源时的回调函数名称,需要和服务端搭配使用 jsonpFunction: &apos;myWebpackJsonp&apos;, // 生成的 Source Map 文件的名称 // 浏览器开发者工具里显示的源码模块名称 sourceMapFilename: &apos;[file].map&apos;, // 异步加载跨域的资源时使用的方式 devtoolModuleFilenameTemplate: &apos;webpack:lll[resource-path]&apos;, crossOriginLoading: &apos;use-credentials&apos;, crossOriginLoading: &apos;anonymous&apos;, crossOriginLoading: false&#125;, module配置模块相关 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&#123; // 不用解析和处理的模块，Webpack忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能 // 注意，被忽略掉的文件里不应该包含 import、 require、 define 等模块化语句， // 不然会导致在构建出的代码中包含无法在浏览器环境下执行的模块化语句。 // 单独、完整的 、react.min.js、文件没有采用模块化，忽略对 、react.min.js、文件 的递归解析处理 noParse: [/react\\.min\\.js$/], // 配置 Loader rules: [ &#123; // 正则匹配命中要使用 Loader 的文件 test: /\\.jsx$/, // 只会命中这里面的文件 include: [ path.resolve(__dirname, &apos;src&apos;) ], // 忽略这里面的文件 exclude: [ path.resolve(__dirname, &apos;node_modules&apos;) ], // 使用哪些 Loader,有先后次序,从后向前执行 use: [ // style-loader会将 css代码转换成字符串后，注入 JavaScript代码中，通过 JavaScript 向 DOM 增加样式。 如果我们想将 css 代码提取到一个单独的文件中，而不是和 JavaScript 混在 一 起，则可以使用 ExtractTextPlugin &apos;style-loader&apos;, // css-loader 会找出 css 代码中 eimport 和 url ()这样的导入语句，告诉 Webpack 依赖这些资源 。 同时支持 CSS Modules、压缩 css 等功能 。处理完后再将结果交给 style-loader处理。 &apos;css-loader&apos;, // 通过 sass-loader将 scss 源码转换为 css 代码，再将 css 代码交给 css-loader处理。 &apos;sass-loader&apos;, // 直接使用 Loader 的名称 &#123; loader: &apos;css-loader&apos;, // 向 html-loader 传一些参数 options: &#123;&#125; &#125;, ], // 不用解析和处理的模块，Webpack忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能 noParse: [ // 用正则匹配 /special-library\\.js$/ ] &#125; ], /** * 配置插件 */ plugins: [], /** * 配置寻找模块的规则 */ resolve: &#123; // 寻找模块的根目录,为 array 类型,默认以 node_modules 为根目录 // 可以指明存放第三方模块的绝对路径，以减少寻找， dirname 表示当前工作目录 modules: [path.resolve(__dirname, &apos;node_modules&apos;)], modules: [ &apos;node modules &apos;, path.resolve(__dirname, &apos;app&apos;) ], // 模块的后缀名，后缀尝试列表要尽可能小，频率出现最高的文件后缀要优先放在最前面 extensions: [&apos;.js&apos;, &apos;json&apos;, &apos;jsx&apos;, &apos;.css&apos;], // 模块别名配置,用于映射模块，从而跳过耗时的递归解析操作。 alias: &#123; // 将 &apos;module&apos;映射成&apos;new-module&apos; ,同样, &apos;module/path/file&apos;也会被映射 成&apos;new-module/path/file&apos; &apos;module&apos;: &apos;new-module&apos;, // 使用结尾符号$后 ,将 &apos;only-module&apos; 映射成 &apos;new-module&apos;, // 但是不像上面的 ,&apos; module/path/file &apos;不会被映射成&apos; new-module/path/file &apos;only-module$&apos;: &apos;new-modules&apos;, &#125;, // alias 还支持使用数组来更详细地进行配置 alias: [ &#123; // 老模块 name: &apos;module&apos;, // 新模块 alias: &apos;new-module &apos;, // 是否只映射模块,如果是 true, 则只有&apos; module &apos;会被映射:如果是 false,则&apos;module/inner/path &apos;也会被映射 onlyModule: true, &#125; ], // 是否跟随文件的软链接去搜寻模块的路径 symlinks: true, // 模块的描述文件 descriptionFiles: [&apos; package.json &apos;], // 模块的描述文件里描述入口的文件的字段名 mainFields: [&apos; main &apos;], // 是否强制导入语句写明文件后缀 enforceExtension: false &#125;, /** * 输出文件的性能检查配置 */ performance: &#123; // 有性能问题时输出警告 hints: &apos;warning &apos;, // 有性能问题时输出错误 hints: &apos;error &apos;, // 关闭性能检查 hints: false, // 最大文件的大小(单位为 bytes) maxAssetSize: 200000, // 最大入口文件的大小 (单位为 bytes) maxEntrypointSize: 400000, // 过滤要检查的文件 assetFilter: function (assetFilename) &#123; return assetFilename.endsWith(&apos; .css &apos;) || assetFilename.endsWith(&apos;.js&apos;); &#125; &#125;, // 配置 source-map 类型 devtool: &apos; source-map &apos;, // Webpack 使用的根目录, string 类型必须是绝对路径 // 配置输出代码的运行环境 context: __dirname, // 浏览器,默认 target: &apos;web&apos;, // WebWorker target: &apos;webworker&apos;, // Node.js,使用 、require、语句加载 Chunk代码 target:&apos;async-node&apos;, II Node.js,异步加载 Chunk代码 target: &apos;node&apos;, // nw.js target: &apos;node-webkit&apos;, // electron,主线程 target: &apos;electron-main&apos;, // electron,渲染线程 target: &apos;electron-renderer&apos;, // 使用来自 JavaScript 运行环境提供的全局变量 externals: &#123; jquery: &apos;jQuery&apos; &#125;, /** * 控制台输出日志控制 */ stats: &#123; assets: true, colors: true, errors: true, errorDetails: true, hash: true &#125;, /** * DevServer 相关的配置 */ devServer: &#123; // 代理到后端服务接口 proxy: &#123; &apos;/api&apos;: &apos;http:// localhost:3000&apos; &#125;, // 配置 DevServer HTTP 服务器的文 件根目录 contentBase: path.join(__dirname, &apos;public&apos;), // 是否开启 Gzip 压缩 compress: true, // 是否开发 HTMLS History API 网页 historyApiFallback: true, // 是否开启模块热替换功能 hot: true, // 是否开启 HTTPS 模式 https: false, // 是否捕捉 Webpack构建的性能信息,用于分析是什么原因导致构建性能不佳 profile: true, // 是否启用缓存来提升构建速度 cache: false, // 是否开始 watch: true, // 监听模式选项 // 不监听的文件或文件夹,支持正则匹配。默认为空 watchOptions: &#123; ignored: /node modules/, // 监听到变化发生后,等 300ms 再执行动作,截流,防止文件更新太快导致重新编 译频率太快。默认为 300ms aggregateTimeout: 300, // 不停地询问系统指定的文件有没有发生变化,默认每秒询问 1000 次 poll: 1000 &#125; &#125;&#125;,","categories":[{"name":"前端","slug":"前端","permalink":"https://www.liangxinwei.cn/categories/前端/"}],"tags":[]},{"title":"小程序和h5页面之间的互相跳转","slug":"小程序和h5页面之间的互相跳转","date":"2018-10-23T11:02:45.000Z","updated":"2020-04-22T02:18:01.805Z","comments":true,"path":"2018/10/23/小程序和h5页面之间的互相跳转/","link":"","permalink":"https://www.liangxinwei.cn/2018/10/23/小程序和h5页面之间的互相跳转/","excerpt":"","text":"小程序跳转到 h5 页面小程序代码： 1wx.navigateTo(&#123;url: &apos;/pages/webview?url=&apos; + encodeURIComponent(&apos;h5页面的 url&apos;)&#125;); webview.js 12345678910111213&lt;web-view src=&quot;&#123;&#123;url&#125;&#125;&quot; bindmessage=&quot;handlePostMessage&quot;&gt;&lt;/web-view&gt;onLoad: function (options) &#123; this.setData(&#123; url: decodeURIComponent(options.url), &#125;);&#125;,// 接收 h5 页面传递过来的参数handlePostMessage: function (e) &#123; const data = e.detail; console.log(data);&#125; h5 页面代码： 1234&lt;head&gt; ··· &lt;script type=&quot;text/javascript&quot; src=&quot;https://res.wx.qq.com/open/js/jweixin-1.3.2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 记得把 url 的 host 添加到后台的合法域名中。 h5 页面跳回小程序在 h5 页面的任何点击事件中： 12345678/* eslint-disable */ wx.miniProgram.getEnv(function (res) &#123; if (res.miniprogram) &#123; wx.miniProgram.switchTab(&#123;url: &apos;/pages/home/home&apos;&#125;); wx.miniProgram.postMessage(&#123;data: &#123;id: &apos;1234&apos;&#125;&#125;); // 传的参数 &#125; &#125;); /* eslint-enable */ 请注意，是wx.miniProgram，不是 window.wx.miniProgram","categories":[{"name":"小程序","slug":"小程序","permalink":"https://www.liangxinwei.cn/categories/小程序/"}],"tags":[]},{"title":"微信订阅号开发之获取网页授权","slug":"微信订阅号开发之获取网页授权","date":"2018-10-17T11:02:20.000Z","updated":"2020-04-22T02:18:01.805Z","comments":true,"path":"2018/10/17/微信订阅号开发之获取网页授权/","link":"","permalink":"https://www.liangxinwei.cn/2018/10/17/微信订阅号开发之获取网页授权/","excerpt":"","text":"题记：项目（Vue）是h5页面，主要用于公众号里面的活动，目的是增加公众号关注人数，达到推广的目的，其中涉及到获取用户的昵称、头像、unionid等基本信息。由于微信公众号改版成订阅号之后，并没有获取用户信息的接口，服务号才有，详情可查看官方文档。所以目前想到的思路是借用和订阅号关联的服务号获取 code，然后利用获取到的code 发送给后端再请求用户信息。 首先，route.js 里面配置 needUnionId，通过 checkUnionId HOC 加工页面使其先获取 unionid，然后再通过 unionid 请求数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import Vue from 'vue';import Router from 'vue-router';import &#123;Util&#125; from './utils';import store from './store/store';import http from './store/module/http';import &#123;checkUnionId&#125; from './hoc';Vue.use(Router);const dynamicImport = (path) =&gt; async (resolve) =&gt; &#123; const module = await import(`./pages/$&#123;path&#125;`); resolve(module);&#125;;/** * 设置项： * * meta: * title: 页面标题 * checkUnionId: 如果需要一进入页面就发请求并携带参数 unionid，则接入 checkUnionId * * 注意：以下的 component 为 dynamicImport 类型的，dynamicImport 的参数都有 ../pages/ 前缀， */const routerList = [ &#123; path: '/wx-login', name: 'WXLogin', meta: &#123; needUnionId: true &#125;, component: dynamicImport('login/wx-login') &#125;, &#123; path: '/login', name: 'login', component: dynamicImport('login/login') &#125;, &#123; path: '*', name: 'not-found', component: dynamicImport('exception/not-found'), meta: &#123;&#125; &#125;];function machiningRouter(arr) &#123; arr.forEach(v =&gt; &#123; const needUnionId = (v.meta || &#123;&#125;).needUnionId === true; if (v.component &amp;&amp; needUnionId) &#123; v.component = checkUnionId(v.component); &#125; if (!needUnionId &amp;&amp; v.children) &#123; machiningRouter(v.children); &#125; &#125;);&#125;machiningRouter(routerList);const router = new Router(&#123; // mode: 'history', // base: '/', routes: routerList&#125;);router.beforeEach((to, from, next) =&gt; &#123; const metaData = to.meta || &#123;&#125;; !metaData.hidden &amp;&amp; http.actions.setLoading(store, &#123;status: true&#125;); metaData.title &amp;&amp; Util.setDocumentTitle(metaData.title); next();&#125;);router.afterEach(route =&gt; &#123; const metaData = route.meta || &#123;&#125;; !metaData.hidden &amp;&amp; http.actions.setLoading(store, &#123;status: false&#125;);&#125;);export default router; 先看 wx-login.vue 的使用方式： 12345678910111213141516171819202122232425262728import &#123;Url, Util&#125; from '@/utils';import &#123;WeChat, closeWindow&#125; from '@/utils/wechat';export default &#123; name: 'WXLogin', data() &#123; return &#123; &#125;; &#125;, created() &#123; // 不需要 // this.requestData(); &#125;, methods: &#123; // 适用于一进入页面就请求数据，checkUnionId 会自动调用，不需要在 created 里面手动调用 async requestData() &#123; &#125;, // 适用于点击按钮才请求数据，此时 checkUnionId 已经获取到了 unionid async handleLogin() &#123; const param = &#123; unionid: this.$parent.unionId, &#125;; await this.$http.post(Url.PMS_QR_CODE_LOGIN, param); this.$toast('扫码登录成功'); this.status = 'success'; &#125;, &#125;&#125;; 其中，checkUnionId.js 为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import &#123;mapActions, mapGetters&#125; from 'vuex';import &#123;getUnionId, WeChat&#125; from '@/utils/wechat';/** * 校验 openId 是否为 null */export default (component) =&gt; (&#123; computed: &#123; ...mapGetters(['unionId']) &#125;, props: component.props, render(h) &#123; return h(component, &#123; on: this.$listeners, attrs: this.$attrs, props: this.$props &#125;); &#125;, mounted() &#123; this.requestUnionId(); &#125;, methods: &#123; ...mapActions(['setLoading']), async requestUnionId() &#123; try &#123; if (this.unionId) &#123; console.log('local unionId:', this.unionId); this.afterRequestUnionId(); &#125; else &#123; this.$toast('获取信息中···'); await getUnionId(); await new WeChat().init(); this.afterRequestUnionId(); &#125; &#125; catch (e) &#123; console.error('check-unionid requestUnionId:', e); &#125; &#125;, afterRequestUnionId() &#123; // fixme: mounted 先于子组件的 mounted 执行，所以不在 setTimeout 里执行的话，this.$children 获取不到，因为页面是按需加载，不是全量加载 setTimeout(() =&gt; &#123; this.$children.forEach(v =&gt; &#123; if (!v.requestData || Object.prototype.toString.call(v) !== '[object Function]') &#123; console.warn('用 checkUnionId 装饰的页面中，如果需要一进入页面就立即发送带 union_id 的请求，那么 methods 中必须有 requestData function 用于获取初始数据，否则，请忽略此条。'); &#125; else &#123; v.requestData(); &#125; &#125;); &#125;, 200); &#125; &#125;&#125;); wechat.js 为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import Vue from 'vue';import store from '@/store/store';import user from '@/store/module/user';import http from '@/store/module/http';import Util from './util';import axiosInstance from './axios-instance';import Url from './url';const APP_ID = 'APP_ID';const DEFAULT_DATA = &#123; appId: APP_ID, apiList: [ 'checkJsApi', 'closeWindow', 'hideAllNonBaseMenuItem' ], errorType: [ &#123;code: '1', msg: '分享成功'&#125;, &#123;code: '2', msg: '微信客户端版本过低，请升级最新版本'&#125;, &#123;code: '3', msg: '获取接口的签名失效，请重新调用方法获取API授权签名'&#125;, &#123;code: '4', msg: '微信分享失败，请重新分享'&#125;, &#123;code: '5', msg: '接口访问失败'&#125;, &#123;code: '6', msg: 'jsApi配置成功'&#125; ]&#125;;/** * 微信 api 全局管理器 */let instance;class WeChat &#123; constructor() &#123; if (!instance) &#123; instance = this; &#125; this.hasInit = false; return instance; &#125; init() &#123; return new Promise(async (resolve, reject) =&gt; &#123; if (this.hasInit) &#123; resolve(&#123;msg: 'success'&#125;); return; &#125; try &#123; // const config = await axiosInstance.post(Url.SIGNATURE, &#123;url: location.origin&#125;); const config = &#123;&#125;; const registerData = &#123; debug: false, appId: DEFAULT_DATA.appId, timestamp: config.timestamp, nonceStr: config.noncestr, signature: config.signature, jsApiList: DEFAULT_DATA.apiList &#125;; wx.config(registerData); wx.ready(() =&gt; &#123; console.log('wx.ready'); wx.hideAllNonBaseMenuItem &amp;&amp; wx.hideAllNonBaseMenuItem(); if (!localStorage.getItem('userUnionId')) &#123; closeWindow(); throw new Error('unionid is null'); &#125; this.hasInit = true; resolve(&#123;msg: 'success'&#125;); &#125;); wx.error(res =&gt; &#123; wx.hideAllNonBaseMenuItem &amp;&amp; wx.hideAllNonBaseMenuItem(); // Vue.$toast('请退出去重新进入'); // closeWindow(); // throw res; &#125;); &#125; catch (e) &#123; throw e; &#125; &#125;); &#125;&#125;function closeWindow() &#123; typeof wx !== 'undefined' &amp;&amp; wx.closeWindow &amp;&amp; wx.closeWindow();&#125;/** * 获取 code */function getCode() &#123; const url = encodeURIComponent(location.href); window.location.href = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;APP_ID&#125;&amp;redirect_uri=$&#123;url&#125;&amp;response_type=code&amp;scope=snsapi_userinfo&amp;connect_redirect=1&amp;state=$&#123;Util.getRandomKey()&#125;#wechat_redirect`;&#125;/** * 获取 user unionId */function getUnionId() &#123; return new Promise(async (resolve, reject) =&gt; &#123; const existedUnionId = localStorage.getItem('userUnionId'); if (existedUnionId) &#123; console.log('缓存中的 onion_id:', existedUnionId, ', 不发请求'); http.actions.setLoading(store, &#123;status: false&#125;); user.actions.setOpenId(store, existedUnionId); resolve(&#123;msg: 'success'&#125;); return; &#125; const code = Util.getUrlSearchParameter().code; console.log('code:', code); if (code) &#123; const result = await axiosInstance.get(Url.USER_INFO, &#123;params: &#123;code&#125;&#125;).catch(e =&gt; &#123; closeWindow(); throw e; &#125;); result.telephone &amp;&amp; user.actions.setTelephoneNumber(store, result.telephone); result.openid &amp;&amp; user.actions.setOpenId(store, result.openid); result.unionid &amp;&amp; user.actions.setUnionId(store, result.unionid); result.nickname &amp;&amp; user.actions.setNickname(store, result.nickname); result.headimgurl &amp;&amp; user.actions.setHeadImgUrl(store, result.headimgurl); resolve(&#123;msg: 'success'&#125;); &#125; else &#123; console.log('没有 code，微信即将重定向···'); getCode(); &#125; &#125;);&#125;export &#123; WeChat, getUnionId, closeWindow&#125;; wechat.js 里面涉及到的 Util 方法： 123456789101112131415161718192021222324/*** 生成唯一的 key*/export function getRandomKey(len = 6) &#123; len = Object.prototype.toString.call(len) === '[object Number]' ? len : 6; len = Math.abs(len) || 6; return Math.random().toString(16).substr(-len);&#125;/*** 获取 URL 的 search 参数值*/export function getUrlSearchParameter() &#123; const search = window.location.search.replace('?', ''); const searchList = search.split('&amp;'); const searchObj = &#123;&#125;; searchList.length &gt; 0 &amp;&amp; searchList.forEach(v =&gt; &#123; const list = v.split('='); if (list.length === 2) &#123; searchObj[list[0]] = list[1]; &#125; &#125;); return searchObj;&#125;","categories":[{"name":"小程序","slug":"小程序","permalink":"https://www.liangxinwei.cn/categories/小程序/"}],"tags":[]},{"title":"浏览器/iframe 全屏、退出全屏","slug":"浏览器-iframe-全屏、退出全屏","date":"2018-08-15T10:56:06.000Z","updated":"2020-04-22T02:18:01.807Z","comments":true,"path":"2018/08/15/浏览器-iframe-全屏、退出全屏/","link":"","permalink":"https://www.liangxinwei.cn/2018/08/15/浏览器-iframe-全屏、退出全屏/","excerpt":"","text":"外面的 html 文件 index.html： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;fullScreen&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe allowfullscreen src=&quot;iframe.html&quot; frameborder=&quot;0&quot; style=&quot;width: 500px;height: 500px;background:#aaa&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 里面嵌套的 iframe.html 文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;iframe&lt;/h1&gt; &lt;button id=&quot;button&quot;&gt;全屏&lt;/button&gt; &lt;script&gt; // 判断是否允许全屏 var fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled; // 全屏 function launchFullscreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullScreen(); &#125; &#125; // 退出全屏 function exitFullscreen() &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if (document.msExitFullscreen) &#123; document.msExitFullscreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125; &#125; var btn = document.querySelector(&apos;#button&apos;); if (fullscreenEnabled) &#123; btn.addEventListener(&apos;click&apos;, function () &#123; var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement; if (fullscreenElement) &#123; exitFullscreen(); btn.innerHTML = &apos;全屏&apos;; &#125; else &#123; launchFullscreen(document.documentElement); btn.innerHTML = &apos;退出全屏&apos;; &#125; &#125;, false); &#125; // 监听全屏事件 document.addEventListener(&apos;webkitfullscreenchange&apos;, function fullscreenChange() &#123; if (document.fullscreenEnabled || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) &#123; console.log(&apos;enter fullscreen&apos;); &#125; else &#123; console.log(&apos;exit fullscreen&apos;); &#125; &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.liangxinwei.cn/categories/前端/"}],"tags":[]},{"title":"javaweb常见HTTP状态码","slug":"javaweb常见HTTP状态码","date":"2017-12-23T10:53:27.000Z","updated":"2020-04-22T02:18:01.803Z","comments":true,"path":"2017/12/23/javaweb常见HTTP状态码/","link":"","permalink":"https://www.liangxinwei.cn/2017/12/23/javaweb常见HTTP状态码/","excerpt":"","text":"客户端 404 -Not Found 代表客户端错误，指的是服务器端无法找到所请求的资源 400 -请求无效，服务器不理解请求的语法 403 - 禁止访问 ，服务器拒绝请求 405 - 资源被禁止，禁用请求中指定的方法 406 - 无法接受 ，无法使用请求的内容特性响应请求的网页 407 - 要求代理身份验证 ，此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理 408 - 请求超时，服务器等候请求时发生超时 409 - 冲突，服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息 410 - 已删除，如果请求的资源已永久删除，服务器就会返回此响应。 411 - 需要有效长度， 服务器不接受不含有效内容长度标头字段的请求。 412 - 未满足前提条件， 服务器未满足请求者在请求中设置的其中一个前提条件。 413 - 请求实体过大，服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 - 请求的 URI 过长， 请求的 URI（通常为网址）过长，服务器无法处理。 415 - 不支持的媒体类型， 请求的格式不受请求页面的支持。 416 - 请求范围不符合要求，如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 - 未满足期望值，服务器未满足”期望”请求标头字段的要求 500 - 内部服务器错误，无法完成请求 501 - 未实现 ，服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码 502 - 网关错误 ，服务器作为网关或代理，从上游服务器收到无效响应 503 - 服务不可用，服务器目前无法使用，通常，这只是暂时状态 504 - 网关超时， 服务器作为网关或代理，但是没有及时从上游服务器收到请求 505 - HTTP 版本不受支持， 服务器不支持请求中所用的 HTTP 协议版本 服务端 2xx - 客户端请求已成功。 200 - 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页 201 - 已创建，请求成功并且服务器创建了新的资源 202 - 已接受，但尚未处理 203 - 非权威性信息，服务器已成功处理了请求，但返回的信息可能来自另一来源 204 - 无内容，服务器成功处理了请求，但没有返回任何内容 205 - 重置内容，服务器成功处理了请求，但没有返回任何内容 206 - 部分内容，服务器成功处理了部分 GET 请求 3xx - 重定向 302 - 对象已移动 304 - 未修改 307 - 临时重定向 附上全部状态码：HTTP response codes","categories":[{"name":"前端","slug":"前端","permalink":"https://www.liangxinwei.cn/categories/前端/"}],"tags":[]},{"title":"javascript循环与闭包","slug":"javascript循环与闭包","date":"2017-11-08T10:54:53.000Z","updated":"2020-04-22T02:18:01.802Z","comments":true,"path":"2017/11/08/javascript循环与闭包/","link":"","permalink":"https://www.liangxinwei.cn/2017/11/08/javascript循环与闭包/","excerpt":"","text":"当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 下面我们来看一段代码，清晰地展示了闭包： 123456789function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 —— 这就是闭包的效果。 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz() ，实际上只是通过不同的标识符引用调用了内部的函数 bar() 。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。 要说明闭包， for 循环是最常见的例子。 12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000);&#125; 正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。 仔细想一下，延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0) ，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i 。 我们来试一下通过声明并立即执行一个函数来创建作用域 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function () &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000); &#125;)();&#125; 这样不行。但是为什么呢？我们现在显然拥有更多的词法作用域了。的确每个延迟函数都会将 IIFE（立即执行函数表达式） 在每次迭代中创建的作用域封闭起来。如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。它需要有自己的变量，用来在每个迭代中储存 i 的值： 12345678for (var i = 1; i &lt;= 5; i++) &#123; (function () &#123; var j = i; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)();&#125; 行了！它能正常工作了！。 可以对这段代码进行一些改进： 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function (j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)(i);&#125; 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 仔细思考我们对前面的解决方案的分析。我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。 let 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。因此，下面的代码可以正常运行了： 123456for (var i = 1; i &lt;= 5; i++) &#123; let j = i; // 是的，闭包的块作用域！ setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000);&#125; 但是，这还不是全部！for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000);&#125; 这样，问题解决了！","categories":[{"name":"前端","slug":"前端","permalink":"https://www.liangxinwei.cn/categories/前端/"}],"tags":[]},{"title":"记一次管理系统和路由系统的整合","slug":"记一次管理系统和路由系统的整合","date":"2017-09-28T10:58:27.000Z","updated":"2020-04-22T02:18:01.807Z","comments":true,"path":"2017/09/28/记一次管理系统和路由系统的整合/","link":"","permalink":"https://www.liangxinwei.cn/2017/09/28/记一次管理系统和路由系统的整合/","excerpt":"","text":"需求：整合管理系统和路由系统UI：同 Ant Design Pro \b 分析由于左侧管理菜单内容在运行时才能确定，而且点击菜单要和右侧内容区联动，地址栏也要有相应的改变，而目前已有的路由系统都是要运行之前要确定具体的路由组建，因此采用 h5 的 history 和 传统的 document.location 结合的方式实现路由系统；整个项目的数据管理则因为考虑到左侧菜单对应的组件可能会使用包括 redux/mbox/dva/kao 之类的框架，如果也使用框架的话，可能会引起冲突，故通过 react 的 context 来实现。 路由系统 router.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889let instance = undefined;class Router &#123; constructor() &#123; if (!instance) &#123; this.history = window.history; this.location = window.location; instance = this; &#125; return instance; &#125; goBack = (cb) =&gt; &#123; this.history.back(); cb &amp;&amp; cb(); &#125; goForward = (cb) =&gt; &#123; this.history.forward(); cb &amp;&amp; cb(); &#125; go = (num, cb) =&gt; &#123; this.history.go(num); cb &amp;&amp; cb(); &#125; pushState = (url, state, cb) =&gt; &#123; url = url || ''; // 加 #，以 hash 的方式改变 url；如果不加，直接以 '/abc' 更改，刷新会报错，请求不到资源（js,css,···） url = url[0] === '/' ? `#$&#123;url&#125;` : `/#$&#123;url&#125;`; this.history.pushState(state || null, '', url); cb &amp;&amp; cb(); &#125; replaceState = (url, state, cb) =&gt; &#123; url = url || '/'; url = url[0] === '/' ? `#$&#123;url&#125;` : `/#$&#123;url&#125;`; this.history.replaceState(state || null, '', url); cb &amp;&amp; cb(); &#125; currentState = () =&gt; &#123; return this.history.state; &#125; currentUrl = () =&gt; &#123; let url = this.location.hash.replace('#', ''); if (url[0] === '/') &#123; url = url.replace('/', ''); &#125; return url; &#125; rootUrl = () =&gt; &#123; return this.location.host; &#125; originUrl = () =&gt; &#123; return this.location.origin; &#125; fullUrl = () =&gt; &#123; return this.location.href; &#125; historyLength = () =&gt; &#123; return this.history.length; &#125;&#125;/** * 拦截器 拦截读写权限 */const handler = &#123; set(target, key, value) &#123; throw new Error(`Setting the $&#123;key&#125; prototype is forbidden`); &#125;, deleteProperty(target, key) &#123; throw new Error(`Deleting the $&#123;key&#125; prototype is forbidden`); &#125;, defineProperty (target, key, descriptor) &#123; throw new Error(`Defining the $&#123;key&#125; prototype is forbidden`); &#125;, setPrototypeOf (target, proto) &#123; throw new Error('Changing the prototype is forbidden'); &#125;&#125;;const routerInstance = new Proxy(new Router(), handler); 路由装饰函数 withRouter.js12345678910111213141516171819202122232425262728293031323334353637383940414243const withRouter = (config = &#123;&#125;) =&gt; (WrapComponent) =&gt; &#123; return class Component extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; data: &#123;&#125; &#125;; &#125; componentDidMount() &#123; config.listenPopState === true &amp;&amp; window.addEventListener('popstate', this.handlePopState); &#125; handlePopState = (data) =&gt; &#123; this.setState(&#123;data: data&#125;); &#125; componentWillUnmount() &#123; config.listenPopState === true &amp;&amp; window.removeEventListener('popstate', this.handlePopState); &#125; render() &#123; const router = &#123; go: routerInstance.go, goBack: routerInstance.goBack, fullUrl: routerInstance.fullUrl, rootUrl: routerInstance.rootUrl, originUrl: routerInstance.originUrl, goForward: routerInstance.goForward, pushState: routerInstance.pushState, currentUrl: routerInstance.currentUrl, replaceState: routerInstance.replaceState, currentState: routerInstance.currentState, historyLength: routerInstance.historyLength &#125;; return React.createElement(WrapComponent, &#123; routerData: this.state.data, router: new Proxy(router, handler),// handler 上面定义的拦截器 ...this.props &#125;); &#125; &#125;;&#125;; 入口组建 App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import React from 'react';import PropTypes from 'prop-types';import &#123;Layout&#125; from 'antd';import GYSider from './GYSider';import GYHeader from './GYHeader';import GYContent from './GYContent';import Test_1 from '../app/Test_1';import Test_2 from '../app/Test_2';import Test_3 from '../app/Test_3';import Test_1_1_1 from '../app/Test_1_1_1';import &#123;withRouter&#125; from '../util/router';import Util from '../util/Util';const &#123;Header, Sider, Content&#125; = Layout;@withRouter()class App extends React.Component &#123; constructor(props) &#123; super(props); const propsState = props.initialState || &#123;&#125;; const initialState = &#123; menuList: [ &#123; path: 'test_1', icon: 'user', text: 'test_1', component: Test_1, children: [ &#123; path: 'test_1/test_1_1', text: 'test_1_1', children: [ &#123; path: 'test_1/test_1_1/test_1_1_1', component: Test_1_1_1, text: 'test_1_1_1' &#125; ] &#125; ] &#125;, &#123; path: 'test_2', icon: 'setting', text: 'test_2', component: Test_2 &#125;, &#123; path: 'test_3', icon: 'logout', text: 'test_3', component: Test_3 &#125; ] &#125;; this.state = &#123; store: &#123; menuList: initialState.menuList.concat(propsState.menuList || []) &#125;, collapsed: false, currentPath: '', currentComponent: GYContent &#125;; this.getAllComponent(this.state.store.menuList); &#125; /** * 保存所有的路由对应的组件 */ getAllComponent = (menuList = []) =&gt; &#123; this.allComponent = this.allComponent || new Map(); menuList.forEach(val =&gt; &#123; if (val.path &amp;&amp; Util.isReactComponent(val.component)) &#123; this.allComponent.set(val.path, val.component); &#125; if (Util.isArray(val.children)) &#123; this.getAllComponent(val.children); &#125; &#125;); &#125; static contextTypes = &#123; store: PropTypes.object, onClickAction: PropTypes.func &#125; static childContextTypes = &#123; store: PropTypes.object.isRequired, onClickAction: PropTypes.func.isRequired &#125; /** * 子组件获取 store */ getChildContext() &#123; return &#123; store: this.state.store, onClickAction: this.handleClickAction &#125;; &#125; /** * 更新 store 时需要返回合并之后的数据 */ handleClickAction = (data) =&gt; &#123; this.setState(Object.assign(this.state, data)); &#125; componentWillMount() &#123; // 刷新浏览器，跳转到相应页面 const currentPath = this.state.currentPath; const documentHref = this.props.router.currentUrl(); if (currentPath !== documentHref &amp;&amp; this.allComponent.has(documentHref)) &#123; this.setState(&#123; currentComponent: this.allComponent.get(documentHref) &#125;); &#125; &#125; onToggle = () =&gt; &#123; this.setState(&#123; collapsed: !this.state.collapsed &#125;); &#125; onCollapse = () =&gt; &#123; console.log('onCollapse'); &#125; render() &#123; const Component = this.state.currentComponent; return ( &lt;Layout className='gy-app-view'&gt; &lt;Sider collapsible breakpoint=\"md\" width=&#123;256&#125; collapsed=&#123;this.state.collapsed&#125; trigger=&#123;null&#125; onCollapse=&#123;this.onCollapse&#125; &gt; &lt;GYSider/&gt; &lt;/Sider&gt; &lt;Layout&gt; &lt;Header className='header'&gt; &lt;GYHeader collapsed=&#123;this.state.collapsed&#125; onToggle=&#123;this.onToggle&#125;/&gt; &lt;/Header&gt; &lt;Content className='gy-content'&gt; &lt;Component/&gt; &lt;/Content&gt; &lt;/Layout&gt; &lt;/Layout&gt; ); &#125;&#125;export default App; 侧边栏组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import React, &#123;Component&#125; from 'react';import &#123;Menu, Icon&#125; from 'antd';const SubMenu = Menu.SubMenu;import Util from '../util/Util';import &#123;withRouter&#125; from '../util/router';import connectStore from '../util/connectStore';@withRouter() // 接入路由@connectStore // 接入 storeclass GYSider extends Component &#123; constructor(props) &#123; super(props); &#125; componentWillReceiveProps(nextProps, nextContext) &#123; console.log('点击 subMenu 更新 store', nextContext.store); &#125; onMenuClick = (&#123;item, key, keyPath&#125;) =&gt; &#123; let self = this; const path = item.props.path; const currentUrl = this.props.router.currentUrl() || ''; path &amp;&amp; path !== currentUrl &amp;&amp; item.props.component &amp;&amp; self.props.router.pushState(`/$&#123;path&#125;`, &#123;path: `/$&#123;path&#125;`&#125;, () =&gt; &#123; self.context.onClickAction(&#123; currentPath: path, currentComponent: item.props.component &#125;); &#125;); &#125; /** * 更新 store 示例 */ onSubMenuClick = (&#123;key, domEvent&#125;) =&gt; &#123; let store = this.context.store; this.context.onClickAction(&#123;store: Object.assign(store, &#123;[key]: key&#125;)&#125;); &#125; createMenu = (arr = []) =&gt; &#123; return arr.map &amp;&amp; arr.map(val =&gt; &#123; if (!val.text) &#123; return undefined; &#125; else &#123; const key = val.path || Util.generateKey(); return Util.isArray(val.children) ? &lt;SubMenu key=&#123;key&#125; onTitleClick=&#123;this.onSubMenuClick&#125; title=&#123;&lt;span&gt;&#123;val.icon &amp;&amp; &lt;Icon type=&#123;`$&#123;val.icon&#125;`&#125;/&gt;&#125; &lt;span&gt; &#123;val.text&#125; &lt;/span&gt; &lt;/span&gt;&#125;&gt; &#123;this.createMenu(val.children)&#125; &lt;/SubMenu&gt; : &lt;Menu.Item path=&#123;val.path&#125; key=&#123;key&#125; component=&#123;val.component&#125;&gt; &#123;val.icon &amp;&amp; &lt;Icon type=&#123;`$&#123;val.icon&#125;`&#125;/&gt;&#125; &lt;span&gt; &#123;val.text&#125; &lt;/span&gt; &lt;/Menu.Item&gt;; &#125; &#125;).filter(val =&gt; val !== undefined); &#125; render() &#123; return ( &lt;div&gt; &lt;div className='logo'&gt;&lt;/div&gt; &lt;Menu theme=\"dark\" mode=\"inline\" onClick=&#123;this.onMenuClick&#125; style=&#123;&#123;margin: '16px 0', width: '100%'&#125;&#125; &gt; &#123;this.createMenu(this.context.store.menuList)&#125; &lt;/Menu&gt; &lt;/div&gt; ); &#125;&#125;export default GYSider; 接入 store 装饰函数 connectStore.js123456789101112import PropTypes from 'prop-types';export default function connectStore(Component) &#123; if (!Component || typeof Component !== 'function') &#123; console.error(`$&#123;Component &amp;&amp; Component.name&#125; is not a class`); return; &#125; Component.contextTypes = &#123; store: PropTypes.object, onClickAction: PropTypes.func &#125;;&#125; 使用示例1234567891011121314151617181920212223242526272829303132333435363738import React, &#123;Component&#125; from 'react';import 上面的入口组建 Appimport UMD from './UMD';class WrapView extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; let initialState = &#123; menuList: [ &#123; path: 'umd', //对应的地址栏 url icon: 'setting', //侧边栏的显示图标 text: 'umd', //侧边栏的显示文字 component: UMD //点击时对应的右侧内容区组件 &#125; ] &#125;; return ( &lt;App initialState=&#123;initialState&#125;/&gt; ); &#125;&#125;export default WrapView;···import React from 'react';import &#123;render&#125; from 'react-dom';import WrapView from './app/components/WrapView';/** * Main App View */render(&lt;WrapView /&gt;, document.getElementById('app')); 核心思路是通过 context 达到类似于 redux 管理数据的目的，App.js 提供 store（存储数据） 和 onClickAction（修改 store）给子组件，子组件通过 connectStore 装饰函数获取到 store 和 onClickAction，点击侧边栏的时候，先取到设置的 path 和 component，然后通过 onCLickAction 设置 currentComponent 和 currentPath，然后 setState 即可实现需求。目前还有一个问题，就是刷新浏览器的时候如何跳转到相应的页面呢？可以在 App.js 里面先获取到所有的 component 和 path 然后保存起来： 1234567891011121314/*** 保存所有的路由对应的组件*/getAllComponent = (menuList = []) =&gt; &#123; this.allComponent = this.allComponent || new Map(); menuList.forEach(val =&gt; &#123; if (val.path &amp;&amp; Util.isReactComponent(val.component)) &#123; this.allComponent.set(val.path, val.component); &#125; if (Util.isArray(val.children)) &#123; this.getAllComponent(val.children); &#125; &#125;);&#125; 再在 App.js 通过以下代码跳转： 12345678910componentWillMount() &#123; // 刷新浏览器，跳转到相应页面 const currentPath = this.state.currentPath; const documentHref = this.props.router.currentUrl(); if (currentPath !== documentHref &amp;&amp; this.allComponent.has(documentHref)) &#123; this.setState(&#123; currentComponent: this.allComponent.get(documentHref) &#125;); &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.liangxinwei.cn/categories/前端/"}],"tags":[]},{"title":"fatal: Could not read from remote repository.的解决办法","slug":"fatal-Could-not-read-from-remote-repository-的解决办法","date":"2017-07-28T11:01:01.000Z","updated":"2020-04-22T02:18:01.802Z","comments":true,"path":"2017/07/28/fatal-Could-not-read-from-remote-repository-的解决办法/","link":"","permalink":"https://www.liangxinwei.cn/2017/07/28/fatal-Could-not-read-from-remote-repository-的解决办法/","excerpt":"","text":"查看远端地址 git remote –v查看配置 git config --list 1234git add . // 暂存所有的更改git checkout . // 丢弃所有的更改git status // 查看文件状态git commit -m &quot;本次要提交的概要信息&quot; // 提交 设置远端仓库地址 git remote set-url origin 你的远端地址 git remote add origin_new 新的地址 git remote –v查看 git push origin_new master重新推送 下面是设置用户名 Git config –global user.name “用户名” git config –global user.email 邮箱地址 设置代理： git config --global https.proxy http://127.0.0.1:1080 取消设置代理：git config --global --unset https.proxy 取消git init操作时出现 rm: cannot remove ‘.git’: Is a directory是因为输入的命令是： rm -f .git解决办法：rm -rf .git 即删除整个.git目录 failed to push some refs to ‘git@github.com:***.git’ hint: Updates were rejected ···使用git push origin master的时候出现一下错误： 解决办法：git push -f origin master或者git pull下 恢复不小心删除的 git stash 文件： 123git fsck //找到dangling的对象git show id //上面列出的每一条记录的最后一个字符串，按 enter 查看具体信息git stash apply id git 回滚提交 123456//reset将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交, 让master分支向后回退了两个提交git checkout mastergit reset HEAD~2//Revert撤销一个提交的同时会创建一个新的提交, 找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。git revert HEAD~2 错误：Please enter a commit message to explain why this merge is necessary. 解决办法： （可选）按键盘字母 i 进入insert模式 （可选）修改最上面那行黄色合并信息 按键盘左上角”Esc” （退出insert模式） 输入”:wq”,按回车键即可（提交） gitignore notworking： 123git rm -r --cached .git add .git commit -m &quot;fixed untracked files&quot; git Failed to connect to www.google.com port 80: Timed out 可能是因为设置了代理： 12git config --global http.proxy //查看代理git config --global --unset http.proxy //取消代理 HTTP Basic access denied on Git： 123git config --global --unset credential.helpergit clone &apos;···&apos;login username，password rebase 和 merge 区别 1git pull --rebase origin master rebase 选项告诉 Git 把你的提交移到同步了中央仓库修改后的 master 分支的顶部。rebase 操作过程是把本地提交一次一个地迁移到更新了的中央仓库master分支之上。这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。反过来，简化了哪里引入Bug的分析，如果有必要，回滚修改也可以做到对项目影响最小。 1git pull origin master 如果没有 rebase， pull 操作仍然可以完成，但每次 pull 操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。合并玩冲突之后，git rebase --continue，Git 会继续一个一个地合并后面的提交，如其它的提交有冲突就重复这个过程。如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行git pull –rebase命令前的样子：git rebase --abort","categories":[{"name":"git","slug":"git","permalink":"https://www.liangxinwei.cn/categories/git/"}],"tags":[]},{"title":"搭建一个包含 redux、router、国际化的前端项目框架","slug":"搭建一个包含-redux、router、国际化的前端项目框架","date":"2017-06-08T10:57:41.000Z","updated":"2020-04-22T02:18:01.806Z","comments":true,"path":"2017/06/08/搭建一个包含-redux、router、国际化的前端项目框架/","link":"","permalink":"https://www.liangxinwei.cn/2017/06/08/搭建一个包含-redux、router、国际化的前端项目框架/","excerpt":"","text":"目的搭建一个交互比较多的 react 前端项目框架，数据可预测，可路由跳转，可国际化，数据操作可控制 使用的主要类库 i18next 国际化 react-i18next i18next-browser-languagedetector immutability-helper immutable 处理数据 react react-dom react-redux 管理数据 react-router 路由 react-router-redux 路由接入 store redux说明 因为 router 是异步过程，所以注入到 store 中，通过 action 跳转路由 在 react-redux 原生 action、reducer 之上封装了一层，便于分发、匹配 action、reducer 执行顺序： action -&gt; 前置拦截器（return true）-&gt; reducer（修改 store）-&gt; componentWillReceiveProps -&gt; shouldComponentUpdate（return true）-&gt; render -&gt; 后置拦截器 项目地址：https://github.com/liangxinwei/redux-ele 项目布局12345678910111213141516171819202122232425262728293031323334353637383940├── cfg webpack 配置文件│ ├── base.js webpack 配置│ ├── default.js loader，plugin│ ├── dev.js dev 环境 │ └── dist.js dist 环境├── src 源码目录│ ├── app│ │ ├── component 具体业务组件，配合 routes 目录使用│ │ ├── config store 配置│ │ │ ├── AppActionRouter.js 分发相应 type 的 action│ │ │ ├── AppReducerCreator.js 匹配相应 type 的 action 的 reducer│ │ │ ├── ConfigureStore.js 生成 store│ │ │ └── index.js 统一导出│ │ ├── i18n 国际化配置│ │ │ ├── locales 中英文配置文件│ │ │ │ ├── en 英文配置│ │ │ │ └── zh 中文配置│ │ │ ├── i18n.js i18next 配置│ │ │ └── index.js 统一导出│ │ ├── middleware 中间件│ │ │ ├── AppMiddleWare.js 前置、后置拦截器业务代码│ │ │ ├── ComponentMiddleWare.js 操作拦截器中间件│ │ │ ├── index.js 中间件统一导出│ │ │ └── LoggerMiddleWare.js 日志中间件│ │ ├── routes 路由配置│ │ │ └── index.jsx│ │ └── App.jsx app 入口│ ├── index.ejs ejs 模板文件│ └── index.jsx 挂载 react dom├── test├── .babelrc babel 配置文件├── .editorconfig 跨平台编辑器配置文件├── .eslintignore eslintignore 配置文件├── .eslintrc eslint 配置文件├── .gitignore├── package.json ├── postcss.config.js postcss 配置文件 ├── server.js 本地服务（webpack-dev-server）├── webpack.config.js webpack 配置文件入口└── README.md App.jsx 项目入口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123;Component&#125; from &apos;react&apos;;import &#123;Provider&#125; from &apos;react-redux&apos;;import &#123;I18nextProvider&#125; from &apos;react-i18next&apos;;import &#123;syncHistoryWithStore&#125; from &apos;react-router-redux&apos;;import &#123;hashHistory&#125; from &apos;react-router&apos;;import &#123;reducers&#125; from &apos;./components&apos;; //合并之后的 reducerimport &#123;default as Store&#125; from &apos;./config/ConfigureStore&apos;;import appMiddleWares from &apos;./middleware/AppMiddleWare&apos;;import &#123;i18n, locales&#125; from &apos;./i18n&apos;; //见下面 i18n 配置import routes from &apos;./routes&apos;;import &apos;./style/index.scss&apos;;/** * App View */class App extends Component &#123; constructor(props) &#123; super(props); &#125; componentWillMount() &#123; // 添加i18n语言包 for (let ns in locales[&apos;zh&apos;]) &#123; if (locales[&apos;zh&apos;].hasOwnProperty(ns)) &#123; i18n.addResourceBundle(&apos;zh&apos;, ns, locales[&apos;zh&apos;][ns]); i18n.addResourceBundle(&apos;en&apos;, ns, locales[&apos;en&apos;][ns]); &#125; &#125; &#125; render() &#123; let storeOptions = &#123;&#125;; const defaultStates = &#123;&#125;; const allReducers = Object.assign(&#123;&#125;, reducers); //此处可以并入其它模块中的 reducer const preMiddleWares = Object.assign(&#123;&#125;, appMiddleWares.preMiddleWares); //此处可以并入其它模块中的 preMiddleWares const postMiddleWares = Object.assign(&#123;&#125;, appMiddleWares.postMiddleWares); //此处可以并入其它模块中的 postMiddleWares storeOptions.initialStates = defaultStates; storeOptions.reducers = allReducers; storeOptions.preMiddleWares = preMiddleWares; storeOptions.postMiddleWares = postMiddleWares; const store = Store.configureStore(storeOptions); const history = syncHistoryWithStore(hashHistory, store); return ( &lt;Provider store=&#123;store&#125;&gt; &lt;I18nextProvider i18n=&#123;i18n&#125;&gt; &#123;routes(history)&#125; &lt;/I18nextProvider&gt; &lt;/Provider&gt; ); &#125;&#125;export default App; routes 路由配置12345678910111213141516171819import React from &apos;react&apos;;import &#123;Router, Route&#125; from &apos;react-router&apos;;import &#123; HomeView, BusinessDetail&#125; from &apos;../components&apos;;const routes = (history) =&gt; &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;HomeView&#125;/&gt; &lt;Route path=&quot;/home&quot; component=&#123;HomeView&#125;/&gt; &lt;Route path=&quot;/business/:id&quot; component=&#123;BusinessDetail&#125;/&gt; &lt;/Router&gt; );&#125;;export default routes; ConfigureStore.js 构建 Store1234567891011121314151617181920212223242526272829303132333435import &#123;applyMiddleware, compose, createStore, combineReducers&#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import &#123;hashHistory&#125; from &apos;react-router&apos;;import &#123;routerReducer, routerMiddleware&#125; from &apos;react-router-redux&apos;;import &#123;componentMiddleWare, logger&#125; from &apos;../middleware&apos;;import appReducerCreator from &apos;./AppReducerCreator&apos;;/** * store 构建器 */export function configureStore(config) &#123; // 合并之后的 preMiddleWares, postMiddleWares, reducers let &#123;initialStates, preMiddleWares, postMiddleWares, reducers&#125; = config; let allReducer = Object.assign(&#123;&#125;, reducers); let appReducer = appReducerCreator(initialStates, allReducer); const finalReducer = combineReducers(&#123;appReducer, routing: routerReducer&#125;); const allMiddleWares = [ thunk, // 异步 action componentMiddleWare(preMiddleWares, postMiddleWares), // 具体业务拦截器 routerMiddleware(hashHistory), // router 注入到 store 中 logger ]; let enhancer = compose( applyMiddleware(...allMiddleWares) ); return createStore(finalReducer, &#123;&#125;, enhancer);&#125;const Store = &#123; configureStore&#125;;export default Store; AppReducerCreator.js123456789101112131415/** * 全局 Reducer 产生器 */function appReducerCreator(wrapInitialState, allReducerMap) &#123; function appReducer(state = wrapInitialState, action) &#123; if (action &amp;&amp; action.type &amp;&amp; allReducerMap[action.type]) &#123; return allReducerMap[action.type](state, action); &#125; else &#123; return state; &#125; &#125; return appReducer;&#125;export default appReducerCreator; ComponentMiddleWare.js action 拦截器1234567891011121314151617181920212223242526/** * 操作拦截器中间件 */export function componentMiddleWare(preMiddleWares, postMiddleWares) &#123; return function (&#123;getState&#125;) &#123; return next =&gt; (action) =&gt; &#123; // 前置拦截校验函数 let preInterceptFunc = preMiddleWares ? preMiddleWares[action.type] : null; // 进行拦截校验操作 if (preInterceptFunc &amp;&amp; !preInterceptFunc.call(this, action, getState())) &#123; console.error(&apos;Invalid action for preMiddleWares intercept!!&apos;); return; &#125; // 调用 middleware 链中下一个 middleware 的 dispatch。 const returnValue = next(action); // 后置拦截函数 let postInterceptFunc = postMiddleWares ? postMiddleWares[action.type] : null; // 进行拦截校验操作 postInterceptFunc &amp;&amp; postInterceptFunc.call(this, action, getState()); return returnValue; &#125;; &#125;;&#125; LoggerMiddleWare.js123456789101112/** * 日志 MiddleWare */export function logger(&#123;getState&#125;) &#123; return next =&gt; (action) =&gt; &#123; console.info(&apos;will dispatch&apos;, action); // 调用 middleware 链中下一个 middleware 的 dispatch。 const returnValue = next(action); console.info(&apos;after dispatch&apos;, getState()); return returnValue; &#125;;&#125; AppMiddleWare.js 具体业务中间件，构建 store 时注入123456789101112131415161718192021222324/** * 前置拦截器 */let preMiddleWares = &#123; TEST: (action, state) =&gt; &#123; return true;// false 则本次 action 无效，数据不会被修改 &#125;&#125;;/** * 后置拦截器 */let postMiddleWares = &#123; TEST: (action, state) =&gt; &#123; ··· // 此处修改之后不会立即在 ui 上体现出来，因为它在 render 之后执行。且因为参数 state 为引用，所以是直接修改，可做一些提示性的操作 &#125;&#125;;let appMiddleWares = &#123; preMiddleWares, postMiddleWares&#125;;export default appMiddleWares; connectToStore.js 组件接入 store decorator1234567891011121314151617181920import &#123;bindActionCreators&#125; from &apos;redux&apos;;import &#123;connect&#125; from &apos;react-redux&apos;;import appConfig from &apos;../config&apos;;// appConfig.router 即下面的 AppActionRouter.jsconst AppActionRouter = appConfig.router;function mapStateToProps(state) &#123; return &#123; store: state.appReducer || &#123;&#125;, routerStore: (state.routing &amp;&amp; state.routing.locationBeforeTransitions) || &#123;&#125; &#125;;&#125;function mapDispatchToProps(dispatch) &#123; return bindActionCreators(AppActionRouter, dispatch);&#125;export default function connectToStore(component) &#123; return connect(mapStateToProps, mapDispatchToProps)(component);&#125; AppActionRouter.js 分发 action1234567891011121314151617181920212223import &#123;actions&#125; from &apos;../components&apos;;// action 为合并之后的所有的 action/** * app action Router */function onClickWithoutCheck(action) &#123; return action;&#125;/** * 如果外部注入 action，那么直接使用 action 的操作即可。 * 如果外部没有注入 action， 使用 dispatch 操作。 */export function onClickAction(action, props) &#123; return function (dispatch, getState) &#123; if (action.type &amp;&amp; actions.hasOwnProperty(action.type)) &#123; actions[action.type].call(this, action, dispatch, props); &#125; else &#123; dispatch(onClickWithoutCheck(action)); &#125; &#125;;&#125; acion 示例1234567let homeActions = &#123;&#125;;homeActions[&apos;TEST&apos;] = function (action, dispatch, state) &#123; dispatch(action);&#125;;export default homeActions; reducer 示例1234567891011import Immutable from &apos;immutable&apos;;let homeReducers = &#123;&#125;;homeReducers[&apos;TEST&apos;] = function (state, action) &#123; let foo = Immutable.fromJS(state); let newArr = foo.mergeDeep(Immutable.fromJS(action.content)); return newArr.toJS();&#125;;export default homeReducers; i18n 配置12345678910111213141516171819202122232425import i18next from &apos;i18next&apos;;import LanguageDetector from &apos;i18next-browser-languagedetector&apos;;const i18n = i18next .use(LanguageDetector) .init(&#123; fallbackLng: &apos;zh&apos;, // have a common namespace used around the full app ns: [&apos;common&apos;], defaultNS: &apos;common&apos;, debug: false, interpolation: &#123; escapeValue: false // not needed for react!! &#125; &#125;, (err) =&gt; &#123; if (err) &#123; console.error(&apos;i18next&apos;, err); &#125; // console.log(&apos;i18next initialized and ready to go!&apos;); &#125;);export default i18n; i18n 英文配置1234const home = &#123; title: &apos;Home Page&apos;&#125;;export default &#123;home&#125;; i18n 中文配置1234const home = &#123; title: &apos;首页&apos;&#125;;export default &#123;home&#125;; i18n 中英文统一导出123456789import zh from &apos;./zh&apos;;import en from &apos;./en&apos;;const locales = &#123; zh: zh, en: en&#125;;export default locales; 组件实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, &#123;Component&#125; from &apos;react&apos;;import &#123;translate&#125; from &apos;react-i18next&apos;;import i18n from &apos;../i18n&apos;;@translate([&apos;home&apos;], &#123;wait: true&#125;) // 使用多语言@connectToStore // 组件介入 storeclass Test extends Component &#123; constructor(props) &#123; super(props); &#125; // 路由跳转 transformRouter = () =&gt; &#123; const &#123;onClickAction&#125; = this.props; // 见下面路由 acion let gotoAction = &#123; type: &apos;GOTO&apos;, content: &apos;/home&apos; &#125;; onClickAction(gotoAction, this.props); &#125; // 发送 action changeStore = () =&gt; &#123; const &#123;onClickAction, store&#125; = this.props; let action = &#123; type: &apos;TEST&apos;, content: &#123;data: &apos;test&apos;&#125; &#125;; onClickAction(action, this.props); &#125; // 切换语言 setLanguage = () =&gt; &#123; i18n.changeLanguage(&apos;zh&apos;); // or en &#125; render() &#123; const &#123;t, store&#125; = this.props; return ( &lt;div className=&apos;app-home&apos;&gt; &lt;div className=&apos;app-header&apos;&gt; &lt;span&gt;&#123;t(&apos;title&apos;)&#125;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; content &lt;/div&gt; &lt;Footer/&gt; &lt;/div&gt; ); &#125;&#125;export default Test; 路由 acion，不需要 路由 recuder123456789import &#123;push&#125; from &apos;react-router-redux&apos;;let routerActions = &#123;&#125;;routerActions[&apos;GOTO&apos;] = function (action, dispatch, state) &#123; dispatch(push(action[&apos;content&apos;]));&#125;;export default routerActions;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.liangxinwei.cn/categories/前端/"}],"tags":[]},{"title":"一些容易被忽略的 javascript 知识点","slug":"一些容易被忽略的-javascript-知识点","date":"2017-05-10T10:55:37.000Z","updated":"2020-04-22T02:18:01.804Z","comments":true,"path":"2017/05/10/一些容易被忽略的-javascript-知识点/","link":"","permalink":"https://www.liangxinwei.cn/2017/05/10/一些容易被忽略的-javascript-知识点/","excerpt":"","text":"ReferenceError和TypeError如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常。如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 立即执行函数表达式由于函数被包含在一对 ( ) 括号内部，因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个()将函数变成表达式，第二个()执行了这个函数。 letlet 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地了所在的块作用域。使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在” 。for 循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。 提升考虑以下代码： 123a = 2;var a;console.log( a );// 2 考虑另外一段代码： 12console.log( a );// undefinedvar a = 2; 过程： 当你看到 var a = 2; 时，JavaScript 实际上会将其看成两个声明： var a; 和 a = 2; 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。第一个代码片段会以如下形式进行处理： 123var a;a = 2;console.log( a ); 其中第一部分是编译，而第二部分是执行。第二个代码片段实际是按照以下流程处理的： 123var a;console.log( a );a = 2; 这个过程就叫作提升。但是函数表达式却不会被提升。例如： 1234foo(); // 不是 ReferenceError, 而是 TypeError!var foo = function bar() &#123; // ...&#125;; 这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域） ，因此foo()不会导致 ReferenceError 。但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值） 。 foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用： 12345foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() &#123; // ...&#125;; 这个代码片段经过提升后，实际上会被理解为以下形式： 1234567var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() &#123;var bar = ...self... // ...&#125; 函数声明和变量声明都会被提升。但是是函数会首先被提升，然后才是变量。考虑以下代码： 12345678foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;; 会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式： 1234567function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;; 注意， var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了） ，因为函数声明会被提升到普通变量之前。尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。 作用域闭包定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。下面这段代码清晰地展示了闭包： 123456789function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;var baz = foo();baz(); // 2 —— 这就是闭包的效果。 bar() 显然可以被正常执行，但是它在自己定义的词法作用域以外的地方执行。看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 typeof null = “object”不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“ object ” 。 Array使用 delete 运算符可以将单元从数组中删除，单元删除后，数组的 length 属性并不会发生变化 123456var a = [ ];a[0] = 1;// 此处没有设置 a[1] 单元a[2] = 3;a[1]; // undefineda.length; // 3 上面的代码可以正常运行，但其中的 “ 空白单元 ” （ empty slot ）可能会导致出人意料的结果。另外：如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理 123var a = [ ];a[\"13\"] = 42;a.length; // 14 Number()对于 . 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。true 转换为 1 ， false 转换为 0 。 undefined 转换为 NaN ， null 转换为 0。为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null ，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换。看下面的例子： 12345678910111213141516171819202122232425262728// 无效语法：因为 . 被视为常量 42. 的一部分，所以没有. 属性访问运算符来调用 tofixed 方法42.toFixed( 3 ); // SyntaxError// 下面的语法都有效：(42).toFixed( 3 ); // \"42.000\"0.42.toFixed( 3 ); // \"0.420\"42..toFixed( 3 ); // \"42.000\"42 .toFixed(3); // \"42.000\"var a = &#123;valueOf: function()&#123; return \"42\";&#125;&#125;;var b = &#123; toString: function()&#123; return \"42\"; &#125;&#125;;var c = [4,2];c.toString = function()&#123; return this.join( \"\" ); // \"42\"&#125;;Number( a ); // 42Number( b ); // 42Number( c ); // 42Number( \"\" ); // 0Number( [] ); // 0Number( [ \"abc\" ] ); // NaN Boolean 假值 undefined,null,false,+0,-0,NaN,””。假值列表以外的值都是真值 假值对象12345var a = new Boolean( false );var b = new Number( 0 );var c = new String( \"\" );var d = Boolean( a &amp;&amp; b &amp;&amp; c );d; // true 说明 a 、 b 、 c 都为 true 虽然 JavaScript 代码中会出现假值对象，但它实际上并不属于 JavaScript 语言的范畴。浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是 “ 假值对象 ” 。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 。最常见的例子是 document.all ，它是一个类数组对象，包含了页面上的所有元素，由 DOM （而不是 JavaScript 引擎）提供给 JavaScript 程序使用。它以前曾是一个真正意义上的对象，布尔强制类型转换结果为 true ，不过现在它是一个假值对象。document.all 并不是一个标准用法，早就被废止了。 奇特的 ~ 运算符 类型转换它首先将值强制类型转换为 32 位数字，然后执行字位操作 “ 非 ” （对每一个字位进行反转）。这与 ! 很相像，不仅将值强制类型转换为布尔值 &lt; ，还对其做字位反转。对 ~ 还可以有另外一种诠释，源自早期的计算机科学和离散数学： ~ 返回 2 的补码。~x 大致等同于 -(x+1) 。~ 和 indexOf() 一起可以将结果强制类型转换（实际上仅仅是转换）为真 / 假值： 12345678910var a = \"Hello World\";~a.indexOf( \"lo\" ); // -4 &lt;-- 真值 !if (~a.indexOf( \"lo\" )) &#123; // true// 找到匹配！&#125;~a.indexOf( \"ol\" ); // 0 &lt;-- 假值 !!~a.indexOf( \"ol\" ); // trueif (!~a.indexOf( \"ol\" )) &#123; // true// 没有找到匹配！&#125; 如果 indexOf(..) 返回 -1 ， ~ 将其转换为假值 0 ，其他情况一律转换为真值。 字位截除使用 ~ 来截除数字值的小数部分，以为这和 Math.floor(..) 的效果一样，实际上并非如此。 中的第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是 ToInt32 的结果。~~ 和 !! 很相似，它只适用于 32 位数字，更重要的是它对负数的处理与 Math.floor(..) 不同。 12Math.floor( -49.6 ); // -50~~-49.6; // -49 x 能将值截除为一个 32 位整数， x | 0 也可以，而且看起来还更简洁。出于对运算符优先级的考虑，我们可能更倾向于使用 ~x 。 == 和 ===常见的误区是：“ == 检查值是否相等， === 检查值和类型是否相等 ” 。听起来蛮有道理，然而还不够准确。正确的解释是：“ == 允许在相等比较中进行强制类型转换，而 === 不允许。”两种解释的区别：根据第一种解释（不准确的版本）， === 似乎比 == 做的事情更多，因为它还要检查值的类型。第二种解释中 == 的工作量更大一些，因为如果值的类型不同还需要进行强制类型转换。有人觉得 == 会比 === 慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级（百万分之一秒）的差别而已。如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎实现上的细微差别之外，它们之间并没有什么不同。== 和 === 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。 抽象关系比较 a &lt; b分为两个部分：比较双方都是字符串（后半部分）和其他情况（前半部分）。比较双方首先调用 ToPrimitive ，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。 1234var a = [ 42 ];var b = [ \"43\" ];a &lt; b; // trueb &lt; a; // false -0 和 NaN 的相关规则在这里也适用。如果比较双方都是字符串，则按字母顺序来进行比较 123456789101112131415161718192021var a = [ \"42\" ];var b = [ \"043\" ];a &lt; b; // falsevar a = [ 4, 2 ];var b = [ 0, 4, 3 ];a &lt; b; // falsevar a = &#123; b: 42 &#125;;var b = &#123; b: 43 &#125;;a &lt; b; // ??// 结果还是 false ，因为 a 是 [object Object] ，b 也是 [object Object]，所以按照字母顺序 a &lt; b 并不成立。// 下面的例子就有些奇怪了:var a = &#123; b: 42 &#125;;var b = &#123; b: 43 &#125;;a &lt; b; // falsea == b; // falsea &gt; b; // falsea &lt;= b; // truea &gt;= b; // true 因为根据规范 a &lt;= b 被处理为 b &lt; a ，然后将结果反转。因为 b &lt; a 的结果是 false ，所以 a &lt;= b 的结果是 true。实际上 JavaScript 中 &lt;= 是 “ 不大于 ” 的意思（即 !(a &gt; b) ，处理为 !(b &lt; a) ）。同理 a &gt;= b 处理为 b &lt;= a 。 toString12345[] + &#123;&#125;; // \"[object Object]\"&#123;&#125; + []; // 0[null].toString() // \"\"[undefined].toString() // \"\"[null, undefined].toString() // \",\" 第一行代码中， {} 出现在 + 运算符表达式中，因此它被当作一个值（空对象）来处理。 [] 会被强制类型转换为 “” ，而 {} 会被强制类型转换为 “[object Object]” 。但在第二行代码中， {} 被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换为 0 。 构造函数123456var Person = function(name) &#123; this.name = name;&#125;;// 实例化一个Personvar alice = new Person('alice');// 不要这么做!Person('bob'); //=&gt; undefined 这个函数只会返回 undefined，并且执行上下文是 window(全局)对象，你无意间创建了一个全局变量 name。调用构造函数时不要丢掉 new 关键字。当使用 new 关键字来调用构造函数时，执行上下文从全局对象(window)变成一个空的 上下文，这个上下文代表了新生成的实例。因此，this 关键字指向当前创建的实例。默认情况下，如果你的构造函数中没有返回任何内容，就会返回 this——当前的上下文。 要不然就返回任意非原始类型的值。 bind 实现12345678910Function.prototype.bind = Function.prototype.bind || function (obj) &#123; var slice = [].slice, args = slice.call(arguments, 1), self = this, nop = function () &#123;&#125;, bound = function () &#123; return self.apply( this instanceof nop ? this : (obj || &#123;&#125;), args.concat(slice.call(arguments))); &#125;; nop.prototype = self.prototype; bound.prototype = new nop(); return bound; &#125;; Object.create() 实现12345Object.create = Object.create || function(o) &#123; function F() &#123;&#125;; F.prototype = o; return new F();&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.liangxinwei.cn/categories/前端/"}],"tags":[]}]}