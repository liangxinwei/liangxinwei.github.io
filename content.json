{"meta":{"title":"梁新维","subtitle":"sometimes code， sometimes design","description":null,"author":"liangxinwei","url":"https://liangxinwei.github.io","root":"/"},"pages":[{"title":"关于我","date":"2019-12-29T21:14:25.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"about/index.html","permalink":"https://liangxinwei.github.io/about/index.html","excerpt":"","text":"简介前端工程师，在向全栈工程师努力中··· 进行中的项目hotdog(移动端) 前端项目 后端项目 联系方式邮箱：liangxw6004@qq.comGitHub：https://github.com/liangxinwei个人网站：https://www.liangxinwei.cn/"},{"title":"分类","date":"2019-12-29T21:13:10.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"categories/index.html","permalink":"https://liangxinwei.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-29T21:13:46.000Z","updated":"2021-04-15T14:13:18.613Z","comments":true,"path":"tags/index.html","permalink":"https://liangxinwei.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"证券分析（第六版）","slug":"fund/证券分析（第六版）","date":"2021-04-15T21:24:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2021/04/15/fund/证券分析（第六版）/","link":"","permalink":"https://liangxinwei.github.io/2021/04/15/fund/证券分析（第六版）/","excerpt":"","text":"在便宜的投资产品稀缺的时候，价值投资者必须有耐心，放弃标准，退而求其次往往会导致灾难。虽然我们不知道好机会处于何时何地，但我们知道机会终将会出现。 价值投资者进行的是自下而上的分析，善于根据基本面逐一对证券进行评估。他们不需要等整个市场的价格都便宜下来，而是只需要20或25个不相关 联的证券一这一数量便足以分散风险。即便是在市场价位走高的形势下，价值投资者也务必要做出证券分析和业务评估，从而获得知识经验以备将来之需。因此价 值投资者们要做的，并不是小心地估算着时间，猜测近期内的盈亏，而是应采取自 下而上的方式，先筛选出价格合适的金融市场，继而出资买入，不管市场或经济的近期水平以及走向如何。只有在找不到合适的交易的情况下，他们才应持有现金。","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"金融市场与金融机构基础笔记","slug":"fund/金融市场与金融机构基础","date":"2021-03-01T21:24:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2021/03/01/fund/金融市场与金融机构基础/","link":"","permalink":"https://liangxinwei.github.io/2021/03/01/fund/金融市场与金融机构基础/","excerpt":"","text":"引论金融机构、金融中介和资产管理公司存款机构、美联储与货币政策美联储与货币创造货币政策","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"Shell笔记一","slug":"shell/shell-1","date":"2020-12-23T23:24:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/12/23/shell/shell-1/","link":"","permalink":"https://liangxinwei.github.io/2020/12/23/shell/shell-1/","excerpt":"","text":"Shell 编程基础获取脚本的参数123456# $# 代表传入函数的参数个数echo \"$# 个参数\"# 位置参数 。从参数 0 开始echo \"$1 $2\"# $@ 代表所有参数的内容echo \"$@\" 将脚本加上可执行权限： 1chmod -x ./2.sh 以 &gt; 改变标准输出： 12# 以 &lt; 改变标准输入（这条命令将会复制/tmp/a.txt 文件到/tmp/b.txt）cat &lt; /tmp/a.txt &gt; /tmp/b.txt 以 &gt;&gt; 追加文件： 1cat 2.sh &gt;&gt; 3.sh 文件描述符理解文件描述符、系统文件表和内存索引节点表 文件描述符表用户区的一部分，除非通过使用文件描述符的函数，否则程序无法对其进行访问。对进程中每个打开的文件，文件描述符表都包含一个条目。 系统文件表为系统中所有的进程共享。对每个活动的 open, 它都包含一个条目。每个系统文件表的条目都包含文件偏移量、访问模式（读、写、或读-写）以及指向它的文件 描述符表的条目计数。每个进程的文件表在系统文件表中的区域都不重合。理由是，这种安排使每个进程都有 它自己的对该文件的当前偏移量。 内存索引节点表对系统中的每个活动的文件（被某个进程打开了），内存中索引节点表都包含一个条目。几个系统文件表条目可能对应于同一个内存索引节点表（不同进程打开同一个文件）。 习惯上，标准输入（Standard Input）的文件描述符是 0，标准输出（Standard Output）是 1， 标准错误（Standard Error）是 2。这也是当我们重定向标准错误时，使用（2&gt;）的原因。 特殊文件的妙用/dev/null我们可以把/dev/null 想象为一个“黑洞”。它类似于一个只写文件。所有写入它的内容都不可读取。但是，对于命令行和脚本来说，/dev/null 却非常有用。如： 12345678910111213# 读取/tmp/b.txt 文件，但是将读取的内容输出到/dev/nullcat /tmp/b.txt &gt;/dev/null# 检索/etc 下所有包含 alloy 字符串的文件行，但是如果有错误信息，则输出到/dev/nullgrep \"alloy\" /etc/* 2&gt; /dev/null# 下面的命令不会产生任何输出# 如果 b.txt 文件存在，则读取的内容输出到/dev/null# 如果 b.txt 文件不存在，则错误的信息输出到/dev/nullcat /tmp/b.txt &gt;/dev/null 2&gt;/dev/null# 这个命令和上一条命令是等效的cat /tmp/b.txt &amp;&gt;/dev/null# 清空 messages 和 wtmp 文件中的内容，但是让文件依然存在并且不改变权限cat /dev/null &gt; /var/log/messagescat /dev/null &gt; /var/log/wtmp 如果是重定向标准输出，直接使用&gt;就可以了，或者也可以用(1&gt;)表示，而如果是重新向标准错误，则用 2&gt;。如果是标准输入呢?那就要用(0&lt;)表示。而(&amp;&gt;)则代表标准输出和标准错误。 /dev/zero类似于/dev/null，/dev/zero 也是一个伪文件，但事实上它会产生一个 null 流(二进制的 0 流，而不是 ASCII 类型)。如果你想把其他命令的输出写入/dev/zero 文件的话，那么写入的内容会消失，而且如果你想从/dev/zero 文件中读取一连串 null 的话，也非常的困难，/dev/zero 文件的主要用途就是用来创建一个指定长度，并且初始化为空的文件，这种文件一 般都用作临时交换文件。 /dev/tty/dev/tty 是一个很实用的文件。当程序打开这个文件时，UNIX/Linux 会自动将它重定向到当前所处的终端。输出到此的信息只会显示在当前工作的终端显示器上。在某些时候例如，设定了 脚本输出到/dev/null 时，而你又想在当前终端上显示一些很重要的信息，你就可以调用这个设备， 写入重要信息。这样做可以强制信息显示到终端。 1234567printf“Enter new passwd:” # 提示输入 stty–echo # 关闭自动打印输入字符的功能 read pass &lt; /dev/tty # 读取密码printf“Enter again”read pass2&lt; /dev/tty # 再读一次，以便确认 stty echo # 记得重新打开自动打印输入字符功能... 一切皆文件\\Linux 文件类型常见的有:普通文件、目录、字符设备文件、块设备文件、符号链接文件等。 普通文件我们用 ls-lh 来查看某个文件的属性，可以看到有类似-rw-r–r– ，值得注意的，它的第一个符 号是-，这样的文件在 Linux 中就是普通文件。这些文件一般是用一些相关的应用程序创建，例如 图像工具、文档工具、归档工具或 cp 工具等。这类文件的删除方式是用 rm 命令。 目录当我们在某个目录下执行命令，看到有类似 drwxr-xr-x 命令时，这样的文件就是目录，目录 在 Linux 是一个比较特殊的文件。注意，它的第一个字符是 d。创建目录可以用 mkdir 命令或 cp 命令。cp 可以把一个目录复制为另一个目录。删除目录用 rm 或 rmdir 命令。 字符设备或块设备文件如果进入/dev 目录，列一下文件，会看到类似如下的格式: 12345alloy@ubuntu:~/LinuxShell/ch2$ ls-la /dev/ttycrw-rw-rw-1 root tty 5, 0 5 月 14 16:47 /dev/ttycrw-rw-rw-1 root tty 5, 0 04-19 08:29 /dev/ttyalloy@ubuntu:~/LinuxShell/ch2$ ls-la /dev/sda1brw-rw----1 root disk 8, 1 5 月 14 11:39 /dev/sda1 看到 /dev/tty 的属性是 crw-rw-rw-。注意，前面第一个字符是 c，表示字符设备文件，如猫等串口设备。看到/dev/sda1 的属性是 brw-r—–。注意，前面的第一个字符是 b，表示块设备，如硬盘、光驱等设备。这种文件，是用 mknode 来创建，用 rm 来删除。目前，在最新的 Linux 发行版本中，一般不用自己来创建设备文件，因为这些文件是和内核是相关联的。 套接口文件当我们启动 MySQL 服务器时，会产生一个 mysql.sock 的文件。1alloy@ubuntu:~/LinuxShell/ch2$ ls-lh /var/lib/mysql/mysql.sock 注意，这个文件的属性的第一个字符是 s。我们了解一下就行了。 符号链接文件 12alloy@ubuntu:~/LinuxShell/ch2$ ls-lh setup.loglrwxrwxrwx 1 root root 11 5月14 11:39 setup.log-&gt; install.log 当我们查看文件属性时，会看到有类似 lrwxrwxrwx 的命令。注意，第一个字符是 l，这类文件是链接文件。是通过 ln-s 源文件产生新文件名。这和 Windows 操作系统中的快捷方式有点相似。 编程的基础元素字符串操作符 替换运算符 变量运算符 替换 ${varname:-word} 如果 varname 存在且非 null，则返回 varname 的值;否则，返回 word。用途:如果变量未定义，则返回默认值范例:如果 loginname 未定义，则${loginname:-ollir}的值为 ollir ${varname:=word} 如果 varname 存在且非 null，则返回 varname 的值;否则将其置为 word，然后返回其值。用途:如果变量未定义，则设置变量为默认值 word。范例:如果 loginname 未定义，则${loginname:-ollir}的值为 ollir，并且 loginname 被设 置为 ollir ${varname:?message} 如果 varname 存在且非 null，则返回 varname 的值;否则打印message，并退出当前脚 本。省如果省略 message 的话，Shell 返回 parameter null or not set。用途:用于捕捉由于变量未定义而导致的错误。范例:如果 loginname 未定义，则${loginname:”undefined!”}则显示 loginname:undefined!，然后退出 ${varname:+word} 如果 varname 存在且非 null，则返回 word;否则返回 null。用途:用于测试变量存在。范例:如果 loginname 已定义，则${loginname:+1}返回 1 模式匹配运算符 变量运算符 替换 ${varname#pattern} 如果模式匹配变量取值的开头处，则删除匹配的最短部分，并返回剩下部分。范例:${path#/*/}为 prince/desktop/long.file.name 这个范例删除了字符串开头/的部分 ${varname##pattern} 如果模式匹配变量取值的开头处，则删除匹配的最长部分，并返回剩下部分。范例:${path#/*/}为 long.file.name这个范例提取了文件路径中的文件名 ${varname%pattern} 如果模式匹配变量取值的结尾处，则删除匹配的最短部分，并返回剩下部分。范例:${path%.*}为/home/prince/desktop/long.file 这个范例去除文件路径中最后一个点号(.)之后的部分 ${varname%%pattern} 如果模式匹配变量取值的结尾处，则删除匹配的最长部分，并返回剩下部分。范例:${path%.*}为/home/prince/desktop/long 这个范例去除范例中第一个点号(.)之后的部分 ${varname/pattern/string} ${varname//pattern/string} 将 varname 中匹配模式的最长部分替换为 string。第一种格式中，只有匹配的第一部分 被替换;第二种格式中，varname 中所有匹配的部分都被替换。如果模式以#开头，则 必须匹配varname 的开头，如果模式以%开头，则必须匹配 varname 的结尾。如果 string 为空，匹配部分被删除。如果 varname 为@或*，操作被依次应用于每个位置参数 并且扩展为结果列表。范例:${path//prince/ollir}则为:/home/ollir/desktop/long.file.name 这个范例将字符串 prince 替换成 ollir ${varname//pattern/string} 例子： 12# PATH 以换行符展示echo $&#123;PATH//:/'\\n'&#125;-e # -e 选项允许 echo 将\\n 解释为一个 LINEFEED 位置变量比较多得是 $n，$#，$0，$?。如例所示： 1234567891011121314151617181920#!/bin/sh# 判断运行参数个数，如果不等于 2，显示使用“用法帮助”，其中 $0 表示就是脚本自己。# NOTE 用中括号做判断时 “[“ 后和 ”]” 前的空格是必须加的if [ $#-ne 2 ] ;then echo \"Usage: $0 string file\"; exit 1;fi# 用 grep 在 $2 文件中查找 $1 字符串grep $1 $2;# 判断前一个命令运行后的返回值(一般成功都会返回 0, 失败都会返回非 0)if [ $?-ne 0 ];then echo \"Not Found \\\"$1\\\" in $2\"; exit 1;fi# 如果没有成功则显示没找到相关信息，否则显示找到了。# 其中 \\\" 表示转义，在 \"\" 里面还需要显示 \" 号，则需要加上转义符 \\\"。echo \"found \\\"$1\\\" in $2\"; Shell 内置了一个 shift 命令，shift 命令可以“截去”参数列表最左端的一个。执行了 shift 命 令后，$1 的值将永远丢失，而$2 的旧值会被赋值给$1，依此类推。 条件测试字符串比较 操作符 如果…则为真 Str1 = str2 str1 匹配 str2 Str1 != str2 str1 不匹配 str2 Str1 &lt; str2 str1 小于 str2 Str1 &gt; str2 str1 大于 str2 -n str1 str1 为非 null(长度大于 0) -z str1 str1 为 null(长度为 0) 文件属性检查 操作符 如果…则为真 -b file file 为块设备文件 -d file file 为目录 -e file file 存在 -f file file 为一般文件 -r file file 可读 -w file file 可写 -x file file 可执行 -s file file 非空 -O file 你是 file 的所有者 file1 -nt file2 file1 比 file2 新 file1 -ot file2 file1 比 file2 旧 case语法如下： 123456789case expression inpattern1) statements;;pattern2) statements;;pattern3 | pattern4) statements;;...esac case 语句常常被用于对 单个参数有大量判断语句的情形。一个例子： 12345678910111213# 判断文件后缀，然后根据文件后缀选择不同的读取方式。case $1 in*.jpg) gqview $1;;*.txt) gvim $1;;*.avi | *.wmv) mplayer $1;;*.pdf) acroread $1;;*) echo $1: Don't know how to read this file;;esac for 循环语法如下： 1234for name [in list] # 遍历list中的所有对象do... # able to use $name，执行与$name相关的操作done 一个例子： 12345# 遍历当前目录中所有 mp3 文件，mpg123 时命令行程序，播放mp3文件for file in `find .-inamedompg123 $filedone 注意，本例中 list 上的两个反单引号(``)。执行反单引号之间的命令，引用结果作为字符串。在 for 循环中，如果 in list 被省略，则默认为 in “$@”，即命令行参数的引用列表。 while/until 循环语法如下： 123456while conditiondostatements...done# 至于 until 语句，语法几乎和 while 一样:# until condition while 语句与 until 语句唯一不同的地方在于，如何判断 condition 的退出状态。在 while 语句中，当 condtion 的退出状态为真时，循环继续运行，否则退出循环。而在 until 中，当 condition 的退出状态为真时，循环退出，否则继续执行循环体。一个例子： 12345678# 遍历 PATH 路径path=$PATH: # 将$PATH 复制到一个参数 path 中，并在末尾加上一个冒号while [ -n $path ]; # 当path不为空时dols-ld $&#123;path%%:*&#125; # 我们使用ls-ld列出显示path中的第一个目录path=$&#123;path#*:&#125; # 在这里，我们截去 path 中的第一个目录和冒号done 综合例子： 12345678910111213141516171819202122232425262728293031#!/bin/shauthor=falselist=falsefile=\"\"while [ $#-gt 0 ]docase $1 in -f) file=$2 # 将 -f 参数的下一个参数(file)获取至 file 变量 #截去下一个参数 shift ;; -l) list=true ;; -a) author=true ;; --) # 传统上，以 -- 结束选项 shift break ;; -*) echo $0: $1: unrecognized option ;; *) break # 无选项参数时，在循环中跳出 ;;esacshift # 参数偏移done 在 Shell 中，有 getopt 命令，可以简化选项处理。使用 getopt 重写： 123456789101112131415161718192021#!/bin/shauthor=falselist=falsefile=\"\"# 它的第一个参数是一个字符串，每个字符是命令的一个选项。如果参数后还需要跟其 他参数，则该字符后面接一个冒号(:)，而紧跟的参数则会放入 $OPTARG 变量中。while getopt alf: optdocase $opt in f) # 将 -f 参数的下一个参数(file)获取至 file 变量 #截去下一个参数 file=$OPTARG ;; l) list=true ;; a) author=true ;;esacdoneshift $&#123;&#123;OPTIND–1&#125;&#125; #删除选项，留下参数，变量 OPTIND 包含下一个要处理的参数的索引值。Shell 会 把它初始化为 1 可以明显看出简化了很多。首先，在 case 中对 $opt 的测试仅仅是字母，开头的 - 被去除了；然后，循环中的 shift 也被 getopt 处理了，不需要自己控制；再次，– 的 case 也不见了，getopt 自动处理；最后，针对不合法选项的处理默认下 getopt 也会显示错误信息。 正则表达式一般字符一般字符包括文字和数字字符、空白字符和 标点符号字符。一般字符匹配的就是它们自身。 转义的 meta 字符当 meta 字符无法表示自己而我们需要这些字符时，转义符号的作用就体现出来了:在字符前置一个反斜杠 ()。例如，.只表示一个点，而不是任意字符;[匹配左方括号，而\\表示反斜杠本身。如果将转义字符置于一般字符前，则转义字符会被忽略。 .(点号)字符.(点号)字符 点号字符表示“任一字符”。例如，”.hina”正则表达式匹配 china，也匹配 China，但是它也同时匹配 dhina 方括号表达式例如，[cC]hina 只匹配 china 和 China。这是最简单的方括号表达式的用法，即直接将字符列表置于方括号中。如果将^符号至于方括号的开头([^abc])，就是取反的意思。即不在方括号中出现的任意字符。例如，[^abd]hina 匹配除了 abd 三个小写字母外的任意字母，加上 hina。 星号 meta 字符的应用ab*c 正则表达式匹配如下字符串:ac，abc，abbc，abbbc…你一定看出来了，星号 meta 字符匹配零个或多 个星号前面的单个字符。注意，匹配零个或多个字符并不是任意字母，例如，ab*c 就不匹配 adc。 a.*c 当点号和星号一起用时是表示字母 a 和 c 中匹配任意长度的字符串，例如，ac, abc, adc, abbc, acccc 等。 a.c 它的含义是字母 a 和字母 c 之间匹配任意一个字母，但是只能是一个，不能多也不能少。例如，acc, abc, aac, a!c等。 区间表达式的应用ab{3}c a 字母和 c 字母之间的 b 字母重现 3 次，即，ab{3}c 正则表达式匹配 abbbc。 ab{3,}c a 字母和 c 字母之间的 b 字母重现至少 3 次，即，ab{3}c 正则表达式匹配 abbbc，abbbbc， abbbbbc… ab{3,5}c a 字母和 c 字母之间的 b 字母重现 3~5 次，即，ab{3}c 正则表达式匹配 abbbc，abbbbc， abbbbbc。 ab?c 只匹配两种：ac 和 abc。 ab+c 匹配 abc，abbc，abbbc。。。但不匹配 ac。 ^abc 匹配字符串开头的 3 个字母 abc，例如，abcxxxABCabcxxxefg。 efg$ 匹配结尾处的 efg。和开头一样，$符号锚定了字符串的结尾，即 abcxxxABCabcxxxefg。 如果将字符^和$一起使用，则两者之间的正则表达式就匹配了整个或整行正则表达式。有时 我们使用^$来匹配空的字符串或者空行。","categories":[{"name":"shell","slug":"shell","permalink":"https://liangxinwei.github.io/categories/shell/"}],"tags":[]},{"title":"聪明的投资者笔记（格雷厄姆投资指南）","slug":"fund/聪明的投资者笔记","date":"2020-12-23T21:24:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/12/23/fund/聪明的投资者笔记/","link":"","permalink":"https://liangxinwei.github.io/2020/12/23/fund/聪明的投资者笔记/","excerpt":"","text":"投资普通股的原则对防御型投资者的组合策略,普通股的选择是很简单的。 下面提出应遵守的四个原则： 应该有适当的但不是过度的多样化，这徂许意味着有 最少10种和最多大约30种不同的证券。 所选择的每一个公司应该是大的、突冶的、谨慎投资 的。尽管这些修饰语是不确定的，但它们的一般意义是清楚 的。关于该点的讨论被放在本章的结尾。 每个公司应该具有一个长期的连续的红利支付的记 录{在道•琼斯工业平均指数中的所有证券满足了这个红利要求为了明确这点，我建议连续红利支付的要求至少从1940年开始。该点将简捷地把我们带进现在一般所指的“战 前”时期 联系到过去7年的平均收益，投资者应读表明他将愿意为一个证券所支付的价格的界限。我建议这个界限设置为平均收益的25倍，并且不多于最近12个月的20倍。这个限制几乎将所有最强的和最流行的公司从组合证券中去掉了。特别是,它实质上取消了在过去很多年中被投机型和机构投资者所喜爱的整个成长股目录。 术语普通股普通股是享有普通权利、承担普通义务的股份，是公司股份的最基本形式。普通股的股东对公司的管理、收益享有平等权利，根据公司经营效益分红，风险较大。在公司的经营管理和盈利及财产的分配上享有普通权利的股份，代表满足所有债权偿付要求及优先股东的收益权与求偿权要求后对企业盈利和剩余财产的索取权。它构成公司资本的基础，是股票的一种基本形式，也是发行量最大，最为重要的股票。目前在上海和深圳证券交易所中交易的股票，都是普通股。 优先股优先股是“普通股”的对称。是股份公司发行的在分配红利和剩余财产时比普通股具有优先 权的股份。优先股也是一种没有期限的有权凭证，优先股股东一般不能在中途向公司要求退股 (少数可赎回的优先股例外)。优先股的主要特征有三： 一是优先股通常预先定明股息收益率。由于优先股股息率事先固定，所以优先股的股息一般不会根据公司经营情况而增减，而且一般 也不能参与公司的分红，但优先股可以先于普通股获得股息，对公司来说，由于股息固定，它 不影响公司的利润分配。 二是优先股的权利范围小。优先股股东一般没有选举权和被选举权， 对股份公司的重大经营无投票权，但在某些情况下可以享有投票权。 如果公司股东大会需要讨论与优先股有关的索偿权，即优先股的索偿权先于普通股，而次于 债权人，优先股的优先权主要表现在两个方面： 股息领取优先权。股份公司分派股息的顺 序是优先股在前，普通股在后。股份公司不论其盈利多少，只要股东大会决定分派股息，优先 股就可按照事先确定的股息率领取股息，即使普遍减少或没有股息，优先股亦应照常分派股息。 剩余资产分配优先权。股份公司在解散、破产清算时，优先股具有公司剩余资产的分配 优先权，不过，优先股的优先分配权在债权人之后，而在普通股之前。只有还清公司债权人债 务之后，有剩余资产时，优先股才具有剩余资产的分配权。只有在优先股索偿之后，普通股才 参与分配。 成长股术语“成长股”被用于这样一种股票:其过去每股收益的增长远高于整个普通股的收益率且人们預计今宕仍会如此(一些权威人士认为，真正的成氏股应该有望在10年至少将其收益翻倍，即它们的复合年收益率增长超过7.1%沁显然，如果支付的价格不过分的话，这种类型的股票具有购买和拥有的吸引力。当然，由于成长股长期以与现在收益相联系的高价出售,并且在过去一段时间以比它们的平均收益高许多的倍数出售，因而是存在问題的。这说明在成长股中已经导人了相当重的投机因素，并在这个领域以远不是简单的方式进行了成功运怍 牛市周期通常以大量私人拥有的企业转成挂牌股份公式为特征，一个相当普遍的过程是将优先股出售给公众，经常是增加货币以满足企业膨胀的需求，为了老的拥有者的利益，也出售大约25%的普通股。因而，后者将保持大约75%的普通股并在诱人的时期将剩余部分变成现金。大多数情况下，优先股将以比普通股的开价稍高的价格转换为普通股。 债券的利息收入通常少于相应的股息收入的一半。 观察股票价格是否有低估有两个主要的来源： 确切的令人失望的结果 长期被忽视、误解或冷落 考虑到个股的特殊性，这两点都不能被依赖为成功的普通股的投资指南。 中等公司定义：他是一个比较重要的工业部门但不是领头的公司。例如他通常在有关的领域是较小的公司，但也许在不重要的行业中与领头的公司起一样的作用。除此之外，任何拥有成长股的公司通常都不被考虑为中等公司。 如果中等公司股票的一般趋势是低估，投资者通过这种趋势怎样才有希望获利呢？购买廉价的中等公司的股票，其利润因各种方法产生： 收到的股利率。 相对购买价格并最终影响价格的再投资的可观收益，在 5 ~ 7 年中，在良好的上等股票中，这些利益能积累得相当大。 牛市对廉价股票通常是最慷慨的，它将把典型的廉价股票至少提高到一个合适的水平。 即使在相对平凡的市场中，持续的价格调整过程仍在进行，此时，中等的被低估的股价也许至少升到他们典型的一般的安全水平。 许多情况下，由于令人失望的收益记录所造成的特别因素，可能因新状态的出现，或因采取新的政策，或因一个管理的机会而被修改。 投资选择的两个基本问题： 安全检验公司债券的主要方法是什么？ 构成普通股评价的主要因素是什么？ 证券选择防御性投资者将仅购买高等级的债券和各种一流的普通股，他要确定所要购买的后者价格不是太高。在确立购买品种时，他有三个选择方向： 应获得一种正确的一流正确的抽样数据，他应既包括幸运的成长性公司（该公司股票卖价特别高），也包括缺乏增长以及股价较低的公司。 排除那些卖价相对他们现在和过去平均收益太高的正群。原因是公司具有投资品质时，高价使其证券注入了太大的投机性因素。我建议一种可能的排除指标是：价格超过7年平均收益25倍或者最近12个月的收益的20倍。 是全神贯注于那些一流的证券，由于他们相对不流行，因此卖价处在重要公司市场价以下。 选择的重点是排除： 排除上市股票中明显的拙劣股 排除那些价格很高却很容易卷入投机性冒险的优先股 进攻性投资者影响资产价值的因素普通股的资产价值由以下因素决定：所有的有形资产（一般根据它们的账面价值），扣除普通股之前的所有负债和债权，按未偿还股的数量平分余额。 成长股的评估价值 = 当前（普通）收益 * （8.5 加上预期收益年增长率的 2 倍） 这个增长数应该是对下一个 7 至 10 年的预测。就成长股来说，他应该有利于建立价值的投资构成，这个价值要大致地与 20 倍与当前收益的最大建议值相一致。 满足投资价值标准的股票（1957年）： 基本规模：有超过 1000 万美元的流动资产 主要“廉价”标准：以低于净流动资产 2/3 的价格卖出普通股 低市盈率：价格不超过 1957 年收益的 8 倍 良好的分红历史：至少在以前 10 年分过红利 评估普通股的 11 条规则： 评估价值请决于对收益能力的预测,因此要选用合适的倍数,如果必要还要通过调整资产价值来决定。 收益能力一般代表对未来 7 年平均收益的预调。 上面的预测应该是在对美元数量和利润率统计分分析的基础上得出的 ,起点就是过去一些时期的真实情况 ,尤其是过去 7 至 10 年内的那些情况。 当把早些年的价格用到计算中时 ,应该作出适当的调整,以反映后来资本额所导致的变动。 倍数应该反映未来收益更长期的变化。倍数选 12 对股票的中立预测比较适当，“中立预测”也就是每股收盖年预期增长不超过 2% 。这个数字的增加或减少依赖于评估者的判断和偏爱。除了异常情况外, 最大的倍数应是 20,最小的倍数应是 8。倍数的范国应该符合一定规律,并随基本利率的变化而相反地改变。当然.能否在实际中这样做还值得怀疑,这是因为在市场中,心理因素一一很大程度上决定了倍数一一能使较高的利率更高 ,使较低的利率更低。 如果有形资产价值少于数益能力价值（收益能力倍数）,后者会由于反映了这种缺陷的一些姿意的因素而焉少。我建议的因素是:和将收益能力价值超过资产价值 2 倍的量减少 1/4（这里允许不扣除超过有形资产 100% 的额外部分)。 如果净流动资产价值超过了收益能力价值,可以让后者增大到超过最后展定价值的 50% 。 有些因素是不能控制的,如哉争收益,或战争的约束 ,或临时使用权 ,或租赁条件,或由于过去损失而获得的收入税的有限的减免。在不考虑反常条件的情况下 ,可能的收益总数或每股的损失记该是能估计到的 ,并且应该在评估价值时加入或从中扣除。 在资本化结构有很大投机性的地方 ,也就是在那些企业优先有由总量较大而不够均衡的地方.企业的总价值应首先被确定,如果企业只拥有普通股的话。这个价值应该以企业承认的主要债权经营价值为根据,然后在优先股和普通股之间进行分配（注意这个处理方法和基于优先股分解权的评估之间的区别)。如果根据前面第 8 条中所指反常条件来说需要调整,这种调整应该对企业总价值进行而不是对每股的基价进行。 只有在评知价至少超过市场价 1/3 时,它们对指导当前购买才具有明显的价值。在其他情况下 ,它们作为补充的事实可以用在分析和投资决定中,如果现价高出评估价较多，它们也可用在卖出的决定中。 无论在什么情况下,普通股的投机性越强,符合鉴定价值的实际根据就越少, 特别是成长型公司,在它们的总价值中很可能有真正的投机性成分,对此无法作出任何可靠的计算。","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"投资第一课笔记","slug":"fund/投资第一课笔记","date":"2020-12-01T18:24:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/12/01/fund/投资第一课笔记/","link":"","permalink":"https://liangxinwei.github.io/2020/12/01/fund/投资第一课笔记/","excerpt":"","text":"在交易的背后，首先我们必须认识到，股票跟其他商品一样——价值决定价格，价格围绕价值上下波动。与此同时，由于股票具备投机的属性，因此股价有可能长期偏 离其实际价值。","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"定投十年财务自由笔记","slug":"fund/定投十年财务自由笔记","date":"2020-11-12T20:24:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/11/12/fund/定投十年财务自由笔记/","link":"","permalink":"https://liangxinwei.github.io/2020/11/12/fund/定投十年财务自由笔记/","excerpt":"","text":"名词解释ROE(净资产收益率)策略加权指数基金小众、收益更好 在所有的策略指数当中，最有影响力，也是我们最常用到的，主要是如下四类:红利指数、基本面 指数、价值指数、低波动指数。 红利指数:持股收息的最优选择红利指数，是按照股息率来决定个股的权重，哪只股票的股息率越高，这只股票的权重就越大。所以 有的股票市值规模虽然小，但股息率高，可能在红利指数中的占比反而更高一些。 红利指数的优点 第一，高股息率，在熊市更有优势。红利指数的股息率越高，熊市分红后再投入的效果越出众，在熊 市里是非常不错的优势。 第二，红利指数的波动是各个指数中比较低的。能长期发放现金股息的公司，赢利能力和财务状况一 般都不错，毕竟现金股息是切切实实发放了出去，如果公司财务状况不好，是没有能力持续发放股息的。 财务状况越稳定，企业出意外的可能性就越小，股价的波动也越小。红利指数投资一篮子这样的股票，自 然也比较稳定，波动也较低。 第三，为日常生活提供分红现金流。指数基金也是有基金分红的，指数基金分红的来源是背后公司的 现金分红。而红利指数投资的是高现金分红的企业，自然也能收获很多现金分红，有的红利指数基金就会 以基金分红的形式发放给基金持有者。 缺点A股有的股票，会因为短期盈利大幅增加，而大比例分红，会影响指数长期的分 红能力。A股的上市公司中，强周期性行业经常会遇到类似的问题。会影响红利指数分红的稳定性 基本面指数基本面策略挑选股票的规则跟市值策略很不一样，这种策略不看市值大小，只看基本面好坏，谁的基 本面更好，谁占的权重就更高。目前一般从四个维度去衡量:营业收入、现金流、净资产、分红。 基本面指数相较普通的指数，最大的好处还是收益会相对更高一些。熊市里，基本面指数平均每年跑赢标普500指数大约5.8%，这是一个非常惊人的数字。牛市里，基本面 指数平均每年跑赢标普500指数大约0.7%。平均下来，基本面指数比标普500指数多出了2%~3%的年化收益 率。 市盈率=公司市值/公司盈利。 市净率=公司市值/公司净资产。 市现率=公司市值/现金流量。 股息率=现金分红/公司市值。 通常对于同一个股票品种来说，市盈率、市净率、市现率越低，股息率越高，这个品种的投资价值也 会越高。 沪深300价值指数是从沪深300指数中挑选出市盈率、市净率、市现率最低，股息率最高的100只股 票，每年定期调整。即每年会调出一部分估值较高的股票，调入一批估值较低的股票，用这种方式，带来 一些额外的超额收益。 策略加权指数基金一个最大的缺点，是资金容量的问题，它承载不了太多的资金。 举个例子，沪深300指数，有300只成份股，是按照上市公司的市值规模挑选的，规模越大的公司，在 沪深300指数中占比越高。 沪深300价值指数，只有100只成份股，是市盈率、市净率等估值比较低的股票。这100成份股容纳的资 金量肯定是小于300只成份股的。 所以策略加权指数基金，通常规模都是小于对应的市值加权指数基金的。 常见的策略加权指数有:红利指数、基本面指数、价值指数和低波动指数。 通常我们定投时，可以以优秀的宽基策略加权指数基金为主，以优秀行业指数基金为辅。例如以红 利、基本面、价值、低波动四类策略加权指数基金为主，以消费、医药、中概互联行业指数基金为辅。 宽基指数基金比较稳健，适合作为投资主力。优秀行业指数基金长期收益出色，可以提高我们的定投 收益效果。这样的思路，更适合普通投资者。我们要挑选规模合适、费率低廉、追踪误差小的指数基金。我们要挑选长期收益出色的策略加权指数基金和优秀行业指数基金。 如果一只指数基金规模较小，它清盘的概率就较大。 追踪误差第一，基金份额净值增长率与业绩比较基准收益率的差值。基金份额净值增长率，就是这段时间里，基金净值上涨了多少。业绩比较基准收益率，就是这段时间 里，指数上涨了多少。它们之间的差值，可以衡量收益上的差距。如果基金净值增长率比业绩比较基准的收益率高，差值就是正的，就说明基金的收益比指数的默认收 益好。起码，指数基金没跑输指数。 第二，基金份额净值增长率标准差与业绩比较基准收益率标准差的差值。这个指标不常用到。标准差指的是衡量基金净值追踪的拟合程度，如果标准差的差距小，就说明基金 在每个时间段的追踪情况都比较贴近于指数。 总体来说，第一个是衡量指数基金的收益是不是追得上指数，第二个则是衡量指数基金的走势是不是 贴得上指数。 从我们投资指数基金的角度来说，通常前者更重要，也就是基金净值是不是跑赢了指数基准。毕竟我 们更在乎收益率。 当然，第二个也很重要，它可以让我们看到每个时间段指数基金的净值是不是与指数比较接近。 估值指标一把手——市盈率市盈率指标也有一些缺点，如不适合用在盈利变化大的品种上，不适合强周期性品种，遇到金 融危机和经济周期的底部会失效等。 静态市盈率静态市盈率是指，市值/上一年度财报的净利润。比如说在2019年年中，我们看静态市盈率，就是用市 值/2018年财报的净利润。 滚动市盈率时效性更高的滚动市盈率是指，市值/最近四个季度财报的净利润。相对来说实效性高一些。 螺丝钉经常用的就是滚动市盈率。滚动市盈率每个季度更新一次。比如说在2019年7、8月，上市公司会更新半年报。半年报更新完成 后，上市公司如果盈利上涨，滚动市盈率就会下降。 静态市盈率和滚动市盈率都是根据已经公布的财报来计算的，是客观的估值指标。只不过时效性不 同，相对来说，滚动市盈率的时效性会更强一些。 动态市盈率预测未来的动态市盈率是指，市值/预测未来一年的净利润。动态市盈率通常是用未来一年的盈利来计 算估值，但是这个未来一年的盈利，是预测的。 未来谁也无法准确预测，所以就会有偏差。大多数时候，我们都不用动态市盈率。 席勒市盈率罗伯特·席勒(Robert Shiller)是著名的经济学家，《非理性繁荣》(Irrational Exuberance )就是他的 著作。这里的席勒市盈率，是他对市盈率的一个改良。 一般的市盈率，使用一年的净利润时会遇到一些特殊情况而产生较大波动。所以巴菲特的老师格雷厄 姆建议用多年的平均净利润来作为参考。 席勒在这个基础上，编制了席勒市盈率，也被称为CAPE。席勒市盈率使用过去10年的平均净利润作为 分母，也就是市值/过去10年平均净利润。 这种方式的市盈率的好处，是避免了某一两年特殊情况的干扰。比如说2007—2008年金融危机的时 候，美国上市公司整体盈利大幅下滑，标普500指数的静态市盈率被动上升到了上百倍。但是如果用席勒市 盈率，则避免了这种干扰，继续有效。 估值指标二把手——市净率什么是市净率？市净率是指每股股价与每股净资产的比率，也就是我们说的账面价值。 市净率的定义是:PB=P/B(其中P代表公司市值，B代表公司净资产)。 净资产，通俗来说就是资产减去负债，它代表全体股东共同享有的权益。具体的计算在上市公司的年 报中都有。 净资产这个财务指标比盈利更加稳定。而且，大多数公司的净资产都是稳定增加的，可以计算出市净 率。 相比较市盈率来说，市净率会更稳定。因为盈利是一个时间段里产生的，而净资产是积累起来的。 企业运作资产的效率:ROE说到市净率，就不得不说净资产收益率(ROE)，ROE等于净利润除以净资产。ROE越高的企业，资产运作效率越高，市净率也就越高。 如果一家企业主要靠无形资产来经营，像律师事务所、广告服务公司、互联网公司，那市净率就没有 多少参考价值了。 衡量现金分红收益率的指标——股息率股息率是指，现金分红/市值。 股息，是投资者在不减少所持有的股权资产的前提下，仍然可以直接分享企业业绩增长的最佳方式。我们买入指数基金的时候就确定了，一般来说基金越是低估，股息率越高。 分红比例是什么 说到股息率，就不得不说分红比例，也就是分红率。乍一看，股息率、分红率这两个概念很像，但实 际上是不同的。分红率，也叫作派息率、分红比例。 简单来说，股息率，是企业过去一年的现金派息额除以公司的总市值。分红率，则是企业过去一年的 现金派息额除以公司的总净利润。分红率一般是公司预先就设置好了，并且连续多年都不会改变。而股息率，则会随着股价波动:股价越低，股息率就越高。 改良后的定投指数基金的方法： 挑选长期盈利增长率良好的品种前面提到过的宽基指数基金和优秀行业指数基金基本都符合这个要求。 在估值处于低位的阶段买入 要同时满足：在自身历史估值处于低位，估值要跟自身盈利速度相匹配。 从世界范围内来看，成熟国家的股票市场，长期盈利增长率在 8% - 10%，市盈率平均值在15倍左右，这是一个可参考的区间。 估值和盈利增长速度的关系：PEG指标（市盈率数值 / 长期盈利增长速度数值）： 比如市盈率时15倍，长期盈利增长率时15%，那PEG就是1，一般合理的区间时 1～2，更多是用来帮助我们排雷用的。","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"理财不用懂太多笔记","slug":"fund/理财不用懂太多笔记","date":"2020-11-12T18:24:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/11/12/fund/理财不用懂太多笔记/","link":"","permalink":"https://liangxinwei.github.io/2020/11/12/fund/理财不用懂太多笔记/","excerpt":"","text":"货币基金的两个名词：万份收益：持有一万元货币基金当天的收益 七日年化：用之前7天的收益率加总，除以7再乘以365所得的结果，之所以是过去7日是因为货币基金或多或少的参与到证券市场，其中的普遍规律是周四的收益较高，周末的收益较少，通过7天累加可以很大程度消除这个影响。 买房参考 在看完所选的户型图纸后，记得看下楼层图或者CAD图纸 户型图注意看标识的尺寸，横平方向要大于3.1m（是最低尺寸），竖直方向要大于3.5m（最低尺寸），不要太相信样板间，他们的家具都是定做的，看起来比较好（比如尺寸） 房屋光线 靠近道路的房屋，9-11层，PM2.5略高一点，临高架桥更高 不要买一层升至二层 不要买顶层 注意小区内变电站和垃圾箱的位置 注意小区内的水系 特别注意铁路 看楼盘时故意提及竞争对手的，置业顾问会把对方的不利因素都告诉你（有许多你是发现不了的） 研究上市公司财务报表 其实我们并不需要成为顶级专家，也不需要供职于金融机构，只要储蓄率大于零，我们就可以用自己的余钱去投资理财，让资金滚动起来钱生钱 要考虑恶性通货膨胀 非流动资产是投资收益的主要来源，只有短期内用不到的资金，才能置换成股票等非流动资产，否则就是以短持长，应当尽量避免。在选择股票时，重点考虑利润和分红稳定的股票，用出租房子的租金和股票的分红去覆盖房贷月供，只要股票的投资收益大于贷款的按揭贷款的利率，那么这种搭配方法就能获得正收益。 查看货币基金的财务报表，并试着理解其中的内容。 坚持不懂的不做 股票指数型基金资本市场上有不少“地雷”和“陷阱”，即使投资能力很强也难免中招。指数有一个好处，就是它的样本量大。一个指数中所包含的股票数量，少则几十只，多则数百上千只。这些上市公司有好也有坏，最终好坏相互抵消，得到一个平均水平。 如果我们想要超越平均水平呢?其实也很简单。这里用到我们之前说的两根温度计—–PE、PB。我们统计各类指数十年以上的运行情况，看看各个阶段它们的PE、PB是多少。最好选择有十年以上历史可追溯的指数，如上证指数、深证成指、恒生指数等。我们在时间轴上把各PE、PB的值连起来，这样高点和低点就一目了然。只要选择在PE、PB处于历史低位的时候投资指数，得到的收益率自然就能超越平均水平。 综合统计国内外各大主要指数的历史情况，当PE低于10倍时处于低估区域，20倍以上则为高估区域，中间为正常区域。这一点从实行注册制的美股、港股市场看得更清楚。A股由于之前实行审核制，供应量跟不上需求，所以曾经很长时间处于高估的位置。 低估分散策略除了指数投资，我们还可以采取另一种策略来实现“傻瓜式投资”。这种策略需要我们资金量稍微多一点，40万元以上较为合适。资金太少则难以分散持股，且交易费率较高。与此同时，还需要稍微了解-点财务知识，会通过财务报表自行计算PE、PB。 我们首先通过一些财经网站或者行情软件，筛选出一篮子低PE、低PB的个股。然后逐一阅读财务报表，核算出它们的PE、PB值，剔除一些PE、PB被扭曲的情况（如非经常性损益等），并将结果记录下来@。最后，我们在各个行业中分散地选择低可在上交所网站查询行业分类信息，如表16-1：PE、低PB的个股，买入并持有。因为股价是变动的，所以我们还需要按月审查，如果出现更低估的标的，则进行换股。 股票的估值低，有可能是因为处于夕阳行业，前景不被看好；又或者是周期性行业，利润处于顶峰时期（好得不能再好，未来就只能下降了）。所以我们需要将投资标的分散到不同的行业中去。但总体来说，低估值更多是出自投资者的悲观情绪i。对于低估的股票而言，因为预期不高，所以只要业绩稍有改善，股价介就可能上涨。反观许多高估值的“成长股”，多多少少有泡沫成分，即使业绩维持高增长，只要增长幅度不如市场预期的那么高，股价也可能下跌。 基金和信托对于投资人来说，基金就是把钱交给专业财经人士打理。基金管理公司收取一定的费用，如管理费、申赎费等。扣除这些费用后，不论是赔是赚，均由基金投资人承担。公募基金品类繁多，数量比股票还多（2015年初超越）。2015年共发行了800多只基金，截至年底公募基金的总规模达到8.4万亿元（但货基占了半壁江山）。对大多数人来说，挑选一款适合自己的基金并不容易。我们普通大众能接触到的基金，被称为“公募基金”。它的特点是可以公开宣传，公开募集发行，投资门槛低，由某某基金公司发行①此外还有面向高净值人士的私募基金，特点是不能公开宣传，只能面向少数特定人群，认购门槛高（不低于100万），一般由某某资产管理公司发行。在公募基金这个大框框里，又分很多类别，我们来看一看。 投资范围基金可以投资的范围很广，除了前面提到的货币基金外，还可以是股票（股票型基金）、债券（债券型基金）、股债混合（混合型基金）、大宗商品（如石油、贵金属等）、房地产（REIs）等，甚至还有投资基金的基金（FOF）。根据最新的《公开募集证券投资基金运作管理办法》②，股票型基金投资股票的最低仓位不得低于80%，这意味着如果遭遇股市崩盘，股票型基金只能硬扛，无法将仓位降低至80%以下。同样，债券型基金投资债券的最低仓位不得低于80%。但不要因为“债券”二字就认为其“风险低”。首先，债券型基金通常用正回购等方式加杠杆买债券，短融长投，因而受到的利率风险较大;其次，债券型基金既可以配置较多的可转债（股性较重），也能够买一小部分股票。至于混合型基金，投资仓位灵活得多，不受限制。关于基金仓位要求的具体情况，可以在招募说明书中找到。根据投资范围，还可以更细致地分类，如专门投资短期债券的短融债基金，专门投资大盘蓝筹股的股票型基金等。投资人可以根据自己的需要去选择合适的基金。 申赎及交易方式基金按能否进行申赎，可分为封闭式基金和开放式基金。同时根据其是否能够在交易所买卖，又分为可交易型基金和不可交易型基金。封闭式基金在募集完毕后的“封闭期”内，不能进行申购和赎回即基金的份额总数不变。许多封闭式基金不能申赎，但可以在证券交易所买卖。由于封闭式基金不能按净值赎回，而其中的股票型基金又有仓位限制，所以当股市低迷时便少有人愿意接手（买入），交易价格相对净值出现大幅折价。2005年熊市底部，甚至出现了不少打半价的封闭式基金。封闭期结束后，一般的处理方法是转为开放式基金，或对基金清算返还资金（这个很少）。随着早期的封闭式基金陆续到期，目前市场上的封闭式基金数量很少。大部分新基金均开放申赎。开放式基金允许申赎的日期即为“开放日”，一般的证券交易日都是开放日，但有些基金也常常暂停申赎，如QD外汇额度耗尽，又如一些基金申购额太多，难以完成资产配置（之前的打新基金），具体情况留意基金的公告。 封闭式基金一般都能在交易所买卖（少量除外），但并不是所有的开放式基金都能交易，其中可交易的又称为LOF，或ETF等。此类基金可以按照净值赎回，所以其交易价格不会偏离净值太多，否则就会有套利资金介入。 场内基金与场外基金通常说的“场内”指的是上海和深圳两个交易所之内。我们除了利用炒股软件申赎和交易基金，还可以通过银行、基金公司官网，甚至淘宝、天天基金网、陆金所等其他平台进行申赎，这些申赎渠道都称为“场外”。同一只基金，既可以在场内申赎和交易，也可以在场外申赎（但不能交易）。当然也有一些基金只在场内，或只在场外。对于在场内有交易代码的基金，我们也可以进行转托管，即“场外转场内”，或“场内转场外”，将基金份额在同一个身份证下不同的账户之间进行转移。通常场外转场内更多，因为许多基金在场外的申购费率打折。此类转换的流程比较复杂，通常只用于套利。 分级基金我们在前面的章节里提到的分级A，就是分级基金的一种。分级基金简言之就是“借钱买股”“借钱买债”。分级基金分作母基金、A类子基、B类子基①三种。母基与其他基金并无二异，只是可以按比例拆分成A类子基、B类子基。其中A类子基获取固定收益，相当于借钱给B类子基，而B类子基则承担更多的盈利和亏损分级基金从2014年下半年开始发展壮大，尤以跟踪各类细分指数的被动型分级基金为多。通过分级基金，我们不仅可以投资各类指数，还可以投资于一些细分行业（行业指数），如银行、券商、环保、军工等。 招募说明书《招募说明书》就像是一本产品说明书，它收纳了基金最全面的资料，类似的还有《上市公告书》和《基金合同》。后两者如果没有时间详细阅读，可以重点关注《招募说明书》。一般的《招募说明书》都有百页以上，但其实需要关注的内容并没有那么多，我们重点关注的内容有： 基金经理介绍。这个自然不用多说，基金经理就像一只基金的导演，很大程度上决定了基金的运作水平。该部分内容会列出基金经理的学历、曾担任过哪些基金的经理，同一时间是否兼任其他基金的经理等内容。某些基金经常更换基金经理，这需要引起我们的注意。许多人冲着明星基金经理去投资的，更得密切关注这一点。 申赎时间及方式，交易方式等。如是否为开放式基金，能否在证券交易所交易等。ETF基金的申购办法略有不同，后文还将详述 封闭期及封闭期结束后处理方法。许多开放式基金在认购期结束后，会暂时封闭一段时间（一个月内）才上市交易或开放申赎以利于基金建仓。通常封闭期超过一年以上，且有固定的封闭期结束日，才称为封闭式基金。封闭期时长以及结束后的处理办法是必须关注的。封闭期结束前，封闭式基金的折价率有缩窄的趋势，因为它将转换为可按净值赎回的LOF基金，或按净值清盘返还资金等。 巨额赎回的认定及处理方式。同一时间大量基金遭遇赎回（一般认为10%以上），基金可以采取部分顺延赎回、全部顺延赎回暂停赎回等措施。 基金转换业务。许多基金公司都有基金转换业务，方便客户在同一基金公司旗下的基金之间转换，其效果就相当于赎回一只，申购另一只，只是省下了一些申赎费用。这也是基金公司防止客户流失的种方法。 拒绝或暂停申购、赎回和转换的情形及处理方式。此处列举了各种可能性，如外汇额度不够用;又或者基金资产规模过大，找不到合适的投资产品（一些基金公司的旗帜型产品，为了树立业绩榜样，可能暂停申购）等。如果出现此类情况，基金公司会单独发布公告说明。 投资策略、范围、比例等。基金的投资策略是积极进取，还是稳健保本?投资范围是债券还是股票?是稳健型的大盘蓝筹股，还是高新技术的小盘成长股?各类投资的最低及最高比例，会不会使用杠杆（各类投资比例合计超过100%）?这部分内容很重要，不同的投资去向，收益性和风险性也各不相同。 业绩比较基准。通过这部分内容，可以对基金的收益性、风险性、业绩目标有一个大致了解。例如，货基的比较基准一般是银行存款利率，所以它的净值不会每天大幅波动。再如，如果一只基金的比较基准是上证A指数收益率×80%+上证国债指数收益率×20%，那么它的收益和风险大致就像是八成股票，两成国债，当然基金经理会努力使业绩好于比较基准。 估值方法（净值）。基金会在每个交易日结束后，将基金财产的价值估算出来，除以总的基金份额数量，得到每份基金的净值。基金的申购和赎回都是以这个净值为参考进行的，所以估多估少会直接影响基金持有人的收益。这里特别注意停牌股票的估值调整办法，还有一些无交易量的证券、非上市证券等的估值办法（一般是债券）等。 收益分配方法。主要是基金分红的一些事项，是发放现金还是基金红利份额等。某些基金还规定，“如果基金投资当期出现亏损则不进行收益分配”“基金当期收益先弥补上期亏损后，方可进行当期收益分配”等。 基金费率。基金的费率包括运营类费率，如管理费、托管费、营销费、指数使用费（指数型基金）;以及交易类费率，如申购费、赎回费、转换费率等。运营类费率虽然没有直接的“收费”动作，但却是实实在在的费用，它直接在基金净值里扣除掉了。而交易类费率，只有当投资人有交易操作时才会产生。为了促销，部分渠道的申购费率还可以打折①，一折、五折的都有，此类渠道多为基金官网或其他网络平台。申购费率也可能因为申购金额的不同而设置不同的收费档位，赎回费率则可能因为持有基金的时间长短而设置不同的收费档位。基金《招募说明书》一般没写其在证券交易所的买卖佣金费率，因为它是券商收取的，各家券商会有不同，就跟股票佣金一样。一般人更关注基金的历史业绩，而较少关注基金费率。有的货基运营类费率高达0.8%以上，有的却不足0.3%，因为货基的收益率本就不高②，所以后者已经赢在了起跑线上。又比如各类股票型基金中，主动管理型基金的费率相对最高，而指数型基金费率则大致低了一半。 建仓期，指数型基金尤其注意这一点。许多新成立的基金规定了三至六个月的建仓期，在建仓期内基金的仓位不受约束，有些基金甚至因此空仓了半年。 分级基金特别注意事项。如A:B的比例数量;A、B子基是永续型还是定期转换型;定折、下折、上折的办法;A类子基的利率规则等。分级基金种类繁多，未来发行的新分级基金，还可能冒出新的 风险揭示。该部分内容详细列举了各种可能的风险。虽然很多也是“八股文”，但有必要细读一遍。 合同终止及清算。一只基金之所以遭遇清算，两种可能性最大，要么是运行不划算（亏本），要么是基金公司或基金托管人（银行）没有能力继续运营（破产倒闭或被吊销牌照），且没有同行愿意接手的。基金的招募说明书中会有基金清算的条件，例如某基金规定:基金份额持有人数量连续60个工作日达不到100人，或连续60个工作日基金资产净值低于人民币5000万元。许多投资人喜欢在熊市抄底，注意不要遇到规模过小而清盘的基金。 其他。任何你关心的内容，都可以在《招募说明书》里找到。例如定期定额投资办法（定投）等。 作为普通投资人，许多金融产品我们无法直接投资。基金拓宽了投资渠道，例如QDII可以投资港股、美股等;又如货币基金可以投资银行大宗存款。此外，一些基金还帮我们省了不少事。例如，指数型基金通过按比例持有成分股，达到跟踪指数的效果。因此我们不用一笔一笔去分散买入上百只股票（资金量小甚至做不到）。","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"螺丝钉的投资类书单","slug":"other/投资类书单","date":"2020-09-07T22:24:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/09/07/other/投资类书单/","link":"","permalink":"https://liangxinwei.github.io/2020/09/07/other/投资类书单/","excerpt":"","text":"螺丝钉推荐的经典的投资书籍 聪明的投资者 证券分析 巴菲特致股东的信 滚雪球 穷查理宝典 文明、现代化、价值投资与中国 彼得林奇的成功投资 共同基金常识 股市真规则 投资中最重要的事 机构投资的创新之路 原则 商业模式新生代、商业模式新生代（个人篇） 投资与养老 憨夺型投资者 大钱细思 非理性繁荣 助推 思考，快与慢 螺丝钉的投资类书单 指数基金投资指南 定投十年财务自由-银行螺丝钉 买基金为自己加薪 理财不用懂太多 期权期货及其他衍生产品第七版本 手把手教你读财报 一个投资家的20年 投资第一课 穷爸爸富爸爸 聪明的投资者 证券分析（投资启蒙书籍，巴菲特的老师格雷厄姆先生的著作） 巴菲特致股东的信 滚雪球 巴菲特之道 巴菲特投资案例集 穿过迷雾 穷查理宝典 彼得林奇的成功投资 战胜华尔街 伯格读共同基金 长赢投资 共同基金常识 约翰博格的投资50年 股市长线法宝 投资者的未来 约翰聂夫的成功投资 股市真规则 投资最重要的事 投资中最简单的事 股市进阶之道——一个散户的自我修养 机构投资的创新之路 新经济下的财富管理 投资估价 低风险投资之路 可转债投资魔法书 分级基金与投资策略 吴晓波推荐给年轻人的50本书第一部分 当商业开始改变世界 国富论：他发现了“看不见的手”（豆瓣 9.0） 资本论：一本为革命而生的经济学宣言（豆瓣 8.6） 新教伦理与资本主义精神：为商业编织“意义之网”（豆瓣 8.9） 就业、利息和货币通论：重新定义“看得见的手”（豆瓣 8.7） 通往奴役之路 ：他什么都不相信，除了自由（豆瓣 8.8） 自由选择 ：经济学界有个“矮巨人”（豆瓣 8.9） 经济学：“我写教科书，其他人拟定法律”（豆瓣 9.3） 创新与企业家精神：一个“旁观者”的创新（豆瓣 8.9） “竞争三部曲”：战略模型的设计大师（一）竞争战略（豆瓣 8.6） “竞争三部曲”：战略模型的设计大师（二）竞争优势（豆瓣 8.7） “竞争三部曲”：战略模型的设计大师（三）国家竞争优势（豆瓣 8.6） 乌合之众：群众是如何被发动起来的（豆瓣 8.2） 第二部分 成长的策略与秘密 追求卓越：第一本卖过千万册的商业图书（豆瓣 7.7） 基业长青：伟大的创业者都是“造钟”人（豆瓣 8.2） 营销管理：营销学最后的大师（豆瓣 9.0） 第五项修炼 ：席卷全球的学习型组织热（豆瓣 8.7） 隐形冠军 ：默默无闻的小巨人（豆瓣 7.7） 定位：“有史以来对营销影响最大的观念”（豆瓣 8.2） 创新者的窘境：管理越好的公司越容易失败（豆瓣 8.5） 长尾理论：尾巴决定商业的未来（豆瓣 7.7） 引爆流行：如何找到那个引爆点（豆瓣 8.0） 第三部分 动荡年代与潮汐的方向 萧条经济学的回归和2008年经济危机：最喜欢说“不”的经济学家（豆瓣 8.6） 非理性繁荣：大股灾烧出的超级明星（豆瓣 8.1） 政府为什么干预经济：为“守夜人”划定边界（豆瓣 8.0） 21世纪资本论：让公平重新回到辩论的中心（豆瓣 7.7） 美国大城市的死与生：家庭主妇对城市的抗议（豆瓣 8.6） 第三次浪潮：他把新世界的地图徐徐展开（豆瓣 8.4） 失控：互联网世界的“预言帝”（豆瓣 8.7） 奇点临近 ：机器什么时候战胜人类（豆瓣 7.6） 世界是平的：一组动听的全球化赞歌（豆瓣 7.6） 未来简史 ：99% 的人将成无用之人？（豆瓣 8.4） 第四部分 无法终结的历史与思想 旧制度与大革命：如何攻陷内心的巴士底狱（豆瓣 8.9） “年代四部曲”：一位欧洲共产党员的历史书写（一）革命的年代：1789～1848（豆瓣 8.5） “年代四部曲”：一位欧洲共产党员的历史书写（二）资本的年代：1848～1875（豆瓣 8.6） “年代四部曲”：一位欧洲共产党员的历史书写（三）帝国的年代：1875～1914（豆瓣 8.4） “年代四部曲”：一位欧洲共产党员的历史书写（四）极端的年代：1914～1991（豆瓣 8.7） 巨人 ：发明了“中美国”概念的英国人（豆瓣 7.1） 历史的终结与最后的人 ：一个走不出去的“福山困境”（豆瓣 8.5） 大国的兴衰：500 年视野里的美国与中国（豆瓣 8.2） 枪炮、病菌与钢铁 ：一本有趣的文明进化简史（豆瓣 8.7） 第五部分 企业家书写的传奇 影响历史的商业七巨头：为了到达顶峰，你不需要什么门票（豆瓣 7.7） 谁说大象不能跳舞？：一个做饼干的如何拯救“蓝色巨人”（豆瓣 7.8） 只有偏执狂才能生存：他穿越了死亡之谷（豆瓣 7.6） 杰克·韦尔奇自传：“全球第一CEO”养成记（豆瓣 7.8） 巴菲特致股东的信：那个种植“时间的玫瑰”的人（豆瓣 8.2） 史蒂夫·乔布斯传 ：生来只是为了改变世界（豆瓣 8.7） 活法：“敬天爱人”的日本商业哲学（豆瓣 8.1） 第六部分 谁来讲述中国事 江村经济：用脚写出来的中国模式（豆瓣 9.0） 美国与中国：费正清的眼睛（豆瓣 8.5） 大分流：如果世界结束于 1820 年（豆瓣 7.6） 万历十五年：一位少校军官的“大历史”（豆瓣 8.9） 论中国 ：一位 85 次访华的政治家（豆瓣 8.6） 当代中国经济改革：中国正在过大关（豆瓣 9.7） 中国的经济制度 ：乱发狂生的错过与得到（豆瓣 8.0） 激荡三十年：为当代中国企业立传（豆瓣 8.6）","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"买基金为自己加薪笔记","slug":"fund/买基金为自己加薪笔记","date":"2020-09-01T16:35:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/09/01/fund/买基金为自己加薪笔记/","link":"","permalink":"https://liangxinwei.github.io/2020/09/01/fund/买基金为自己加薪笔记/","excerpt":"","text":"评选基金风险的指标： 标准差：代表基金过去一段时间净值的稳定程度。数字越低，基金绩效的稳定度越高，越值得信赖。不过要切记一点，应该与同类型的基金比较。 ß 值：显示基金的波动程度。如果 &gt; 1，就代表基金风险大于整体市场；如果 &lt; 0，就代表基金风险小于整体市场。例如，为 1.05，代表大盘涨跌幅为 1%，带动基金净值涨跌为 1.05%。 夏普指数：指的是每单位风险所带来的超额收益。简单来说，如果为 0，就代表每单位风险所带来的收益和银行定存相同；如果 &gt; 0，就代表每单位风险所带来的收益优于银行定存；如果 &lt; 0，就代表每单位风险所带来的收益不如银行定存。 了解景气趋势-基本面 国内生产总值，国内生产总值常被作为衡量一国经济成果的指标，如果一个国家的经济成长率增幅递减，可以预期股市大概也不会有行情。 主要经济指标，可以预测未来6~9个月的经济活动，要观察连续3个月有无升降，如果升幅或者跌幅逐渐缩小，就代表趋势逆转。值得注意的是，当主要经济指标达到最低，或达到最高时，预测就会钝化，必须搭配其他经济指标一并观察。 美国采购经理指数，这是针对美国采购经理所作的调查，显示制造业的景气状况。当美国采购经理指数上升，代表美国对外采购金额增加，未来景气可望好转，反之则代表景气走弱。而当美国采购经理指数高于50，就代表景气扩张，低于50则是景气收缩期。 消费者物价指数，是衡量通货膨胀的重要指标。当消费者物价指数维持低位，中央银行会调低利率；消费者物价指数持续高位，中央银行则会调高利率。 美联储的态度，美联储在全球金融市场会结冻，影响了全球利率走势与资金流向，从2004年6月以来，美联储持续加息，为的就是要打击通货膨胀，美联储开会前市场的看法，乃至美联储发表的声明内容，都是重要观察指标。 消费者信心指数，其高低影响市场存货，特别是美国零售业占国内生产总值的60%，若存货居高不下，美国采购经理指数就跟着下滑。当消费者信心指数维持低于100时，代表景气低迷，若消费者信心指数持续下跌，则代表消费者对未来景气看法不乐观，消费意愿可能萎缩。不过，消费者信心指数在经济扩张期变化不大，景气低迷时，消费者信心指数对景气回升有关键影响。 工业生产与产能利用率，工业生产指数衡量主要工业的实质产出，产能利用率则是衡量厂商对设备的利用程度，当工业生产指数上升时，代表经济步调加速，但是增幅过高则可能是景气过热，投资须谨慎。至于产能利用率偏高则代表需求大于供给，厂商有调高价格的能力，提升获利，进一步提升投资意愿。 判断进出场时点-技术面 季线走向 通常当季线持续向上时，表示中长期持续看好，反之，如果季线持续往下，表示中长期有疑虑，不过，要注意的是当季线往下时，股市通常已经下跌一阵了。 KD值，用来判断实际进出场时间点。 KD值是利用周期中的最高价、最低价和收盘价来计算未来的随机值，50是强弱势的分水岭，80以上表示趋涨，20以下表示趋跌，K线代表快速动线，D线代表慢速动线，K值大于D值表示涨势，D值大于K值表示跌势。通常当K线穿越D线，产生黄金交叉时，我会加快布局；反之，若K线跌破D线、产生死亡交叉时，我会准备卖出持股。通常我会看周KD指标，再参考日KD跟月KD。原则上，只要大环境不差，低于20时我会大力买进，当K线穿越D线，产生黄金交叉后，只要还有筹码，我都还会持续买进，直到布局完成。等到KD值到达80的超涨区时，我会开始准备卖出，此时如果死亡交叉还没产生，就可以再等一下，等K线下弯时，我才会开始分批卖出，一旦出现死亡交叉，就是我出清手上持股的时候。 搭配成交量的观察。 “量先价行”是股市里的至理名言，所以除了季线和KD值外，成交量也是观察重点，通常量缩价跌时，是进场的好时点，而“量价背离”时，则要小心市场有反转向下或持续下探的危险。 基金投资 11 戒 赶流行 不论资产多寡，一律进行资产配置 崇尚品牌，只买同一家公司的基金 和基金浴血奋战，奖赏赔钱基金 惩罚让你赚钱的好基金 轻易牵手，又轻易分手 净值疑惑，对新基金莫名狂热 只买不卖 把基金当股票操作 赎回之后就让基金闲置 迷信明星基金经理人 基金投资 4 原则 勿以钱小而不存，节流为先 钱少不需要资产配置 增加自己的附加价值 随着年龄增长调整理财计划 萧老师的投资心得 清出每月可扣款金额 获得第一步，挑出好基金 决定开户方式，小钱也要省 设定停利点，持续扣款，定期检视基金收益率 达到停利点，适时买回 获利金额滚入再投资","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"定投记录表","slug":"fund/定投记录表","date":"2020-07-07T23:35:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/07/07/fund/定投记录表/","link":"","permalink":"https://liangxinwei.github.io/2020/07/07/fund/定投记录表/","excerpt":"","text":"日期 操作(买/卖) 交易品种代码 买入卖出金额 成交单价 买入卖出份额 买入卖出时的估值 2020-07-07 买 螺丝钉 4000.00 - - -","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"指数基金投资指南笔记二（开始定投）","slug":"fund/指数基金投资指南笔记二（开始定投）","date":"2020-07-06T15:15:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/07/06/fund/指数基金投资指南笔记二（开始定投）/","link":"","permalink":"https://liangxinwei.github.io/2020/07/06/fund/指数基金投资指南笔记二（开始定投）/","excerpt":"","text":"定投的策略当盈利收益率大于10%时，开始定投。当盈利收益率低于6.4%时，暂停定投。 我们使用盈利收益率来定投指数基金的策略是： 当盈利收益率大于10%时，分批投资。 盈利收益率小于10%，但大于6.4%时，坚定持有已经买入的基 金份额。 当盈利收益率小于6.4%时，分批卖出基金。（只适合于流通性比较好、盈利比较稳定的品种。国内主要是上证红利、中证红利、上 证50、基本面50、上证50AH优选、央视50、恒生指数和恒生中国企业 指数等。） 盈利收益率法 + 定投（盈利稳定增长）： 在盈利收益率大于10%的时候坚持定投。 盈利收益率小于10%，大于6.4%的时候暂停定投，继续持有; 可以定投其他盈利收益率大于10%的品种。 盈利收益率小于6.4%的时候卖出。 博格公式法 + 定投（盈利快速增长）： 在市盈率或市净率处于历史底部区域的时候坚持定投。 市盈率市净率进入正常估值，暂停定投，继续持有；可以定投其他处于底部区域的品种。 当市盈率市净率进入历史较高区域的时候卖出。 定期不定额定期不定额：盈利收益率法用盈 利收益率来估值的指数基金，它的盈利收益率越高，投资价值就越高，越值得投资。所以我们可以在盈利收益率高的时候，多投入一些。 以盈利收益率首次达到10%以上(首次达到低估标准)时的投资金 额为基准。之后每个月定投的金额，可以根据下列公式来计算: $$ 当月的定投金额 = 首次低估时的定投资金 * (\\frac{当月的盈利收益率}{首次的盈利收益率})^{n} $$ 来看个例子。假设我们从盈利收益率达到10%的时候开始定投，初 始定投的金额为每月1 000元，n为1。这样到了第二个月，我们发现盈利收益率达到12.5%了，指数基金投资价值变高了，我们应该多投入一些资金。 使用定期不定额公式来计算： $$ 当月的定投金额 = 1000 * (\\frac{12.5 %}{10 %})^{1} $$ 也就是说，这个月的定投金额为1 250元，比初始的1 000元要高一些。这样我们就做到盈利收益率越高，买入越多了。用这种定期不定额的投资方式，可以帮助我们在相对低估的时候买入更多，相应地，在估值稍高的时候则会买入更少。 定期不定额：博格公式法博格公式使用的数据是市盈率，当市盈率越小的时候，指数基金的投资价值越大；博格公式的变种使用的数据是市净率，市净率越小的时候，指数基金的投资价值越大。 所以使用博格公式进行投资时，每月定投的金额可以用以下的公式这样来计算： $$ 当月的定投金额 = 首次低估时的定投资金 * (\\frac{首次的市盈率}{当月的市盈率})^{n} $$ 所以使用博格公式的变种进行投资时，每月定投的金额可以用以下的公式这样来计算： $$ 当月的定投金额 = 首次低估时的定投资金 * (\\frac{首次的市净率}{当月的市净率})^{n} $$ 在这些公式里都有一个n，它就是定投收益的放大器，对进一步提升我们定投的收益，起着很重要的作用。所谓放大，很好理解，即 n 越大，收益会相对越高。只要普通定期定额的定投是盈利的，那么 n 就能放大我们的收益。 定投放大器n，能够放大我们的投资收益，但是对资金的需求量会随着n的增大而越来越高，而且这种增高是呈几何倍数增长的。n的数值越大，当指数基金越低估时，要求投入的资金量就越多，因此投资者要量力而行，设置适合自己的放大器，根据自己能够承 受的资金额度来设定n的取值。从我的经验来看，设置n=1，效果就已 经不错了。有条件的、资金比较多的朋友，可以设置n=2，也就足够了。 构建定投计划首先，我们可以选择自己比较熟悉的方式去投资这些指数基金，比如从银行买，用网络平台买，或是开股票账户来买等。把定投需要的账户开通好。第五章介绍过场内和场外投资指数基金的渠道和操作步骤。 其次，确定自己每月定投的时间和频率，比如，选择在发工资之后的第1个交易日进行定投。频率上，按周定投或者按月定投效果相似，选择适合自己的方式就好。 最后，计划中要把定投所遵循的定投策略，包括什么时候定投、什么时候持有、什么时候卖出，都详细地列出来，只有这样，一份完整的计划才能落实在纸面上，帮助我们在以后的执行过程中严格遵守，避免受到主观情绪的干扰。 为父母构建养老定投计划、为自己构建加薪定投计划、为子女构建教育定投计划。 每次想卖出手里的指数基金时，问问自己:手里的指数基金有没有过于昂贵?如果我卖了它，是不是因为有更好的选择？ 格雷厄姆的策略虽然简单，但是对人的心理素质要求较高。很多时候需要我们摒弃内心的心理干扰，像一个机器人一样去一丝不苟地执行计划，面对恐慌和贪婪也岿然不动。这一点很少有人能做到，这也是为什么我们需要将计划一一列出，落实在纸面上，这样才能保证自己不会被主观情绪干扰。 定期检查优化为了做好计划的优化，在定投的时候需要我们做好定投记录，方便以后进行总结和回顾。定投记录一般包括定投指数基金的日期、指数基金的品种、操作(买或卖)、指数基金的价格、估值等信息。在定投日期一栏，还可以预先把每个月定投的时间写上，这样可以提醒、督促自己按计划来坚持执行，避免受到主观情绪的影响。 计划制订好之后，要能把这个计划给别人讲明白，讲解的内容要包括什么是指数基金、指数基金有哪些优势、为什么这样制订定投计划、依据是什么等。一套知识体系，只是看完能掌握10%的内容；看完又去实践，能掌握50%的内容；能给别人讲明白，才算是基本都掌握了。另外，给别人讲述的过程中，也能够帮助我们对自己的定投计划查漏补缺。 附1： 定投计划表 梳理现金流a. 我的家庭月收入是 __ 元，家庭月开支是 __ 元。每个月剩余资金 __ 元(剩余资金=月收入-月开支)。b. 每个月的剩余资金 __ ，我打算拿出 __ % 的比例来定投 (一般50%比较合适)，也就是说，每个月我能用来定投指数基金的资金是 __ 元。 选择适合定投的指数基金通过 □公众号或者 □指数网站，查找出当前处于低估、适合定投的指数基金有 __ 只，分别是：__ 。□ 我的每月定投资金少于1 000元，可以选1只，我选择 __ ；□ 我的每月定投资金在1000 ~ 3000元或以上，可以选2~3只，我选择 __ ，每只指数基金的定投金额分别为 __ 。 构建定投计划a. 寻找适合自己的定投渠道□ 我有过经验，熟悉场内操作，可以从场内入手， 券商 __ 是，使用的股票交易软件是 __ 。□ 我是新人，刚开始接触定投，可以从场外开始入手，选择场外的定投平台是 __ 。b. 确定每月的定投日期我选择每月 __ 日作为定投日进行定投，原因是(比如这是每月发工资后的第一天)，将本月定投资金投入到低估值指数基金 上。c. 列出投资策略我的投资策略是：在指数基金低估的时候，坚持每月定投。在指数基金恢复正常估值的时候，坚定持有基金份额。到牛市指数基金高估的时候，分批卖出获利。 做好定投记录在记录定投信息的时候，主要需要记录的是：定投的时间、定投的操作（买/卖）、定投买入或卖出的品种、定投买入或卖出的总金额、成交的基金份额数量、买入或卖出的估值。可制作 定投记录表。","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"指数基金投资指南笔记一（概念及常见基金）","slug":"fund/指数基金投资指南笔记一（概念及常见基金）","date":"2020-07-06T15:14:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/07/06/fund/指数基金投资指南笔记一（概念及常见基金）/","link":"","permalink":"https://liangxinwei.github.io/2020/07/06/fund/指数基金投资指南笔记一（概念及常见基金）/","excerpt":"","text":"投资指数基金的核心：用价值投资的理念挑选出值得投资的指数基金，再用定投的方式去投资它。 价格与价值的关系、能力圈，以及安全边际： 价格与价值的关系：股票有其内在价值，股票的价格围绕其内在价值上下波动。 能力圈：要求我们对所投资的品种非常了解，能判断出它大致的内在价值是多少，而不是什么热门投资什么。 安全边际：在投资的时候，我们需要判断一下，当前股价与股票内在价值之间的关系。我们要用比价值更低的价格去买股票。 场内基金在证券交易所上市，可以有“申购赎回”和“买入卖出”两套交易体系，其中买入卖出方式需要在证券交易所中进行，是通过股票交易软件来操作的。如果基金没有在证券交易所上市，那就是场外基金，它只有“申购赎回”一种交易方式。 常见指数基金品种指数是一个选股规则，它的目的是按照某个规则挑选出一篮子股票，并反映这一篮子股票的平均价格走势。指数基金追踪指数，完全按照指数的选股规则去买入完全一样的一篮子股票。指数基金有三个独特的好处：长生不老、长期上涨、成本低。指数基金是最适合普通投资者的投资品种。 指数基金的分类 按投资的行业上区分，指数基金可以分为宽基和行业指数基金： 常见宽基指数基金（指数在挑选股票的时候，并不限制投资哪些行业）上证50、沪深300、中证500、创业 板、红利、基本面、央视50、恒生、H股、上证50AH优选、纳斯达克 100、标普500等。 常见的行业指数基金（指数在挑选股票的时候，会要求只投资 哪些行业的股票）必需消费行业的指数基金、医药行业的指数基金、可选消费行业的指数基金、养老产业的指数基金、 银行业的指数基金、证券业的指数基金、保险行业的指数基金、金融行业的指数基金、地产行业的指数基金等。 按照投资方向，基金可以分为：股票基金、债券基金、混合基金、货币基金。 按照投资理念，基金可以分为：主动型基金（基金经理来选择股票，并且决定股票的买入卖出）、被动型基金（其基金经理不参与选股，而是根据某一个既定的规则来挑选股票、买入卖出）。 按照销售渠道，基金可以分为：场内基金、场外基金。 按照募集对象，基金可以分为：公募基金、私募基金。 按照基金是否开放，基金可以分为：开放式基金，封闭式基金。 宽基指数基上证50指数 上证50指数是从上交所挑选沪市规模最大、流动性好、最具代表性的50只股票组成样本股，以综合反映沪市最具影响力的一批优质大盘企业的整体状况。这些股票基本都是关乎国计民生的大公司，一般是国家控股或在对应的行业里是数一数二的龙头公司。这种大公司也被称为蓝筹股。蓝筹这个词来自西方赌场。在西方赌场里，一般有三种颜色的筹码，其中蓝色筹码最为值钱。后来就用蓝筹股，代表规模较大、有较大影响力的公司。上证50并不是一个投资市场整体的指数，它更多的是投资大盘股。 特点： 以大盘股为主。 只有上交所的股票，没有深交所的股票。 以大盘股为主。 沪深300指数 沪深300指数(简称沪深300)是由中证指数公司开发的，从上交所 和深交所挑选规模最大、流动性最好的300只股票。它的成份股数目比 上证50多，也都是以大公司为主。沪深300指数所包括的公司，从市值规模上来说，占到国内股市全部规模的60%以上，比较有代表性，所以沪深300也被认为是国内股市最具代表性的指数。 特点： 以大盘股为主，兼顾上海和深圳上市公司。 中证500指数 将全部沪深300指数的300家公司排除，然后将最近一年日均总市值排名前300名的企业也排除，这样可以最大限度地避免选入大公司。在剩下的公司中，选择日均总市值排名前500名的企业，这就是中证500指数。中证500指数跟沪深300没有重合，是国内中型公司的代表。 特点： 以中型上市公司为主，从定位上，它与沪深300和上证50重合度很低。 创业板指数 创业板相关的指数有两个，一个是创业板综指，另一个是创业板指数。创业板综指是为了衡量创业板所有上市公司的股价平均表现而设立的，代码是399102。它包括创业板全部的500多家企业。而创业板指数是为了衡量创业板最主要的100家企业的平均表现而设立的，代码是399006。创业板指数限制了成份股的数量，只从创业板上市公司中，挑选出规模最大、流动性最好的100只股票。 特点： 创业板指数整体公司规模较小，属于以中小型公司为主的指数。并且这些公司大多盈利没有进入稳定期，所以创业板的整体盈利数字比较 低；公司开展新业务也更容易导致盈利大起大落。小公司+盈利没有进入稳定期，创业板指数相比之前介绍的指数，更容易暴涨暴跌，投资时要有心理准备。 红利指数 我们都知道股票是会发放股息的，也就是现金分红业绩比较好的公司，会每年从净利润中拿出一部分，以现金分红的形式回馈股东。这就是股票的现金分红，也叫股息。有研究表明，能实现高现金分红的股票，长期持有的平均收益率高于现金分红低的股票。这也很好理解，因为能够长期发放高现金分红，至少就能够说明企业的盈利和财务状况良好。所以我们可以通过持有几十只现金分红最高的股票，来获取更高的 收益。这就是红利指数的来源。 特点： 高股息率，在熊市更有优势。 能持续发放现金股息的公司，盈利能力和财务健康状况 好的概率越高。 提供分红现金流。 上证红利指数 最老牌的一个红利指数，也是非常出名的一个红利指数。这个指数挑选了上交所过去两年平均现金股息率最高的50只股票，指数代码为 000015。A股的第一个红利指数基金就是围绕上证红利指数开发的。 特点： 以大盘股为主。 中证红利指数 中证红利指数由中证指数公司编制，同时从上交所和深交所挑选过去两年平均现金股息率最高的股票，成份股数量扩大到100只。 深证红利指数 深证红利指数与上证红利指数对应，专门投资深交所的高现金股息率的股票，不过成份股只有40只。 红利机会指数 这是标普公司围绕A股开发的红利指数。红利机会指数在传统红利指数的基础上增加了一些筛选条件。传统的红利指数，一般只是挑选高股息率的股票，没有其他的要求。但是红利机会指数有3个要求:过去3年盈利增长必须为正；过去12 个月的净利润必须为正；每只股票权重不超过3%，单个行业不超过 33%。这样筛选出来的股票，长期分红能力会更强。另外盈利增速高也会带来更好的收益。 基本面指数 基本面覆盖了一个公司的运营的各 个方面，比如说营业收入、现金流、净资产、分红等。通过基本面来选 股，也就是说，谁的基本面更好，谁占的权重更高。目前一般从4个维度去 衡量:营业收入，现金流，净资产和分红。而基本面指数也正是从这4 个维度去挑选股票的。 中证基本面50指数 按照4个基本面指标，挑选出综合排名前50的公司。具体来说，是从上市公司过去5年的年报数据中，计算4个基本面指标。 营业收入：公司过去5年营业收入的平均值。 现金流：公司过去5年现金流的平均值。 净资产：公司在定期调整时的净资产。 分红：公司过去5年分红总额的平均值。 特点： 这种按照占总规模百分比来排名得分的方式，很明显公司规模越大，越占优势。所以基本面50指数挑选出来的，往往也是大盘股。从定位上来说，基本面50指数跟上证50指数很相似。不过因为它综合考虑了 收入、盈利、净资产等基本面因素，所以挑选股票时会考虑得更全面一些。 港股指数基金 而投资于中国香港、美国等市场的基金品种，我们把它们称为 QDII 基金。QDII的意思是合格境内机构投资者。我们可以把这种基金理解成一种“代购”。这些境外市场用的都是非人民币交易，所以可以在一定程度上抵御 人民币汇率风险。如果人民币相对美元贬值，将人民币换为美元资产可以分散这种风险。但反过来，如果人民币 相对美元升值，持有美元资产也会受到损失。这是一把双刃剑。 恒生指数 恒生指数投资的是所有在中国香港上市的公司中规模最大的50家企业。 特点： 历史悠久，成熟开放。 跟内地紧密相关，但投资者以境外投资者为主。 “老千股”导致个股投资风险巨大，普通投资者投资港股的最好方式——港股指数基金。 历史悠久，成熟开放。 H股指数 如果一家公司在内地注册，但是在香港地区上市，这样的公司就是H股了。内地公司到香港上市的有很多，从1993年青岛啤酒到香港上市至今，已经有160多家企业到香港上市。为了衡量这些公司股票的表现，恒生指数公司编制了恒生中国企业指数，也就是通常说的国企指数，简称为H股指数。 特点： 内地公司在境外的“代言人”。 与内地经济紧密相关，但仍然是以境外投资者为主。 H股与A股指数的亲密关系。 纳斯达克100指数 投资的是纳斯达克规模最大的100家大型企业。 标普500指数 标普500指数是美国影响力最大的一个股票指数，是美国传统经济的代表，定位上类似于国内的沪深300指数。不过要想入选标普500，得是一个行业排在前面的领导者。所以标普500是一个附带主观判断的蓝筹股指数，有些类似于前面提到过的由 专家选股的央视50指数。标普500指数倾向于选择行业的领导者、长期盈利更好的公司。 上证综指 上证综指是国内历史最悠久的一个指数，指数代码为000001。从这个代码也可以看出它的重要性。我们平时在新闻里听到的上证3000点、 6000点，其实说的就是这个上证综指。综指指的是综合指数，上证综指包括了上交所全部的上市公司，目的是反映上交所所有股票的走势。 行业指数基金目前必需消费行业的指数主要是以下4只： 上证消费指数：从上交所挑选必需消费行业公司。 上证消费80指数：从上交所挑选80家规模最大的必需消费行业公司。 中证消费指数：从中证800，即沪深300和中证500中挑选必需消费行业公司。 全指消费指数：从所有上市公司中挑选必需消费行业公司，覆盖范围最广。 医药行业的指数主要有以下几种: 中证医药指数：又称中证800医药指数，是从中证800指数中挑选医药行业。 中证医药100指数：挑选了100家大型医药股，每只股票买入相同的金额。 上证医药指数：只投资上交所的医药行业公司。 全指医药指数：从整个A股中挑选医药行业，它覆盖的医药公司是最全的。 细分医药指数：挑选了医药行业细分领域的主要公司。 300医药指数：挑选了沪深300指数里的医药行业公司。 500医药指数：挑选了中证500指数里的医药行业公司。 可选消费有如下几个特点： 需求比必需消费弱，有一定周期性。 受益于人口红利，特别是人均消费金额的提升。 可选消费的升级换代特性。 其他什么是联接基金？联接基金是基金公司开发的特殊品种。场内基金投资需要开股票账户，具体操作在步骤上也比较麻烦，也没有自动定投的功能。所以基金公司就开发了一个联接基金，方便从场外来投资。 联接基金是一种场外基金，通过申购赎回来交易。但它并不直接投 资股票，而是通过投资对应的场内指数基金来实现复制指数的目的，也是指数基金的一种。 很多基金公司成立ETF基金(交易型开放式指数基金)的时候，大多数也会成立对应的ETF联接基金。ETF联接基金是投资到对应的ETF基金上的，一般不会再单独收取基金管理费，因为ETF已经收取了基金管理费，若再对ETF联接基金收取费用则会导致双重收费。所以联接基金不再单独收费，整体费率跟对应的ETF基金一样。 什么是市值加权、策略加权?市值加权比较好理解，就是股票规模越大，权重越高。例如一只指数包含50只股票，总市值2万亿，其中有一只市值1 000亿，另一只800亿。那1000亿市值的股票，在这个指数中占比就是5%；而800亿的股票，在这个指数中占比就是4%。这个4%、5%就是权重，这就是市值加权。 而策略加权，则是按照别的方式来决定个股权重。例如红利指数，就是按照股息率来决定权重，哪个股票的股息率越高，这个股票的权重就越大。所以有的股票市值规模虽然小，但股息率高，可能在红利指数中占比反而更高一些。 什么是等权重指数呢?像上证50指数、沪深300指数等是市值加权的指数，也就是按照市 值规模来挑选股票，谁市值越大谁占的权重就越高。而红利指数是根据 股息率加权的指数，股息率越高所占的权重就越大。 而等权重指数则是分配给每个成份股完全相同的权重。 开始的时候每个成份股都是相同的权重，但是由于各个成份股的涨 跌幅度和速度都不同，就导致一段时间后它们的权重也不同了。所以等权重指数一般每隔一段时间会强制再平衡一次，一般是一年一次。 这种指数的好处是避免了部分股票在指数中的占比过高。有的指数中，部分成份股占比比较高，几个成份股就占据了指数40%~50%的权重，这样相当于指数的成份股被某几只股票“绑架了”，而等权重指数是最分散的一种指数，每个成份股都是均匀买入的。 不过，等权重指数也有缺点，就是流动性比较差，它的流动性取决于流动性最差的那个成份股。所以等权重指数基金的规模天生受限，主要是一些小型指数基金采用。 什么是港股通?港股通是互联互通的一部分，也是中国金融业的一次大创新。在港股通之前，境外投资者很难直接投资A股市场，内地投资者想要走出去也困难重重。港股通于2014年成立，开通港股通后，个人投资者可以很方便地投 资中国香港股票市场的股票。港股通初期以恒生指数和恒生中国企业指 数的成份股为主，因为这些指数的成份股相对可靠，遇到风险的概率较小，后期也逐渐扩展到香港中小盘股。基金公司也通过港股通，成立了很多投资中国香港股票市场的基金品种。 常见的估值指标 市盈率（公司市值/公司盈利，即 PE=P/E，其中P代表公司市值，E代表公司盈利） 市盈率背后的信息： 市盈率反映了我们愿意为获取1元的净利润付出多少代价。例如某个公司的市盈率是10，就代表我们愿意为这个公司的1元盈利付出10元。 估算市值。一个公司一年赚100亿元净利润，市盈率是10，其市值就是1000亿元。 市盈率的适用范围:流通性好、盈利稳定的品种。应用市盈率的前提 流通性好 盈利稳定 盈利收益率 盈利收益率是市盈率的变种。市盈率是用公司市值除以盈利，而盈利收益率则是用公司盈利除以公司市值。也就是盈利收益率=E/P。它所代表的意义是，假如我们把一家公司全部买下来，这家公司一年的盈利能够带给我们的收益率，就是盈利收益率。 盈利收益率也是有适用条件的，市盈率所要求的流通性好、盈利稳定，盈利收益率也同样要求。 市净率 市净率指的是每股股价与每股净资产的比率，也就是我们说的账面价值。市净率的定义是：PB=P/B(其中P代表公司市值，B代表公司净资产)。 影响市净率的因素有哪些? 企业运作资产的效率：ROE（净利润 / 净资产），ROE越高的企业，资产运作效率越高，市净率也就越高。 资产的价值稳定性。资产价值越稳定，市净率的有效性越高。 无形资产。 负债大增或亏损。 当企业的资产大多是比较容易衡量价值的有 形资产，并且是长期保值的资产时，比较适合用市净率来估值。比如 前文介绍的强周期性行业的指数基金，它们的盈利不稳定或盈利呈周期 性变化，因此市盈率和盈利收益率都无法用在它们上面，但可以用市净 率来估值。像证券、航空、航运、能源等都很适合用市净率估值。 股息率 股息，是投资者在不减少所持有的股权资产的前提下，仍然可以直接分享企业业绩增长的最佳方式。我们都知道，有的股票是会分红的。如果我们用过去一年，公司的现金分红除以公司的市值，得到的就是股息率了。股息率衡量的，就是现金分红的收益率。 股息率、分红率股息率、分红率这两个概念很像，但实际上是不同的。分红率也叫 作派息率、分红比例。 简单来说，股息率是企业过去一年的现金派息额除以公司的总市值，而分红率是企业过去一年的现金派息额除以公司的总净利润。这两 个比率，分子一样，但是分母一个是公司市值，一个是公司当年净利润。(当然细节上还有一些不同，例如分红还要扣税等，但大体上可以 这么理解。) 分红率一般是公司预先就设置好了，并且连续多年都不会有什么改变。而股息率则会随着股价波动：股价越低，股息率就越高。 股息率和盈利收益率之间有很大的关系。股息率=股息/市值，而盈利收益率=盈利/市值，分红率=股息/盈利，所以股息率=盈利收益 率*分红率。分红率往往在很长时间里都不会变。所以对同一个指数来说，往往盈利收益率高的时候，也是股息率高的时候。这就是盈利收益率与股息率之间的关系。 我们发现绝大多数指数基金，假如选择在盈利收益率高的时候开始定投，长期收益会相当不错；反之如果在盈利收益率低的时候开始定投，长期收益会很一般。 有三个因素直接影响了我们投资指数基金的收益：第一个是初始投资时刻指数基金的股息率，它影响了我们的分红收益；第二个是投资期内指数基金的市盈率变化；第三个是投资期内指数基金的盈利增长率；最后这两项影响我们的资本利得收益。 指数基金未来的年复合收益率，等于指数基金的投资初期股息率，加上指数基金每年的市盈率变化率，再加上指数基金的每年的盈利变化率。","categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"}],"tags":[]},{"title":"CSS世界笔记一：流、元素与基本尺寸","slug":"css/CSS世界笔记一：流、元素与基本尺寸","date":"2020-06-26T08:52:28.000Z","updated":"2021-04-15T14:13:18.553Z","comments":true,"path":"2020/06/26/css/CSS世界笔记一：流、元素与基本尺寸/","link":"","permalink":"https://liangxinwei.github.io/2020/06/26/css/CSS世界笔记一：流、元素与基本尺寸/","excerpt":"","text":"块级元素块级元素对应的英文是 block-level element，常见的块级元素有 &lt;div&gt;、&lt;li&gt;和&lt;table&gt; 等。需要注意是，块级元素和 display 为 block 的元素”不是一个概念。例如，&lt;li&gt;元 素默认的 display 值是 list-item，&lt;table&gt;元素默认的 display 值是 table，但是它们 均是块级元素，因为它们都符合块级元素的基本特征，也就是一个水平流上只能单独显示一 个元素，多个块级元素则换行显示。正是由于块级元素具有换行特性，因此理论上它都可以配合 clear 属性来清除浮动 带来的影响。例如: 12345.clear:after &#123; content: ''; display: table; // 也可以是 block，或者是 list-item clear: both;&#125; 深藏不露的 width:autowidth 的默认值是 auto，它至少包含了以下 4 种不同的宽度表现: 充分利用可用空间。比方说，、这些元素的宽度默认是 100%于父级容器的。 收缩与包裹。典型代表就是浮动、绝对定位、inline-block 元素或 table 元素， 英文称为 shrink-to-fit，CSS3 中的 fit-content 指的就是这种宽度表现。 收缩到最小。这个最容易出现在 table-layout 为 auto 的表格中，如下图3-4： 超出容器限制。除非有明确的 width 相关设置，否则上面 3 种情况尺寸都不会主动超过父级容器宽度的，但是存在一些特殊情况。例如，内容很长的连续的英文和数字，或者内联元素被设置了 white-space:nowrap，则表现为“恰似一江春水向东流，流到断崖也不回头”。例如，看一下下面的 CSS 代码:123456789.father &#123; width: 150px; background-color: #cd0000; white-space: nowrap;&#125;.child &#123; display: inline-block; background-color: #f0f3f9;&#125; 子元素既保持了 inline-block 元素的收缩特性，又同时让内容宽度最大，直接无视父级容器的宽度限制。这种现象后来有了专门的属性值描述，这个属性值叫作 max-content。 关于 height:100%对于 height 属性，如果父元素height 为 auto，只要子元素在文档流中，其百分比值完全就被忽略了。例如，某小白想要在页面插入一个，然后满屏显示背景图，就写了如下 CSS： 12345div &#123; width: 100%; /* 这是多余的 */ height: 100%; /* 这是无效的 */ background: #d9d9d9;&#125; 然后他发现这个高度永远是 0，哪怕其父级塞满了内容也是如此。事实上，他需要如下设置才行： 123html, body &#123; height: 100%;&#125; 并且仅仅设置也是不行的，因为此时的也没有具体的高度值： 123body &#123; /* 子元素 height:100%依旧无效 */&#125; 如何让元素支持 height:100%效果？ 设定显式的高度值 使用绝对定位。例如：1234div &#123; height: 100%; position: absolute;&#125; 此时的 height:100% 就会有计算值，即使祖先元素的 height 计算为 auto 也是如此。 需要注意的是，绝对定位元素的百分比计算和非绝对定位元素的百分比计算是有区别的，区别 在于绝对定位的宽高百分比计算是相对于 padding box 的，也就是说会把 padding 大小值计算 在内，但是，非绝对定位元素则是相对于 content box 计算的，如下示例： HTML 123456&lt;div class=\"box\"&gt; &lt;div class=\"child\"&gt;高度100px&lt;/div&gt;&lt;/div&gt;&lt;div class=\"box rel\"&gt; &lt;div class=\"child\"&gt;高度160px&lt;/div&gt;&lt;/div&gt; CSS 1234567891011121314151617.box &#123; height: 160px; padding: 30px; box-sizing: border-box; background-color: #beceeb;&#125;.child &#123; height: 100%; background: #cd0000;&#125;.rel &#123; position: relative;&#125;.rel &gt; .child &#123; width: 100%; position: absolute;&#125; 效果图 任意高度元素的展开收起动画技术很多时候，我们展 开的元素内容是动态的，换句话说高度是不固定的，因此，height 使用的值是默认的 auto， 应该都知道的 auto 是个关键字值，并非数值，正如 height:100%的 100%无法和 auto 相计 算一样，从 0px 到 auto 也是无法计算的，因此无法形成过渡或动画效果。 HTML 1234567&lt;input id=\"check\" type=\"checkbox\"&gt;&lt;p&gt;个人觉得，...&lt;/p&gt;&lt;div class=\"element\"&gt; &lt;p&gt;display:table-cell其他...&lt;/p&gt;&lt;/div&gt;&lt;label for=\"check\" class=\"check-in\"&gt;更多↓&lt;/label&gt;&lt;label for=\"check\" class=\"check-out\"&gt;收起↑&lt;/label&gt; CSS 12345678.element &#123; max-height: 0; overflow: hidden; transition: max-height .25s;&#125;:checked ~ .element &#123; max-height: 666px;&#125; 点此链接查看效果 其中展开后的 max-height 值，我们只需要设定为保证比展开内容高度大的值就可以，因为 max-height 值比 height 计算值大的时候，元素的高度就是 height 属性的计算高度，在本交互中，也就是 height:auto 时候的高度值。于是，一个高度 不定的任意元素的展开动画效果就实现了。但是，使用此方法也有一点要注意，即虽然说从适用范围讲，max-height 值越大使用场景越多，但是，如果 max-height 值太大，在收起的时候可能会有效果延迟的问题，比方说，我们展开的元素高度是 100px，而 max-height 是 1000px，动画时间 是 250ms，假设我们动画函数是线性的，则前 225ms 我们是看不到收起效果的，因为 max-height 从 1000px 到 100px 变化这段时间，元素不会有区域被隐藏，会给人动画延迟 225ms 的感觉，相信这不是你想看到的。因此，建议 max-height 使用足够安全的最小值，这样，收起时即使有延迟，也会因为时间很短，很难被用户察觉，并不会影响体验。","categories":[{"name":"css","slug":"css","permalink":"https://liangxinwei.github.io/categories/css/"}],"tags":[]},{"title":"Git 更改提交信息","slug":"git/Git 更改提交信息","date":"2020-05-26T10:01:01.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/05/26/git/Git 更改提交信息/","link":"","permalink":"https://liangxinwei.github.io/2020/05/26/git/Git 更改提交信息/","excerpt":"","text":"如果提交消息中包含不明确、不正确或敏感的信息，您可以在本地修改它，然后将含有新消息的新提交推送到 GitHub。 提交尚未推送上线 在命令行上，导航到包含要修改的提交的仓库。 键入 git commit --amend -m &quot;new commit message&quot;，然后按 Enter 键。 提交已经推送上线按上面两步操作完之后， 使用 push --force 命令强制推送经修改的旧提交1git push --force [origin] [branch] # 多个账户下如：git push github master 修改多个提交或旧提交的消息如果需要修改多个提交或旧提交的消息，您可以使用交互式变基，然后强制推送以更改提交历史记录。 在命令行上，导航到包含要修改的提交的仓库。 使用 git rebase -i HEAD~n 命令在默认文本编辑器中显示最近 n 个提交的列表。1git rebase -i HEAD~3 # 显示当前分支上最后 3 次提交的列表 此列表将类似于以下内容： 123456789101112131415161718192021pick e499d89 Delete CNAMEpick 0c39034 Better READMEpick f7fde4a Change the commit message but push the same commit.# Rebase 9fdb3bd..f7fde4a onto 9fdb3bd## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message# x, exec = run command (the rest of the line) using shell## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 在要更改的每个提交消息的前面，用 reword 替换 pick。 123pick e499d89 Delete CNAMEreword 0c39034 Better READMEreword f7fde4a Change the commit message but push the same commit. 保存并关闭提交列表文件 在每个生成的提交文件中，键入新的提交消息，保存文件，然后关闭它。 强制推送修改后的提交。 1git push --force 其他有几个命令需要注意一下： p, pick = use commit r, reword = use commit, but edit the commit message e, edit = use commit, but stop for amending s, squash = use commit, but meld into previous commit f, fixup = like “squash”, but discard this commit’s log message x, exec = run command (the rest of the line) using shell d, drop = remove commit 参考 更改提交消息 - GitHub 帮助","categories":[{"name":"git","slug":"git","permalink":"https://liangxinwei.github.io/categories/git/"}],"tags":[]},{"title":"SourceTree设置多个账户","slug":"git/SourceTree设置多个账户","date":"2020-04-26T11:42:19.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/04/26/git/SourceTree设置多个账户/","link":"","permalink":"https://liangxinwei.github.io/2020/04/26/git/SourceTree设置多个账户/","excerpt":"","text":"需求一台电脑同时登录两个账号：公司的 gitlab 账号，自己的 github 账号，提交的时候，分别提交对应的账号。 取消git全局设置12git config --global --unset user.namegit config --global --unset user.email SSH配置1、生成 gitlab id_rsa 私钥、id_rsa.pub 公钥 12cd ~/.sshssh-keygen -t rsa -C &quot;公司邮箱&quot; 2、生成 github id_rsa 私钥、id_rsa.pub 公钥 12cd ~/.sshssh-keygen -t rsa -C &quot;github邮箱&quot; # 之后会提示输入文件名，我的是 id_rsa_github.pub 3、github 添加公钥 id_rsa_github.pub（你命名的文件名） 4、添加 ssh key 123456789# 使用 -K 可以将私钥添加到钥匙串，不用每次开机后还要再次输入这条命令了ssh-add -K ~/.ssh/id_rsassh-add -K ~/.ssh/id_rsa_github# 可以在添加前使用下面命令删除所有的keyssh-add -D# 最后可以通过下面命令，查看key的设置ssh-add -l 5、设置 ssh config 文件 12cd ~/.ssh/vim config 输入以下内容： 1234567891011# gitlabHost gitlabHostName xxx.xxx.xxx（公司的 gitlab 域名，如 git.spacebox.fun）User gitIdentityFile ~/.ssh/id_rsa# githubHost githubHostName github.comUser gitIdentityFile ~/.ssh/id_rsa_github 通过如上设置，即可设置多账户。接下来，就可以愉快的玩耍啦～ 如何新建 git 项目123456mkdir project &amp;&amp; cd projectgit initgit config user.name &quot;***&quot;git config user.email &quot;***&quot;# $giturl 代表的是项目的 git clone 的 url 地址，github 即为上面设置的 Hostgit remote add github $giturl 如何克隆 git 项目12# git clone，github 即为上面设置的 Hostgit clone *** --origin github 如何设置在 SourceTree 已经存在的项目中1、打开右上角设置2、设置新的 origin3、设置 username4、点击右边的刷新，通过新的 origin 拉取/提交 参考 一个客户端设置多个github账号 - tmyam’s blog Git多账号登陆 Git - git-clone Documentation","categories":[{"name":"git","slug":"git","permalink":"https://liangxinwei.github.io/categories/git/"}],"tags":[]},{"title":"MySQL笔记（一）","slug":"mysql/MySQL笔记（一）","date":"2020-04-22T09:27:19.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/04/22/mysql/MySQL笔记（一）/","link":"","permalink":"https://liangxinwei.github.io/2020/04/22/mysql/MySQL笔记（一）/","excerpt":"","text":"引擎 InnoDB 是一个可靠的事务处理引擎，它不支持全文本搜索 MEMORY在功能等同于MyISAM，但由于数据存储在内存(不是磁盘) 中，速度很快(特别适合于临时表) MyISAM是一个性能极高的引擎，它支持全文本搜索(参见第18章)， 但不支持事务处理。 外键不能跨引擎混用引擎类型有一个大缺陷。外键(用于强制实施引用完整性)不能跨引擎，即使用一 个引擎的表不能引用具有使用不同引擎的表的外键。 使用 REGEXP：123// shop_name 是测试数据，包含 --，比如 商家--1SELECT `shop_name` FROM business WHERE `shop_name` REHEXP &apos;--1|--2&apos;;SELECT `shop_name` FROM business WHERE `shop_name` REHEXP &apos;--[0-9]&apos;; Concat() 拼接串，即把多个串连接起来形成一个较长的串Trim() 删除数据多余的空格，RTrim() 函数去掉值右边的所有空格，LTrim() 去掉串左边的空格常见的情景：报表中的名字按照name(location)的格式，而表中数据存储在两个列name和country中 1234SELECT Concat(Trim(`shop_name`), Trim(&apos; ( &apos;), Trim(`mail_type`), &apos; )&apos;) AS format_titleFROM business;// 标题--1(中通)` 但是拼接串它没有名字，它只是一个值，客户机没有办法引用它（一个未命名的列），解决办法是别名(alias)，是一个字段或值的替换名。别名用AS关键字赋予。 执行算术计算123456SELECT `shop_name`, `mail_type`， `distance`, `service_time`, `service_time` * `distance` as `total_price`FROM businessWHERE `mail_type` LIKE &apos;_通&apos;ORDER BY `distance`DESC;// 标题--9 中通 980 59 57820 常用的文本处理函数： Left() 返回串左边的字符，Right() 返回串右边的字符 Length() 返回串的长度 Locate() 找出串的一个子串 Lower() 将串转换为小写，Upper() 将串转换为大写 LTrim() 去掉串左边的空格，RTrim() 去掉串右边的空格 Soundex() 返回串的SOUNDEX值（SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法，如：Y.Lee -&gt; Y.Lie，SELECT shop_name FROM business WHERE Soundex(shop_name) = Soundex(&#39;Y.Lie&#39;)） SubString() 返回子串的字符 常用的日期处理函数 AddDate() 增加一个日期(天、周等) AddTime()增加一个时间(时、分等) CurDate()返回当前日期 CurTime()返回当前时间 Date()返回日期时间的日期部分 DateDiff()计算两个日期之差 Date_Add()高度灵活的日期运算函数 Date_Format()返回一个格式化的日期或时间串 Day()返回一个日期的天数部分 DayOfWeek()对于一个日期，返回对应的星期几 Hour()返回一个时间的小时部分 Minute()返回一个时间的分钟部分 Month()返回一个日期的月份部分 Now()返回当前日期和时间 Second()返回一个时间的秒部分 Time()返回一个日期时间的时间部分 Year()返回一个日期的年份部分 聚焦函数12345678910111213-- street 的行数SELECT COUNT(*) AS `street_count` FROM street;-- 最大值SELECT MAX(`distance`) AS max_distance,-- 最小值MIN(`distance`) AS min_distance,-- 平均值AVG(`distance`) AS avg_distance,-- 所有值的和SUM(`distance`) AS total_distance,-- 所有不同值的和（去重）SUM(DISTINCT `distance`) AS total_distance_distinctFROM business; GROUP BY GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套， 为数据分组提供更细致的控制。 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算(所以不能从个别的列取回数据)。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式(但不能是聚集函数)。如果在SELECT中使用表达式，则必须在 GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子 句中给出。 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列 中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 使用WITH ROLLUP关键字，可以得到每个分组以 及每个分组汇总级别(针对每个分组)的值12345678SELECT `mail_type`, COUNT(*) AS `num_mail_type`FROM `business`GROUP BY `mail_type`;SELECT `mail_type`, COUNT(*) AS `num_mail_type`FROM `business`GROUP BY `mail_type`WITH ROLLUP; HAVING和WHERE的差别:WHERE过滤指定的是行而不是分组。事实上，WHERE没有分组的概念。WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。 联结表12345678910// 在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。// WHERE子句作为 过滤条件，它只包含那些匹配给定条件(这里是联结条件)的行。// 没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。SELECT p.name, c.name, d.name, s.nameFROM `province` p, `city` c, `district` d, `street` sWHERE s.parent_code = d.codeAND d.parent_code = c.codeAND c.parent_code = p.codeAND p.name = &apos;山西省&apos;ORDER BY c.name; UNION操作符来组合数条SQL查询，将它们的结果组合成单个结果集。规则： UNION必须由两条或两条以上的SELECT语句组成，语句之间用关 键字UNION分隔 UNION中的每个查询必须包含相同的列、表达式或聚集函数(不过各个列不需要以相同的次序列出)。 列数据类型必须兼容:类型不必完全相同，但必须是DBMS可以隐含地转换的类型(例如，不同的数值类型或不同的日期类型)。 UNION ALL返回所有匹配行，不取消重复的行123456789// 查询 `distance` &lt; 400 ｜｜ `mail_type` IN (&apos;顺丰&apos;, &apos;圆通&apos;)SELECT `shop_name`, `distance`FROM `business`WHERE `distance` &lt; 400UNIONSELECT `shop_name`, `distance`FROM `business`WHERE `mail_type` IN (&apos;顺丰&apos;, &apos;圆通&apos;)ORDER BY `distance`; 更新表：123UPDATE `business`SET `service_time` = round(rand() * 100)WHERE `service_time` &lt; 60; 创建用户123456789101112131415SELECT * FROM mysql.user;—- `hotdog`@`%`：用户名 hotdog，% 表示允许任何ip地址，IDENTIFIEDBY 指定的口令为纯文本，MySQL 将在保存到user表之前对其进行加密。CREATE USER `hotdog`@`%` IDENTIFIED BY ‘123456’;—- 配置权限：对 hotdog 数据库有所有权限，不能访问其他数据库，GRANT 的反操作为 REVOKEGRANT ALL PRIVILEGES ON hotdog.* TO `hotdog`@`%` IDENTIFIED BY &apos;123456&apos;;—- 删除用户DROP USER `hotdog`@`localhost`;—- 配置完权限之后刷新MySQL的系统权限相关表方可生效FLUSH PRIVILEGES;—- 删除用户DROP USER `username`;—- 查看赋予用户账号的权限SHOW GRANT FOR `username`;—- 更改口令，新口令必须传递到Password()函 数进行加密。SET PASSWORD FOR `username` = Password(`new_password`) created_at字段与updated_at字段关于自动更新与自动插入时间戳123456ALTER TABLE `user` ADD COLUMN `create_at` TIMESTAMP NOT NULL;ALTER TABLE `user` ADD COLUMN `update_at` TIMESTAMP NOT NULL;—- TIMESTAMP DEFAULT CURRENT_TIMESTAMP 表示插入的时候自动获取当前时间（格式为YY-mm-dd HH:ii:ss）ALTER TABLE `user` MODIFY `create_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL;—- TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 表示更新的时候自动获取当前时间（格式为YY-mm-dd HH:ii:ss）ALTER TABLE `user` MODIFY `update_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL; 新增外键1ALTER TABLE `products` ADD CONSTRAINT `fk_orders_customs` FOREIGN KEY (vend_id) REFERENCES `vendors` (vend_id); 视图 规则和限制 与表一样，视图必须唯一命名(不能给视图取与别的视图或表相 同的名字)。 对于可以创建的视图数目没有限制。 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。 视图不能索引，也不能有关联的触发器或默认值。 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。 性能问题：因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。 一些常见应用 重用SQL语句。 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。 使用表的组成部分而不是整个表。 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 数据库维护123456// 1. 用来检查表键是否正确ANALYZE TABLE `table_name`;// 2. CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对 索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。 CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最 彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删 除的链接并进行键检验，QUICK只进行快速扫描。如下所示，CHECK TABLE发现和修复问题CHECK TABLE `table_name`;// 3. 如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能。OPTIMIZE TABLE `table_name`; 字符集123456// 查看所支持的字符集完整列表SHOW CHARACTER SET;// 查看所支持校对的完整列表SHOW COLLATION;SHOW FULL COLUMNS FROM `village`;SHOW VARIABLES LIKE &apos;%char%&apos;; 改善性能123456781. 但过一段时间后你可能需要调整内存分配、缓冲区大 小等。查看当前设置：SHOW VARIABLES;SHOW STATUS;2. 显示所有活动进程(以及它们的线程ID和执行时间)SHOW PROCESSLIST；3. KILL命令终结某个特定的进程(使用这个命令需要作为管理员登录)。4. LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。5. 索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。(索引可根据需要添加和删除。) MySQL不允许对变长列(或一个列的可变部分)进行索引 MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2) MySQL 数据类型 串数据类型 数值数据类型 日期和时间数据类型 二进制数据类型 触发器 想要某条语句（或某些语句）在事件发生时自动执行。MySQL响应以下任意语句而 自动执行的一条MySQL语句(或位于BEGIN和END语句之间的一组语 句):DELETE; NSERT; UPDATE。 只有表才支持触发器，每个表最多支持6个触发器（每条INSERT、UPDATE 和DELETE的之前和之后），单一触发器不能与多个事件或多个表关联。 1234// 触发器将在INSERT语句成功执行后执行。从 NEW.order_num 取得这个值并返回它，此触发器必须按照AFTER INSERT执行CREATE TRIGGER `new_order` AFTER INSERT ON `orders` FOR EACH ROW SELECT NEW.order_num;// 删除触发器DROP TRIGGER `new_product`; INSERT触发器（在INSERT语句执行之前或之后执行）： 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被 插入的行; 在BEFORE INSERT触发器中，NEW中的值也可以被更新(允许更改 被插入的值); 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT 执行之后包含新的自动生成值。 DELETE触发器（在DELETE语句执行之前或之后执行）： 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访 问被删除的行; OLD中的值全都是只读的，不能更新。1234567// 在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值(要被删除的订单)// 保存到一个名为archive_ orders的存档表中CREATE TRIGGER `delete_order` BEFORE DELETE ON `orders` FOR EACH ROWBEGIN INSERT INTO `archive_orders`(`order_num`, `order_date`, `cust_id`) VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);END; UPDATE触发器（在UPDATE语句执行之前或之后执行）： 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问 以前(UPDATE语句前)的值，引用一个名为NEW的虚拟表访问新更新的值; 在BEFORE UPDATE触发器中，NEW中的值可能也被更新(允许更改 将要用于UPDATE语句中的值); OLD中的值全都是只读的，不能更新。123// 保证州名缩写总是大写CREATE TRIGGER `upper_vendor` BEFORE UPDATE ON `vendors` FOR EACH ROWSET NEW.vend_state = Upper(NEW.vend_state);","categories":[{"name":"mysql","slug":"mysql","permalink":"https://liangxinwei.github.io/categories/mysql/"}],"tags":[]},{"title":"2020Flag","slug":"other/2020Flag","date":"2020-01-01T22:24:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2020/01/01/other/2020Flag/","link":"","permalink":"https://liangxinwei.github.io/2020/01/01/other/2020Flag/","excerpt":"","text":"业余项目 Icon 独立为项目（React、Vue）各一份、便于代码复用 DDL：2020-04-30 学习 TypeScript 并能有配套练习项目 DDL：2020-06-30 学习 Node.js 后台并能有配套练习项目 DDL：2020-12-31，2020-06-30 完成 70% 学习 MySQL 并能有配套练习项目 DDL：2020-12-31，2020-06-30 完成 70% 阅读技术书籍、设计书籍、产品书籍，DDL：2020-12-31 一个月一本 计算机 Node.js高级编程 CSS世界 计算机网络 软件工程 Linux+Shell编程从入门到精通（第2版）（进行中） 正则指引 设计 简约至上 dont make me think 写给大家看的设计书 点石成金 启示录：打造用户喜爱的产品 产品 《幕后产品》王诗沐 《有效需求分析》徐锋 理财 指数基金投资指南 定投十年财务自由-银行螺丝钉 买基金为自己加薪 理财不用懂太多 手把手教你读财报 唐朝 投资第一课（进行中） 期权期货及其他衍生产品第七版本 一个投资家的20年 其他 区块链技术指南 图解物联网 创业维艰-如何完成比难更难的事 大败局 史蒂夫·乔布斯传 史玉柱自述： 我的营销心得 参与感 创业小败局 从0到1 从为什么开始乔布斯让APPLE红遍世界的黄金圈法则 海底捞你学不会 黑客与画家 基业长青珍藏版 精益创业 美 埃里克 莱斯 商业模式新生代 商战 原则 重来_更为简单有效的商业思维 - 贾森•弗里德 卓有成效的管理者 其他 搭建自己的GitHub Pages博客 练字，达到字迹美观工整、笔力苍劲（进行中） 读一些哲学方面的书 健身，年中能有8块腹肌 学英语，单词量20000，不看字母能听懂英文电影（进行中） 学习理财相关的知识，开始钱生钱（进行中）","categories":[{"name":"随笔","slug":"随笔","permalink":"https://liangxinwei.github.io/categories/随笔/"}],"tags":[]},{"title":"2019年终总结","slug":"other/2019年终总结","date":"2019-12-31T20:15:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2019/12/31/other/2019年终总结/","link":"","permalink":"https://liangxinwei.github.io/2019/12/31/other/2019年终总结/","excerpt":"","text":"今天是2019年12月31日，眨眼间，2019年过去了。 时间总是过的很快，尤其是走出象牙塔进入社会之后，刚毕业那会怀揣着简历到处面试的情景仍然记忆犹新。 这次的年终总结算是2018年到2019年的总结，从我入职现在的公司开始到现在，与我而言，算是很有收获的2年。 工作上这应该是挑战与机遇并存的2年，之前的工作中，我一直是只负责某一部分具体的业务，入职之后，刚开始是写C端小程序、H5活动页面，然后逐步负责公司整个B端相关系统的前端方面的工作，期间遇到过困难、经历过挑战。刚接手B端系统的时候，前同事写的比较随意，代码格式各不一样，维护起来很吃力，不过还好那会业务不算很忙，总算抽出时间重构了最核心的一部分逻辑，并且将打包时间从之前的恐怖的动辄20-30min缩短到2min之内，将webpack版本性能3升级到4，为此领导特意请我喝了一周的☕️，个人感觉还是挺有成就感的一件事。 团队中也有了新鲜的血液，不同同事之间的代码风格各不一样，如何保证代码质量就成了必须要考虑的一件事，所以我们商讨了一份内部使用的 ESLint 规则，以及code review，有利于以后的维护。 公司扩张之后，相应的，业务也随之而来，期间和另一位同事（大神）配合搭建起了针对线下各个门店的视频监控系统。第一次涉足视频领域，感觉挺不错。 工作外围随着公司的扩张，随之而来的招人和带新人就成了我工作之余的另一件事，慢慢的学会了怎么样面试别人，在这里特别感谢我的领导，总是在恰当的时间的提点我，令我感觉成长了很多，获益良多。 另外，得益于用户对移动端办公的迫切需求和小程序的急速发展，公司的B端系统也同步到了小程序上，我作为唯一的开发人员、测试人员、产品人员、UI，从申请小程序到上线第一版以及之后的版本迭代，期间未出现过重大BUG，被领导称做「全干工程师」😓。这样的经历也让我对前端开发有了更深一步的认识与理解，作为最接近用户的程序员，我们应该时刻站在用户的角度思考怎么样能让所开发的产品更易用、更简洁、交互更合理、操作更简单，并且在产品上线之后主动了解用户的反馈，并针对反馈做相应的改进，然后再上线、跟踪反馈、优化，达到整个流程的闭环。这种一个人负责所有的事情对我虽然是第一次，但是开发过程中下意识的思考UI、产品，开发完的测试，上线之后的跟踪反馈，让我耳目一新，原来前端开发人员还可以这样，为此还特意买了设计相关的书籍、B端产品相关的书籍，边看书边开发，美美哒。 前端团队成长方面，我组织公司的前端同事搭建起了前端团队的自我成长体系，并付诸于行动，每周（最长不超过2周）开一次前端分享（交流）会，包括并不限于JavaScript、CSS、React、Vue、产品、设计相关，相互督促学习，并实践与公司的项目中。以目前的反馈来看，效果挺好。通过学习，我相信不只是我，团队中的任何一位同事，都会在各个方面都有所成长。 情感上今年顺利收获女朋友一枚，工作也有了更大的动力。想给她更好的生活，就得更努力赚钱，努力工作，努力学习，一直成长。 其他最近因为一些原因，公司也开始了传说中的内部优化，虽然没有波及到研发部门，但是日渐空阔的办公室还是实时提醒着我，凛冬将至，这更让我觉得提升自己的能力才是最重要的，在这里告诫大家，一定要有危机意识，居安思危。 2020年目标明天又是新的一年，在这里立几个小目标： 前端技术方面有大的突破（多阅读源码） 学习Node.js、MongoDB、MySQL，并能有相应的后台练习项目 学习产品相关的知识 学习理财相关的知识，开始钱生钱 健身，年中能有8块腹肌 练字，达到字迹美观工整、笔力苍劲 学习英语，单词量能达到20000，慢英语能听懂 最后想说现在看来，那件事（前端团队的自我成长体系）到现在才运行起来，带给我的教训：要做成一件看起来很难的事，只是缺乏立即去做的决心，和坚持下去的恒心，仅此而已。 今年对自己整体的评价：技术方面，刚及格，主要是业务太繁忙，又刚交女朋友，学习的时间太少，其他方面，比如UI意识、产品意识等等，还算是比较满意，不再仅仅是前端开发，眼界开阔了不少，业余还看了一些理财方面的书籍，打算来年继续学习。 2020年，29岁了，希望能有更好的成长。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://liangxinwei.github.io/categories/随笔/"}],"tags":[]},{"title":"B端产品经理长成读书笔记","slug":"other/B端产品经理长成读书笔记","date":"2019-09-12T22:51:34.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2019/09/12/other/B端产品经理长成读书笔记/","link":"","permalink":"https://liangxinwei.github.io/2019/09/12/other/B端产品经理长成读书笔记/","excerpt":"","text":"PMBOK：项目管理知识体系 Project Management Body Of Knowledge 产品的规则设计：1、精神理念：什么最重要2、目标：产品要达成什么目标3、谁更重要：多方冲突时保护谁4、鼓励什么：什么事再产品中会受到认可和激励5、拒绝什么：什么事不能在产品中做？禁止和惩罚什么？ 方案出错，90%是问题出错了问题-拆解-方案-结论 原则1、定义问题，2、拆解问题，3、导出方案，4、评估得出结论 更高的时间和行动成本会拉低用户对产品的需求 RFM模型RFM是最经典的客户消费行为特征分析模型，RFM代表Recency（最近一次消费时间），Frequency（某一个时间范围内的消费频次），Monetary（某一个时间范围内的平均客单价或累计交易额）。根据公司实际数据情况，将这三个指标划分成几档，可以形成多种组合（假设每个指标分五档，则可产生5x5x5个组合），对这些组合进行聚类分析，提炼出行为模式类似的多个群体，实现对客户消费特征的群体细分。 数据集市 DM Data Mart数据仓库 DW Data WarehouseBI Business Intelligence 数据仓库和大数据是两个完全不同的概念,它们在理念、技术方案、应用领域方面都完全不同,具体如下。·理念:数据仓库源于交易数据,对数据的准确性要求高,适合做离线分析;大数据源于日志的行为数据,对数据准确性要求不高,适合做自动化策略。技术方案:数据仓库采用传统的、经典的数据分析思路,即抽样、分析、预测;大数据基于海量数据和运算能力,不做抽样而做全量研究,不做分析而做模型应用。应用领域:数据仓库主要用来做企业经营分析;大数据主要用来做各种业务自动化应用。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangxinwei.github.io/categories/读书笔记/"}],"tags":[]},{"title":"九败一胜读书笔记","slug":"other/九败一胜读书笔记","date":"2019-08-19T22:02:58.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2019/08/19/other/九败一胜读书笔记/","link":"","permalink":"https://liangxinwei.github.io/2019/08/19/other/九败一胜读书笔记/","excerpt":"","text":"获取的长期经验不是最重要的，快速学习能力是决定一个人发展现状及未来前景的重要因素。 总重契约精神，总重大家共同制订好的游戏规则，没有这个，创业就无从谈起。 CEO不可被人代替的指责是：设计公司整体愿景和所有战略，确保传达给所有利益相关方，不仅是管理层，包括所有员工，不仅是公司内部人，包括股东、消费者、商户和所有合作伙伴；招到并留住最优秀的人；确保公司要有足够的资金。 以身作则不是塑造公司价值观的最好办法，而是唯一办法。 把所有东西考虑清楚再去讨论能不能做。 2004-2009校内网给他们的经验和教训： 创业团队必须分工明确，CEO必须解放出来，关注整个业界、时代、社会发展的潮流。 快速推广很重要。 没有盲目地自我创新，快速学习别人的优点。比如模仿Facebook，在节省成本的同时，让用户有了当时一流的UI体验。 对资本的看法太过理想化了。应该更早的接触资本，降低姿态，做一些妥协。 必须和信任的人一起创业。唯有信任才能在遇到低潮的情况下让团队依旧坚持稳固。 O2O 线上线下：线上交易，线下消费 保持对未知的世界充满好奇，先把更多的会放进自己的视，才有抉择的余地。 对于社会能产生真实价值的东西，是事业最稳定的基石。不管这种东西是解决人与人的关系，还是解决人与物的关系。 互联网时代是”产品为王”的时代，是完美主义者有着系统性优势的时代。只有完美主义的人，才能把产品打磨的那么出色，产品出色，整个公司就赢了。 任何一个部门，一年只要做对一件事就能获得成功 招聘进来的人的水准应该比现有团队50%的人高，整个团队才会越来越强 对未来越有信心，对现在越有耐心。 一家老有新闻的企业并非好事，在那些枯燥，平凡的日常管理细节里，每天前进一点，日积月累，短期内看不出公司发生了多少变化，把观察时间放长一点，三五年，你就会发现这家公司可能已经脱胎换骨了。这同样适用于每个人。 未来是不确定的，只能战战兢兢，如履薄冰。 一如既往的好奇心，超强的学习能力。 免费的根本问题在于真正的免费如何盈利。 想要构建产品壁垒，就最好做自己擅长的部分。 无数平庸的细节堆积出来的，就是平庸的产品。 如果你希望在一个好的创业公司一路高歌猛进的话，每一年都是关键的一年。 小公司做起来的关键是抓住了一个机会，中等公司的关键是有一批比较强的高管，大公司的关键是要有正确的流程和价值观。 企业创始人的价值观决定整个企业其他人对待整个市场的方式。美团网价值观的排序是：消费者第一、商家第二、员工第三、股东第四、王兴第五。 核心价值观的渗透度越高，整个企业的人员稳定性才越强。公司的使命、愿景、价值观，这些看起来是虚无缥缈的东西，确是团队精神生长的坚实土地。 CEO履行好自己的指责，其他事情都应该找最专业、最好的人来做。 团队的组件原则：招进来的人，水准应该比现有团队50%的人高。只要按照这个标准，整个团队会越来越强。 公司越来越大，为了保障公司的正常运转，需要一套行之有效的组织架构和严密的流程。系统和流程保障了分工明确、权责到位，不易出差错；另一方面却让跨部门合作变得越来越困难，效率在沟通中损耗，创新的热情和机会就有可能在这些损耗中溜掉。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangxinwei.github.io/categories/读书笔记/"}],"tags":[]},{"title":"JavaScript 垃圾收集","slug":"js/JavaScript 垃圾收集","date":"2019-07-08T18:54:53.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2019/07/08/js/JavaScript 垃圾收集/","link":"","permalink":"https://liangxinwei.github.io/2019/07/08/js/JavaScript 垃圾收集/","excerpt":"","text":"JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。而在 C 和 C++ 之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。在编写 JavaScript 程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的原理其实很简单：找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）周期性地执行这一操作。 下面我们来分析一下函数中局部变量的正常生命周期。局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。 标记清除Javascript中最常用的垃圾收集方式是标记清除（mark-and-swep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 到2008年为止，IE、 Firefox、 Opera、 Chrome 和 Safari 的 JavaScript 实现使用的都是标记清除式的垃圾收集策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。 引用计数另一种不太常见的垃圾收集策略叫做引用计数（ reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。 Netscape Navigator3.0 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。请看下面这个例子 123456function problem() &#123; var objectA = new Object(); var objectB = new Object(); objectA.someOtherobject = objectB; objectB.anotherobject = objectA;&#125; 在这个例子中， objectA 和 objectB 通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2。在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA 和 objectB 还将继续存在，因为它们的引用次数永远不会是。假如这个函数被重复多次调用，就会导致大量内存得不到回收。为此，Netscape 在 Navigator4.0 中放弃了引用计数方式，转而采用标记清除来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。 我们知道，IE中有一部分对象并不是原生 JavaScript 对象。例如，其 BOM 和 DOM 中的对象就是使用 C++ 以 COM（ Component Object Model，组件对象模型）对象的形式实现的，而 COM 对象的垃圾收集机制采用的就是引用计数策略。因此，即使 IE 的 JavaScript 引擎是使用标记清除策略来实现的，但 JavaScript 访问的 COM 对象依然是基于引用计数策略的。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用的回题。下面这个简单的例子，展示了使用 COM 对象导致的循环引用问题： 1234var element= document.getElementById(&quot;some element&quot;)var myobject = new Object();myobject.element = element;element.someObject = myobject; 这个例子在一个 DOM 元素（element）与一个原生 JavaScript 对象（myObject）之间创建了循环引用。其中，变量 myobject 有一个名为 element 的属性指向 element 对象；而变量 element 也有一个属性名叫 someObject 回指 myobject，由于存在这个循环引用，即使将例子中的 DOM 从页面中移除，它也永远不会被回收。为了避免类似这样的循环引用问题，最好是在不使用它们的时候手工断开原生 JavaScript 对象与 DOM 元素之间的连接。例如，可以使用下面的代码消除前面例子创建的循环引用： 12myobject.element= null;element.someobject = null; 将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。为了解决上述问题，IE9 把 BOM 和 DOM 对象都转换成了真正的 JavaScript 对象。这样，就避免了两种垃圾收集算法并存导致的问题，也消除了常见的内存泄漏现象。 性能问题垃坂收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多长时间运行次，不禁让人联想到IE因此而声名狼藉的性能问题。IE的垃圾收集器是根据内存分配量运行的，具体点说就是256个变量、4096个对象（或数组）字面量和数组元素（slot）或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使IE重写了其垃圾收集例程。 随着IE7的发布，其 JavaScript 引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。IE7中的各项临界值在初始时与IE6相等。如果垃圾收集例程回收的内存分配量低于15%，则变量、字面量和（或）数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了在运行包含大量 JavaScript 的页面时的性能。 事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议读者这样做。在 IE 中，调用 window.CollectGarbage() 方法会立即执行垃圾收集。在 Opera7 及更高版本中，调用 window.opera.collect() 也会启动垃圾收集例程。 管理内存使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，JavaScript 在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给Web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行 JavaScript 的网页耗尽全部系统内存而导致系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。 因此，确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。旦数据不再有用，最好通过将其值设置为 null 来释放其引用————这个做法叫做解除引用（ dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，如下面这个例子所示： 12345678function createPerson(name) &#123; var localPerson = new Object(); localPerson.name = name; return localPerson;&#125;var globalPerson = createPerson(&quot;Nicholas”);// 手工解除 globalPerson 的引用globalPerson = null; 在这个例子中，变量 globalPerson 取得了 createPerson() 函数返回的值。在 createPerson() 函数内部，我们创建了一个对象并将其赋给局部变量 localPerson，然后又为该对象添加了一个名为 name 的属性。最后，当调用这个函数时，localPerson 以函数值的形式返回并赋给全局变量 globalPerson。由于 localPerson 在 createPerson() 函数执行完毕后就离开了其执行环境，因此无需我们显式地去为它解除引用。但是对于全局变量 globalPerson 而言，则需要我们在不使用它的时候手工为它解除引用，这也正是上面例子中最后一行代码的目的。 不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"roadhog 1.3.X 打包慢的解决办法","slug":"frontend/roadhog-1-3-X-打包慢的解决办法","date":"2019-06-11T19:01:51.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2019/06/11/frontend/roadhog-1-3-X-打包慢的解决办法/","link":"","permalink":"https://liangxinwei.github.io/2019/06/11/frontend/roadhog-1-3-X-打包慢的解决办法/","excerpt":"","text":"背景：公司的后台管理系统项目基于 Antd Pro 早期版本，使用的脚手架是 roadhog，虽然接入了 dva 等框架，方便了我们把工作重心集中在业务上，但是随着项目的庞大，问题随之而来，首当其冲的就是线上部署的时候打包慢的问题。因为 road 的扩展不太灵活，其本身的初衷就是尽可能减少webpack的配置，所以如何降低打包的速度就成了亟需解决的问题。 项目依赖58个，打包之后140个文件。 网上搜了一圈，发现没有令人满意的解决方案，只好自己来解决。仔细缕了一遍思路后发现，还是有解决办法的。 以下改动仅适用于公司的后台管理系统项目。 删除项目中没有用到或废弃的代码 利用好 roadhog 支持的 webpack 配置项 自己改 roadhog 的源码，然后发布为 npm 包，替换掉 roadhog 第一项不用说。 第二项是设置 webpack 的 externals，由于项目中用到了 g2、d3、echarts、@antv/data-set、moment、g-cloud、g2-plugin-slider、cal-heatmap 等 js 库，所以把它们都配置到 externals 下： 12345678910111213141516171819202122232425262728&#123; \"entry\": \"src/index.js\", \"extraBabelPlugins\": [ \"transform-runtime\", \"transform-decorators-legacy\", \"transform-class-properties\", [\"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": true &#125;] ], \"env\": &#123; \"development\": &#123; \"extraBabelPlugins\": [ \"dva-hmr\" ] &#125; &#125;, \"externals\": &#123; \"g2\": \"G2\", \"echarts\": \"echarts\", \"@antv/data-set\": \"DataSet\", \"moment\": \"moment\", \"g-cloud\": \"Cloud\", \"g2-plugin-slider\": \"G2.Plugin.slider\" &#125;, \"ignoreMomentLocale\": true, \"theme\": \"./src/theme.js\", \"hash\": true, \"multipage\": true&#125; 在 .eslint.js 将其配置为全局变量： 1234567\"globals\": &#123; \"CalHeatMap\": true, \"DataSet\": true, \"moment\": true, \"echarts\": true, \"G2\": true&#125; 以上注意： 配置 &quot;multipage&quot;: true 后，roadhog 才会把超过2次引用的依赖打为 common 包 “dva-hmr” 设置在 development 才会避免生产环境下将其打包，因为生产环境下不会用到 将这些 js 库文件（不用包涵g-cloud、g2-plugin-slider）下载下来，放到项目根目录下 public/js 下，roadhog 作者约定 public 目录下的文件会在 server 和 build 时被自动 copy 到输出目录（默认是 ./dist）下。所以可以在这里存放 favicon, iconfont, html, html 里引用的图片等。 手动在 index.ejs 里面将其引入 第三项 主要改动的地方： common.js 下 HtmlWebpackPlugin 插件配置的地方，给它配置 public 下的所有 js 文件和 css 文件的路径和环境变量：1234567891011if (existsSync(join(paths.appSrc, 'index.ejs'))) &#123; const scripts = glob.sync(path.resolve(paths.appPublic) + '/js/*.js').map(filePath =&gt; path.basename(filePath)); const stylesheets = glob.sync(path.resolve(paths.appPublic) + '/stylesheets/*.css').map(filePath =&gt; path.basename(filePath)); ret.push(new HtmlWebpackPlugin(&#123; template: 'src/index.ejs', inject: true, scripts, stylesheets, env: JSON.stringify(NODE_ENV) &#125;));&#125; 然后在你的项目的 index.ejs 中引入： 12345678910111213&lt;head&gt; &lt;% var stylesheets = htmlWebpackPlugin.options.stylesheets || [] %&gt; &lt;% for(var i = 0; i &lt; stylesheets.length; i++) &#123; %&gt; &lt;link rel=\"stylesheet\" href=\"&lt;%= 'stylesheets/' + stylesheets[i] %&gt;\"&gt; &lt;% &#125; %&gt;&lt;/head&gt;&lt;body&gt; &lt;% var scripts = htmlWebpackPlugin.options.scripts || [] %&gt; &lt;% for(var i = 0; i &lt; scripts.length; i++) &#123; %&gt; &lt;script type=\"text/javascript\" src=\"&lt;%= 'js/' + scripts[i] %&gt;\"&gt;&lt;/script&gt; &lt;% &#125; %&gt;&lt;/body&gt; 修改 webpack.config.prod.js 替换 webpack.optimize.UglifyJsPlugin 为： 12345678910...(debug ? [] : [new UglifyJsPlugin(&#123; uglifyOptions: &#123; compress: &#123; warnings: false, &#125;, &#125;, cache: true, sourceMap: false, parallel: true,&#125;)]), UglifyJsPlugin 的好处不必多说，大家自己 google。 删掉 webpack.optimize.CommonsChunkPlugin 配置，参考 vue-cli2 的配置项： 12345678910111213141516171819202122232425262728293031323334if (config.multipage) &#123; // Support hash const name = config.hash ? 'common.[hash]' : 'common'; // ret.push(new webpack.optimize.CommonsChunkPlugin(&#123; // name: 'common', // filename: `$&#123;name&#125;.js`, // &#125;)); ret = ret.concat([ // split vendor js into its own file // 将所有从node_modules中引入的js提取到vendor.js，即抽取库文件 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks(module) &#123; return (module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf(paths.appNodeModules) === 0); &#125;, &#125;), // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated // 从vendor中提取出manifest，原因如上 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', minChunks: Infinity, &#125;), // This instance extracts shared chunks from code splitted chunks and bundles them // in a separate chunk, similar to the vendor chunk // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk new webpack.optimize.CommonsChunkPlugin(&#123; name, async: 'vendor-async', children: true, minChunks: 3, &#125;), ]);&#125; 然后，运行 npm run test，npm run build，编译好之后，发布到 npm 仓库如 liangxinwei_roadhog。 最后，删掉项目下的 package.json 里面 roadhog 相关的依赖，替换为 &quot;liangxinwei_roadhog&quot;: &quot;^1.0.0&quot;： 12345\"devDependencies\": &#123; - \"roadhog\": \"^1.3.1\", - \"roadhog-api-doc\": \"^0.1.0\", + \"liangxinwei_roadhog\": \"^1.0.0\",&#125;, 修改启动和打包命令： 12\"start\": \"node --max_old_space_size=4096 node_modules/liangxinwei_roadhog/lib/server.js\",\"build\": \"node --max_old_space_size=4096 node_modules/liangxinwei_roadhog/lib/build.js\" 经过我前后的数据比对，修改第二项之后，打包时间由原来的 20-30min 缩减到 5-6min，修改第三项之后，初次打包时间为 3-4min，再次打包时间缩减到 1min 之内。大功告成！ 前端开发长路漫漫，大家且行且珍惜。","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"webpack各配置项全解析","slug":"frontend/webpack各配置项全解析","date":"2019-01-30T18:59:45.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2019/01/30/frontend/webpack各配置项全解析/","link":"","permalink":"https://liangxinwei.github.io/2019/01/30/frontend/webpack各配置项全解析/","excerpt":"","text":"以下内容摘自【深入浅出webpack】，包含每一项的具体配置。 entry表示入口, Webpack 执行构建的第一步将从 Entry 开始,可抽象成输入，类型可以是 string、 object、 array 123456789101112// 只有 1 个入口,入口只有 1 个文件entry: &apos; ./app/entry&apos;,// 只有1个入口,入口有两个文件entry: [ &apos;./app/entry1&apos;, &apos;./app/entry2&apos;],// 有两个入口entry: &#123; a: &apos;./app/entry-a&apos;, b: [&apos;./app/entry-bl&apos;, &apos;./app/entry-b2&apos;]&#125;, output如何输出结果 : 在 Webpack 经过一系列处理后,如何输出最终想要的代码 12345678910111213141516171819202122232425262728293031323334353637&#123; // 输出文件存放的目录,必须是 string 类型的绝对路径 path: path.resolve(dirname, &apos; dist &apos;), // 输出文件的名称 // 完整的名称 filename: &apos; bundle.js&apos;, // 在配置了多个 entry 时,通过名称模板为不同的 entry 生成不同的文件名称 filename: &apos; [name].js&apos;, // 根据文件内容的 Hash 值生成文件的名称, 用于 浏览器长时间缓存文件 filename: &apos; [chunkhash].js&apos;, // 放到指定目录下 // 发布到线上的所有资源的 URL 前缀,为 string 类型 publicPath: &apos;/assets/&apos;, // 放到根目录下 publicPath: &apos;&apos;, // 放到 CDN 上 // 导出库的名称 , 为 string 类型, 不填它时,默认的输出格式是匿名的立即执行函数 publicPath: &apos;https://cdn.example.com/&apos;, library: &apos; MyLibrary &apos;, // 导出库的类型,为枚举类型,默认是 var // 可以是umd、 umd2、 commonjs2、 commonjs、 amd、 this、 var、 assign、 window、global、jsonp libraryTarget: &apos;umd&apos;, // 是否包含有用的文件路径信息到生成的代码里 ,为 boolean 类型 pathinfo: true, // 附加 Chunk 的文件名称 chunkFilename: &apos;[id].js&apos;, chunkFilename: &apos;[chunkhash].js&apos;, // JSONP 异步加载资源时的回调函数名称,需要和服务端搭配使用 jsonpFunction: &apos;myWebpackJsonp&apos;, // 生成的 Source Map 文件的名称 // 浏览器开发者工具里显示的源码模块名称 sourceMapFilename: &apos;[file].map&apos;, // 异步加载跨域的资源时使用的方式 devtoolModuleFilenameTemplate: &apos;webpack:lll[resource-path]&apos;, crossOriginLoading: &apos;use-credentials&apos;, crossOriginLoading: &apos;anonymous&apos;, crossOriginLoading: false&#125;, module配置模块相关 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&#123; // 不用解析和处理的模块，Webpack忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能 // 注意，被忽略掉的文件里不应该包含 import、 require、 define 等模块化语句， // 不然会导致在构建出的代码中包含无法在浏览器环境下执行的模块化语句。 // 单独、完整的 、react.min.js、文件没有采用模块化，忽略对 、react.min.js、文件 的递归解析处理 noParse: [/react\\.min\\.js$/], // 配置 Loader rules: [ &#123; // 正则匹配命中要使用 Loader 的文件 test: /\\.jsx$/, // 只会命中这里面的文件 include: [ path.resolve(__dirname, &apos;src&apos;) ], // 忽略这里面的文件 exclude: [ path.resolve(__dirname, &apos;node_modules&apos;) ], // 使用哪些 Loader,有先后次序,从后向前执行 use: [ // style-loader会将 css代码转换成字符串后，注入 JavaScript代码中，通过 JavaScript 向 DOM 增加样式。 如果我们想将 css 代码提取到一个单独的文件中，而不是和 JavaScript 混在 一 起，则可以使用 ExtractTextPlugin &apos;style-loader&apos;, // css-loader 会找出 css 代码中 eimport 和 url ()这样的导入语句，告诉 Webpack 依赖这些资源 。 同时支持 CSS Modules、压缩 css 等功能 。处理完后再将结果交给 style-loader处理。 &apos;css-loader&apos;, // 通过 sass-loader将 scss 源码转换为 css 代码，再将 css 代码交给 css-loader处理。 &apos;sass-loader&apos;, // 直接使用 Loader 的名称 &#123; loader: &apos;css-loader&apos;, // 向 html-loader 传一些参数 options: &#123;&#125; &#125;, ], // 不用解析和处理的模块，Webpack忽略对部分没采用模块化的文件的递归解析处理，这样做的好处是能提高构建性能 noParse: [ // 用正则匹配 /special-library\\.js$/ ] &#125; ], /** * 配置插件 */ plugins: [], /** * 配置寻找模块的规则 */ resolve: &#123; // 寻找模块的根目录,为 array 类型,默认以 node_modules 为根目录 // 可以指明存放第三方模块的绝对路径，以减少寻找， dirname 表示当前工作目录 modules: [path.resolve(__dirname, &apos;node_modules&apos;)], modules: [ &apos;node modules &apos;, path.resolve(__dirname, &apos;app&apos;) ], // 模块的后缀名，后缀尝试列表要尽可能小，频率出现最高的文件后缀要优先放在最前面 extensions: [&apos;.js&apos;, &apos;json&apos;, &apos;jsx&apos;, &apos;.css&apos;], // 模块别名配置,用于映射模块，从而跳过耗时的递归解析操作。 alias: &#123; // 将 &apos;module&apos;映射成&apos;new-module&apos; ,同样, &apos;module/path/file&apos;也会被映射 成&apos;new-module/path/file&apos; &apos;module&apos;: &apos;new-module&apos;, // 使用结尾符号$后 ,将 &apos;only-module&apos; 映射成 &apos;new-module&apos;, // 但是不像上面的 ,&apos; module/path/file &apos;不会被映射成&apos; new-module/path/file &apos;only-module$&apos;: &apos;new-modules&apos;, &#125;, // alias 还支持使用数组来更详细地进行配置 alias: [ &#123; // 老模块 name: &apos;module&apos;, // 新模块 alias: &apos;new-module &apos;, // 是否只映射模块,如果是 true, 则只有&apos; module &apos;会被映射:如果是 false,则&apos;module/inner/path &apos;也会被映射 onlyModule: true, &#125; ], // 是否跟随文件的软链接去搜寻模块的路径 symlinks: true, // 模块的描述文件 descriptionFiles: [&apos; package.json &apos;], // 模块的描述文件里描述入口的文件的字段名 mainFields: [&apos; main &apos;], // 是否强制导入语句写明文件后缀 enforceExtension: false &#125;, /** * 输出文件的性能检查配置 */ performance: &#123; // 有性能问题时输出警告 hints: &apos;warning &apos;, // 有性能问题时输出错误 hints: &apos;error &apos;, // 关闭性能检查 hints: false, // 最大文件的大小(单位为 bytes) maxAssetSize: 200000, // 最大入口文件的大小 (单位为 bytes) maxEntrypointSize: 400000, // 过滤要检查的文件 assetFilter: function (assetFilename) &#123; return assetFilename.endsWith(&apos; .css &apos;) || assetFilename.endsWith(&apos;.js&apos;); &#125; &#125;, // 配置 source-map 类型 devtool: &apos; source-map &apos;, // Webpack 使用的根目录, string 类型必须是绝对路径 // 配置输出代码的运行环境 context: __dirname, // 浏览器,默认 target: &apos;web&apos;, // WebWorker target: &apos;webworker&apos;, // Node.js,使用 、require、语句加载 Chunk代码 target:&apos;async-node&apos;, II Node.js,异步加载 Chunk代码 target: &apos;node&apos;, // nw.js target: &apos;node-webkit&apos;, // electron,主线程 target: &apos;electron-main&apos;, // electron,渲染线程 target: &apos;electron-renderer&apos;, // 使用来自 JavaScript 运行环境提供的全局变量 externals: &#123; jquery: &apos;jQuery&apos; &#125;, /** * 控制台输出日志控制 */ stats: &#123; assets: true, colors: true, errors: true, errorDetails: true, hash: true &#125;, /** * DevServer 相关的配置 */ devServer: &#123; // 代理到后端服务接口 proxy: &#123; &apos;/api&apos;: &apos;http:// localhost:3000&apos; &#125;, // 配置 DevServer HTTP 服务器的文 件根目录 contentBase: path.join(__dirname, &apos;public&apos;), // 是否开启 Gzip 压缩 compress: true, // 是否开发 HTMLS History API 网页 historyApiFallback: true, // 是否开启模块热替换功能 hot: true, // 是否开启 HTTPS 模式 https: false, // 是否捕捉 Webpack构建的性能信息,用于分析是什么原因导致构建性能不佳 profile: true, // 是否启用缓存来提升构建速度 cache: false, // 是否开始 watch: true, // 监听模式选项 // 不监听的文件或文件夹,支持正则匹配。默认为空 watchOptions: &#123; ignored: /node modules/, // 监听到变化发生后,等 300ms 再执行动作,截流,防止文件更新太快导致重新编 译频率太快。默认为 300ms aggregateTimeout: 300, // 不停地询问系统指定的文件有没有发生变化,默认每秒询问 1000 次 poll: 1000 &#125; &#125;&#125;,","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"JavaScript高级程序设计笔记五：对象的属性","slug":"js/JavaScript高级程序设计笔记五：对象的属性","date":"2018-11-18T11:02:45.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2018/11/18/js/JavaScript高级程序设计笔记五：对象的属性/","link":"","permalink":"https://liangxinwei.github.io/2018/11/18/js/JavaScript高级程序设计笔记五：对象的属性/","excerpt":"","text":"ECMAScript 有两种属性：数据属性和访问器属性。 1、数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。 [Configurable]：表示能否通过 delete 删除属性从而重新定义属性，或者能否把属性修改为访问器属性。默认值为true。 [Enumerable]：表示能否通过 for-i 循环返回属性。对于直接在变量上定义的属性，默认值是 true。 [Writable]：表示能否修改属性的值，默认值为true。 [value]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为 undefined。 要修改属性默认的特性，必须使用 ECMAScript 的 Object.defineProperty() 方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、 enumerable、 writable 和 value。设置其中的一或多个值，可以修改对应的特性值。 1234567891011121314const obj = &#123;&#125;;// 设置 a 只读，一旦设置 configurable 就不能再修改了Object.defineProperty(obj, &apos;a&apos;, &#123; configurable: false, value: 123&#125;);// obj: &#123;a: 123&#125;delete a.a // falsea.a = 345 // 345, obj: &#123;a: 123&#125;Object.defineProperty(a, &apos;a&apos;, &#123; configurable: true, value: 222&#125;)// 抛出错误：VM3638:1 Uncaught TypeError: Cannot redefine property: a at Function.defineProperty 2、对象的访问器属性访问器属性不包含数据值，他们包含一对儿 getter 和 setter 函数（都不是必需的）。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性： [Configurable]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为 true。 [Enumerable]：表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。 [get]：在读取属性时调用的函数。默认值为 undefined。 [set]：在写入属性时调用的函数。默认值为 undefined。 访问器属性不能直接定义，必须使用 object.defineProperty() 来定义。请看下面的例子： 1234567891011121314151617var book = &#123; _year: 2004, edition: 1&#125;;Object.defineProperty(book, &quot;year&quot;, &#123; get() &#123; return this._year; &#125;, set(newValue) ( if(newValue &gt; 2004) &#123; this._year = newValue; this.edition = newValue - 2004; &#125; )&#125;);book.year = 2005;alert(book.edition); // 2","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"JavaScript高级程序设计笔记四：创建对象的几种方式","slug":"js/JavaScript高级程序设计笔记四：创建对象的几种方式","date":"2018-11-17T11:02:45.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2018/11/17/js/JavaScript高级程序设计笔记四：创建对象的几种方式/","link":"","permalink":"https://liangxinwei.github.io/2018/11/17/js/JavaScript高级程序设计笔记四：创建对象的几种方式/","excerpt":"","text":"虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同个接口创建很多对象，会产生大量的重复代码。 工厂模式工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节，如下面的例子所示： 1234567891011function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.job = job; o.sayName = function() &#123; alert(this.name); &#125; return o;&#125;var p1 = createPerson(\"Nicholas\", 29, \"Software Engineer\");var p2 = createPerson(\"Greg\", 27, \"Doctor\"); 工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数模式ECMAScript中的构造函数可用来创建特定类型的对象。像 Object 和 Array 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。例如，可以使用构造函数模式将前面的例子重写如下： 12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function() &#123; alert(this.name); &#125;&#125;var p1 = new Person(\"Nicholas\", 29, \"software Engineer\");var p2 = new Person(\"Greg\", 27, \"Doctor\"); 我们注意到， Person() 中的代码除了与 createPerson() 中相同的部分外，还存在以下不同之处: 没有显式地创建对象; 直接将属性和方法赋给了this对象; 没有 return语句 此外，还应该注意到函数名 Person 使用的是大写字母P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头，主要是为了区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。要创建 Person 的新实例，必须使用 new 操作符，实际上会经历以下4个步骤: 创建一个新对象; 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 p1 和 p2 分别保存着 Person 的一个不同的实例，这两个对象都有一个 constructor（构造函数）属性，该属性指向 Person，如下所示： 12alert(p1.constructor === Person); // truealert(p2.constructor === Person); // true 对象的 constructor 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是 instanceof 操作符要更可靠一些。我们在这个例子中创建的所有对象既是 Object 的实例，同时也是 Person 的实例，这一点通过 instanceof 操作符可以得到验证： 1234alert(p1 instanceof Object); // truealert(p1 instanceof Person); // truealert(p2 instanceof Object); // truealert(p2 instanceof Person); // true 将构造函数当作函数构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 new 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 new 操作符来调用，它跟普通函数也不会有什么两样。构造函数的问题构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，p1 和 p2 都有一个名为 sayName() 的方法，但那两个方法不是同一个 Function 的实例。不要忘了 ECMAScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义： 123456function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = new Function(\"alert(this.name)\") // 与声明函数在逻辑上是等价的&#125; 从这个角度上来看构造函数，更容易明白每个 Person 实例都包含一个不同的 Function实例（以显示name属性）的本质。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建 Function 新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的，以下代码可以证明这一点： 1alert(p1.sayName === p2.sayName); // false 然而，创建两个完成同样任务的 Function 实例的确没有必要；况且有 this 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题： 1234567891011function Person(name, age, job) &#123; this.name = name; this.age = age; this.job =job; this.sayName = sayName;&#125;function sayName() &#123; alert(this.name);&#125;var p1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var p2 = new Person(\"greg\", 27, \"Doctor\"); 在这个例子中，我们把 sayName() 函数的定义转移到了构造函数外部。而在构造函数内部，我们将 sayName 属性设置成等于全局的 sayName 函数。这样一来，由于 sayName 包含的是一个指向函数的指针，因此 p1 和 p2 对象就共享了在全局作用域中定义的同一个 sayName() 函数。这样做确实解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。 原型模式我们创建的每个函数都有一个 prototype（原型属性），这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中，如下面的例子所示： 12345678910function Person() &#123;&#125;Person.prototype.name =\"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function() &#123; alert(this. name)&#125;var p1 = new Person();var p2 = new Person();alert(p1.sayName === p2.sayName); // true 在此我们将 sayName() 方法和所有属性直接添加到 Person 的 prototype 中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与构造函数不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，p1 和 p2 访问的都是同一组属性和同一个 sayName() 函数。原型模式继承的问题原型中所有属性是被很多实例共享的，对于基本值，可以通过在实例上添加同名属性以隐藏原型中的对应属性，但是当原型中包含引用类型的属性时，问题就比较突出了： 123456789101112131415161718function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: 'Bob', age: 23, friends: ['Court', 'Shelby']&#125;var p1 = new Person();var p2 = new Person();p1.friends.push('Van');alert(p1.friends); // 'Court'， 'Shelby'， 'Van'alert(p2.friends); // 'Court'， 'Shelby'， 'Van' 此处会有问题alert(p1.friends === p2.friends); // true 组合使用构造函数模式和原型模式前者用于定义实例属性，后者定义方法和共享的属性，这样每个实例都有自己的一份实例属性副本，但同时又共享着对方法的引用，最大限度地节省内存。如下： 1234567891011121314151617181920212223function Person(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.friends = ['Court', 'Shelby'];&#125;Person.prototype = &#123; constructor: Person, sayName() &#123; alert(this.name); &#125;&#125;var p1 = new Person(\"Nicholas\", 29, \"Software Engineer\");var p2 = new Person(\"greg\", 27, \"Doctor\");p1.friends.push('Van');alert(p1.friends); // 'Court', 'Shelby', 'Van'alert(p2.friends); // 'Court', 'Shelby'alert(p1.sayName === p2.sayName); // falsealert(p1.friends === p2.friends); // true","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"JavaScript 高级程序设计笔记三：URI编码方法","slug":"js/JavaScript高级程序设计笔记三：URI编码方法","date":"2018-11-06T11:02:45.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2018/11/06/js/JavaScript高级程序设计笔记三：URI编码方法/","link":"","permalink":"https://liangxinwei.github.io/2018/11/06/js/JavaScript高级程序设计笔记三：URI编码方法/","excerpt":"","text":"URI编码方法Global对象的encodeURI()和encodeURIComponent()方法可以对URI(Uniform Resource Identifiers，通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。其中， encodeURI()主要用于整个 URI (例如：http://www.wrox.com/illegal value. htm)，而 encodeURIComponent()主要用于对URI中的某一段(例如前面URL中的 illegal value.htm)进行编码。它们的主要区别在于，encodeURI()不会对本身属于URL的特殊字符进行编码，例如冒号正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。来看下面的例子。 12345var uri = &quot;http://www.wrox.com/illegal value.htm&quot;;alert(encodeURI(uri));// &quot;http://www.wrox.com/illegal%20value.htm&quot;alert(encodeURIComponent(uri));// &quot;http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm&quot; 使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了 %20。而encodeURIComponent()方法则会使用对应的编码替换所有非字母数字字符。这也正是可以对整个URI使用encodeURI()，而只能对附加在现有URI后面的字符串使用encodeURIComponent()的原因所在。一般来说，我们使用encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URL进行编码。与encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent().其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。例如，它可将%20替换成一个空格，但不会对%23作任何处理，因为%23表示井字号（#），而井字号不是使用encodeURI()替换的。同样地， decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符。","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"JavaScript 高级程序设计笔记二：基本包装类型","slug":"js/JavaScript高级程序设计笔记二：基本包装类型","date":"2018-10-26T11:02:45.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2018/10/26/js/JavaScript高级程序设计笔记二：基本包装类型/","link":"","permalink":"https://liangxinwei.github.io/2018/10/26/js/JavaScript高级程序设计笔记二：基本包装类型/","excerpt":"","text":"为了便于操作基本类型值，ECMAScript还供了3个特殊的引用类型: Boolean、 Number 和 String。这些类型与其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。来看下面的例子： 12var s1 = &quot;some text&quot;;var s2 = s1.substring(2); 这个例子中的变量s1包含一个字符串，字符串当然是基本类型值。而下一行调用了s1的 substring()方法，并将返回的结果保存在了s2中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法(尽管如我们所愿，它们确实有方法)。其实，为了让我们实现这种直观的操作，后台已经自动完成了一系列的处理。当第二行代码访问s1时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。 创建 string类型的一个实例 在实例上调用指定的方法 销毁这个实例。 可以将以上三个步骤想象成是执行了下列 ECMAScript代码： 123var s1 = new String(&quot;some text&quot;);var s2 = s1.substring(2);s1 = nu11; 经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于Boolean 和 Number类型对应的布尔值和数字值。引用类型与基本包装类型的主要区别就是对象的生存周期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法。来看下面的例子: 123var s1 = &quot;some text&quot;;s1.color = &quot;red&quot;;alert(s1.color); // undefined 在此，第二行代码试图为字符串s1添加一个 color属性。但是，当第三行代码再次访问s1时，其 color 属性不见了。问题的原因就是第二行创建的 string对象在执行第三行代码时已经被销毁了。第三行代码又创建自己的 String对象，而该对象没有 color属性。当然，可以显式地调用 Boolean、 Number和 String 来创建基本包装类型的对象。不过，应该在绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用 typeof 会返回 “object”，而且所有基本包装类型的对象都会被转换为布尔值true。Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如: 12var obj = new Object (&quot;some text&quot;);alert(obj instanceof string); // true 把字符串传给 Object构造函数，就会创建 String 的实例；而传入数值参数会得到 Number 的实例，传入布尔值参数就会得到 Boolean的实例。要注意的是，使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。例如: 12345var value =&quot;25&quot;;var number = Number(value); // 转型函数alert(typeof number); // &quot;number&quot;var obj = new Number(value); // 构造函数alert(typeof obj) // &quot;object&quot; 在这个例子中，变量 number 中保存的是基本类型的值25，而变量obj中保存的是 Number 的实例。","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"小程序和h5页面之间的互相跳转","slug":"miniprogram/小程序和h5页面之间的互相跳转","date":"2018-10-23T19:02:45.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2018/10/23/miniprogram/小程序和h5页面之间的互相跳转/","link":"","permalink":"https://liangxinwei.github.io/2018/10/23/miniprogram/小程序和h5页面之间的互相跳转/","excerpt":"","text":"小程序跳转到 h5 页面小程序代码： 1wx.navigateTo(&#123;url: &apos;/pages/webview?url=&apos; + encodeURIComponent(&apos;h5页面的 url&apos;)&#125;); webview.js 12345678910111213&lt;web-view src=&quot;&#123;&#123;url&#125;&#125;&quot; bindmessage=&quot;handlePostMessage&quot;&gt;&lt;/web-view&gt;onLoad: function (options) &#123; this.setData(&#123; url: decodeURIComponent(options.url), &#125;);&#125;,// 接收 h5 页面传递过来的参数handlePostMessage: function (e) &#123; const data = e.detail; console.log(data);&#125; h5 页面代码： 1234&lt;head&gt; ··· &lt;script type=&quot;text/javascript&quot; src=&quot;https://res.wx.qq.com/open/js/jweixin-1.3.2.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 记得把 url 的 host 添加到后台的合法域名中。 h5 页面跳回小程序在 h5 页面的任何点击事件中： 12345678/* eslint-disable */ wx.miniProgram.getEnv(function (res) &#123; if (res.miniprogram) &#123; wx.miniProgram.switchTab(&#123;url: &apos;/pages/home/home&apos;&#125;); wx.miniProgram.postMessage(&#123;data: &#123;id: &apos;1234&apos;&#125;&#125;); // 传的参数 &#125; &#125;); /* eslint-enable */ 请注意，是wx.miniProgram，不是 window.wx.miniProgram","categories":[{"name":"小程序","slug":"小程序","permalink":"https://liangxinwei.github.io/categories/小程序/"}],"tags":[]},{"title":"JavaScript 高级程序设计笔记一：简介、script 标签","slug":"js/JavaScript高级程序设计笔记一：简介、script 标签","date":"2018-09-30T19:02:45.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2018/09/30/js/JavaScript高级程序设计笔记一：简介、script 标签/","link":"","permalink":"https://liangxinwei.github.io/2018/09/30/js/JavaScript高级程序设计笔记一：简介、script 标签/","excerpt":"","text":"一个完整的JavaScript实现应该由下列三个不同的部分组成： 1. 核心（ECMAScript） 由ECMA-262定义的ECMAScript与Web浏览器没有依赖关系，Web浏览器只是ECMAScript实现可能的宿主环境之一（其他如Node、Adobe Flash），宿主环境不仅提供基本的ECMAScript实现，同时也会提供该语言的扩展，以便与环境之间对接交互。它规定了这门语言的下列组成部分：语法、类型、语句、关键字、保留字、操作符、对象。 2. 文档对象模型（DOM） 文档对象模型（DOM，Document Object Model）是针对 XML 但经过扩展用于HTML的应用程序编程接口（API，Application Programming Interface）。DOM 把整个页面映射为一个多层节点结构。HTML和XML页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。通过DOM创建的这个表示文档的树结构，开发人员获得了控制页面内容和结构的主动权。 DOM级别： DOM1级（DOM Level 1）由两个模块组成：DOM Core（规定了如何映射基于XML的文档结构）和DOM HTML（在 Core 的基础上加以扩展，添加了针对HTML的对象和方法）。 DOM2级扩充了鼠标和用户界面事件、范围、遍历等细分模块，而且通过对象接口增加了对CSS的支持。 DOM3级引入了以统一方式加载和保存文档的方法——在DOM加载和保存（DOM Load and Save）模块中定义；新增了验证文档的方法——在DOM验证（DOM Validation）模块中定义。 3. 浏览器对象模型（BOM） 浏览器对象模型（BOM，Browser Object Model）只处理浏览器窗口和框架，如 window， location， navigator， screen， 对 cookies 的支持、像 XMLHttpRequest 这样的自定义对象。 script 标签的属性： async：表示应该立即下载脚本，但不应该妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本，一定在页面的Load事件前执行，但可能会在DOMContentLoaded事件触发之前或之后执行。 charset：代码的字符集 defer：告诉浏览器立即下载，但是延迟执行（遇到标签之后再执行），HTML5规范要求脚本按照他们出现的先后顺序执行（先于DOMContentLoaded事件）， language：用于表示编写代码使用的脚本语言，已弃用 src：表示包含要执行外部代码的文件 type：可以看成是 language 的替代属性看，","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"微信订阅号开发之获取网页授权","slug":"miniprogram/微信订阅号开发之获取网页授权","date":"2018-09-17T19:02:20.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2018/09/17/miniprogram/微信订阅号开发之获取网页授权/","link":"","permalink":"https://liangxinwei.github.io/2018/09/17/miniprogram/微信订阅号开发之获取网页授权/","excerpt":"","text":"题记：项目（Vue）是h5页面，主要用于公众号里面的活动，目的是增加公众号关注人数，达到推广的目的，其中涉及到获取用户的昵称、头像、unionid等基本信息。由于微信公众号改版成订阅号之后，并没有获取用户信息的接口，服务号才有，详情可查看官方文档。所以目前想到的思路是借用和订阅号关联的服务号获取 code，然后利用获取到的code 发送给后端再请求用户信息。 首先，route.js 里面配置 needUnionId，通过 checkUnionId HOC 加工页面使其先获取 unionid，然后再通过 unionid 请求数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import Vue from 'vue';import Router from 'vue-router';import &#123;Util&#125; from './utils';import store from './store/store';import http from './store/module/http';import &#123;checkUnionId&#125; from './hoc';Vue.use(Router);const dynamicImport = (path) =&gt; async (resolve) =&gt; &#123; const module = await import(`./pages/$&#123;path&#125;`); resolve(module);&#125;;/** * 设置项： * * meta: * title: 页面标题 * checkUnionId: 如果需要一进入页面就发请求并携带参数 unionid，则接入 checkUnionId * * 注意：以下的 component 为 dynamicImport 类型的，dynamicImport 的参数都有 ../pages/ 前缀， */const routerList = [ &#123; path: '/wx-login', name: 'WXLogin', meta: &#123; needUnionId: true &#125;, component: dynamicImport('login/wx-login') &#125;, &#123; path: '/login', name: 'login', component: dynamicImport('login/login') &#125;, &#123; path: '*', name: 'not-found', component: dynamicImport('exception/not-found'), meta: &#123;&#125; &#125;];function machiningRouter(arr) &#123; arr.forEach(v =&gt; &#123; const needUnionId = (v.meta || &#123;&#125;).needUnionId === true; if (v.component &amp;&amp; needUnionId) &#123; v.component = checkUnionId(v.component); &#125; if (!needUnionId &amp;&amp; v.children) &#123; machiningRouter(v.children); &#125; &#125;);&#125;machiningRouter(routerList);const router = new Router(&#123; // mode: 'history', // base: '/', routes: routerList&#125;);router.beforeEach((to, from, next) =&gt; &#123; const metaData = to.meta || &#123;&#125;; !metaData.hidden &amp;&amp; http.actions.setLoading(store, &#123;status: true&#125;); metaData.title &amp;&amp; Util.setDocumentTitle(metaData.title); next();&#125;);router.afterEach(route =&gt; &#123; const metaData = route.meta || &#123;&#125;; !metaData.hidden &amp;&amp; http.actions.setLoading(store, &#123;status: false&#125;);&#125;);export default router; 先看 wx-login.vue 的使用方式： 12345678910111213141516171819202122232425262728import &#123;Url, Util&#125; from '@/utils';import &#123;WeChat, closeWindow&#125; from '@/utils/wechat';export default &#123; name: 'WXLogin', data() &#123; return &#123; &#125;; &#125;, created() &#123; // 不需要 // this.requestData(); &#125;, methods: &#123; // 适用于一进入页面就请求数据，checkUnionId 会自动调用，不需要在 created 里面手动调用 async requestData() &#123; &#125;, // 适用于点击按钮才请求数据，此时 checkUnionId 已经获取到了 unionid async handleLogin() &#123; const param = &#123; unionid: this.$parent.unionId, &#125;; await this.$http.post(Url.PMS_QR_CODE_LOGIN, param); this.$toast('扫码登录成功'); this.status = 'success'; &#125;, &#125;&#125;; 其中，checkUnionId.js 为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import &#123;mapActions, mapGetters&#125; from 'vuex';import &#123;getUnionId, WeChat&#125; from '@/utils/wechat';/** * 校验 openId 是否为 null */export default (component) =&gt; (&#123; computed: &#123; ...mapGetters(['unionId']) &#125;, props: component.props, render(h) &#123; return h(component, &#123; on: this.$listeners, attrs: this.$attrs, props: this.$props &#125;); &#125;, mounted() &#123; this.requestUnionId(); &#125;, methods: &#123; ...mapActions(['setLoading']), async requestUnionId() &#123; try &#123; if (this.unionId) &#123; console.log('local unionId:', this.unionId); this.afterRequestUnionId(); &#125; else &#123; this.$toast('获取信息中···'); await getUnionId(); await new WeChat().init(); this.afterRequestUnionId(); &#125; &#125; catch (e) &#123; console.error('check-unionid requestUnionId:', e); &#125; &#125;, afterRequestUnionId() &#123; // fixme: mounted 先于子组件的 mounted 执行，所以不在 setTimeout 里执行的话，this.$children 获取不到，因为页面是按需加载，不是全量加载 setTimeout(() =&gt; &#123; this.$children.forEach(v =&gt; &#123; if (!v.requestData || Object.prototype.toString.call(v) !== '[object Function]') &#123; console.warn('用 checkUnionId 装饰的页面中，如果需要一进入页面就立即发送带 union_id 的请求，那么 methods 中必须有 requestData function 用于获取初始数据，否则，请忽略此条。'); &#125; else &#123; v.requestData(); &#125; &#125;); &#125;, 200); &#125; &#125;&#125;); wechat.js 为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132import Vue from 'vue';import store from '@/store/store';import user from '@/store/module/user';import http from '@/store/module/http';import Util from './util';import axiosInstance from './axios-instance';import Url from './url';const APP_ID = 'APP_ID';const DEFAULT_DATA = &#123; appId: APP_ID, apiList: [ 'checkJsApi', 'closeWindow', 'hideAllNonBaseMenuItem' ], errorType: [ &#123;code: '1', msg: '分享成功'&#125;, &#123;code: '2', msg: '微信客户端版本过低，请升级最新版本'&#125;, &#123;code: '3', msg: '获取接口的签名失效，请重新调用方法获取API授权签名'&#125;, &#123;code: '4', msg: '微信分享失败，请重新分享'&#125;, &#123;code: '5', msg: '接口访问失败'&#125;, &#123;code: '6', msg: 'jsApi配置成功'&#125; ]&#125;;/** * 微信 api 全局管理器 */let instance;class WeChat &#123; constructor() &#123; if (!instance) &#123; instance = this; &#125; this.hasInit = false; return instance; &#125; init() &#123; return new Promise(async (resolve, reject) =&gt; &#123; if (this.hasInit) &#123; resolve(&#123;msg: 'success'&#125;); return; &#125; try &#123; // const config = await axiosInstance.post(Url.SIGNATURE, &#123;url: location.origin&#125;); const config = &#123;&#125;; const registerData = &#123; debug: false, appId: DEFAULT_DATA.appId, timestamp: config.timestamp, nonceStr: config.noncestr, signature: config.signature, jsApiList: DEFAULT_DATA.apiList &#125;; wx.config(registerData); wx.ready(() =&gt; &#123; console.log('wx.ready'); wx.hideAllNonBaseMenuItem &amp;&amp; wx.hideAllNonBaseMenuItem(); if (!localStorage.getItem('userUnionId')) &#123; closeWindow(); throw new Error('unionid is null'); &#125; this.hasInit = true; resolve(&#123;msg: 'success'&#125;); &#125;); wx.error(res =&gt; &#123; wx.hideAllNonBaseMenuItem &amp;&amp; wx.hideAllNonBaseMenuItem(); // Vue.$toast('请退出去重新进入'); // closeWindow(); // throw res; &#125;); &#125; catch (e) &#123; throw e; &#125; &#125;); &#125;&#125;function closeWindow() &#123; typeof wx !== 'undefined' &amp;&amp; wx.closeWindow &amp;&amp; wx.closeWindow();&#125;/** * 获取 code */function getCode() &#123; const url = encodeURIComponent(location.href); window.location.href = `https://open.weixin.qq.com/connect/oauth2/authorize?appid=$&#123;APP_ID&#125;&amp;redirect_uri=$&#123;url&#125;&amp;response_type=code&amp;scope=snsapi_userinfo&amp;connect_redirect=1&amp;state=$&#123;Util.getRandomKey()&#125;#wechat_redirect`;&#125;/** * 获取 user unionId */function getUnionId() &#123; return new Promise(async (resolve, reject) =&gt; &#123; const existedUnionId = localStorage.getItem('userUnionId'); if (existedUnionId) &#123; console.log('缓存中的 onion_id:', existedUnionId, ', 不发请求'); http.actions.setLoading(store, &#123;status: false&#125;); user.actions.setOpenId(store, existedUnionId); resolve(&#123;msg: 'success'&#125;); return; &#125; const code = Util.getUrlSearchParameter().code; console.log('code:', code); if (code) &#123; const result = await axiosInstance.get(Url.USER_INFO, &#123;params: &#123;code&#125;&#125;).catch(e =&gt; &#123; closeWindow(); throw e; &#125;); result.telephone &amp;&amp; user.actions.setTelephoneNumber(store, result.telephone); result.openid &amp;&amp; user.actions.setOpenId(store, result.openid); result.unionid &amp;&amp; user.actions.setUnionId(store, result.unionid); result.nickname &amp;&amp; user.actions.setNickname(store, result.nickname); result.headimgurl &amp;&amp; user.actions.setHeadImgUrl(store, result.headimgurl); resolve(&#123;msg: 'success'&#125;); &#125; else &#123; console.log('没有 code，微信即将重定向···'); getCode(); &#125; &#125;);&#125;export &#123; WeChat, getUnionId, closeWindow&#125;; wechat.js 里面涉及到的 Util 方法： 123456789101112131415161718192021222324/*** 生成唯一的 key*/export function getRandomKey(len = 6) &#123; len = Object.prototype.toString.call(len) === '[object Number]' ? len : 6; len = Math.abs(len) || 6; return Math.random().toString(16).substr(-len);&#125;/*** 获取 URL 的 search 参数值*/export function getUrlSearchParameter() &#123; const search = window.location.search.replace('?', ''); const searchList = search.split('&amp;'); const searchObj = &#123;&#125;; searchList.length &gt; 0 &amp;&amp; searchList.forEach(v =&gt; &#123; const list = v.split('='); if (list.length === 2) &#123; searchObj[list[0]] = list[1]; &#125; &#125;); return searchObj;&#125;","categories":[{"name":"小程序","slug":"小程序","permalink":"https://liangxinwei.github.io/categories/小程序/"}],"tags":[]},{"title":"浏览器/iframe 全屏、退出全屏","slug":"frontend/浏览器-iframe-全屏、退出全屏","date":"2018-08-15T18:56:06.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2018/08/15/frontend/浏览器-iframe-全屏、退出全屏/","link":"","permalink":"https://liangxinwei.github.io/2018/08/15/frontend/浏览器-iframe-全屏、退出全屏/","excerpt":"","text":"外面的 html 文件 index.html： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;fullScreen&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe allowfullscreen src=&quot;iframe.html&quot; frameborder=&quot;0&quot; style=&quot;width: 500px;height: 500px;background:#aaa&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 里面嵌套的 iframe.html 文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;iframe&lt;/h1&gt; &lt;button id=&quot;button&quot;&gt;全屏&lt;/button&gt; &lt;script&gt; // 判断是否允许全屏 var fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled; // 全屏 function launchFullscreen(element) &#123; if (element.requestFullscreen) &#123; element.requestFullscreen(); &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if (element.msRequestFullscreen) &#123; element.msRequestFullscreen(); &#125; else if (element.webkitRequestFullscreen) &#123; element.webkitRequestFullScreen(); &#125; &#125; // 退出全屏 function exitFullscreen() &#123; if (document.exitFullscreen) &#123; document.exitFullscreen(); &#125; else if (document.msExitFullscreen) &#123; document.msExitFullscreen(); &#125; else if (document.mozCancelFullScreen) &#123; document.mozCancelFullScreen(); &#125; else if (document.webkitExitFullscreen) &#123; document.webkitExitFullscreen(); &#125; &#125; var btn = document.querySelector(&apos;#button&apos;); if (fullscreenEnabled) &#123; btn.addEventListener(&apos;click&apos;, function () &#123; var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement; if (fullscreenElement) &#123; exitFullscreen(); btn.innerHTML = &apos;全屏&apos;; &#125; else &#123; launchFullscreen(document.documentElement); btn.innerHTML = &apos;退出全屏&apos;; &#125; &#125;, false); &#125; // 监听全屏事件 document.addEventListener(&apos;webkitfullscreenchange&apos;, function fullscreenChange() &#123; if (document.fullscreenEnabled || document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) &#123; console.log(&apos;enter fullscreen&apos;); &#125; else &#123; console.log(&apos;exit fullscreen&apos;); &#125; &#125;, false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"javaweb常见HTTP状态码","slug":"frontend/javaweb常见HTTP状态码","date":"2017-12-23T18:53:27.000Z","updated":"2021-04-15T14:13:18.553Z","comments":true,"path":"2017/12/23/frontend/javaweb常见HTTP状态码/","link":"","permalink":"https://liangxinwei.github.io/2017/12/23/frontend/javaweb常见HTTP状态码/","excerpt":"","text":"客户端 404 -Not Found 代表客户端错误，指的是服务器端无法找到所请求的资源 400 -请求无效，服务器不理解请求的语法 403 - 禁止访问 ，服务器拒绝请求 405 - 资源被禁止，禁用请求中指定的方法 406 - 无法接受 ，无法使用请求的内容特性响应请求的网页 407 - 要求代理身份验证 ，此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理 408 - 请求超时，服务器等候请求时发生超时 409 - 冲突，服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息 410 - 已删除，如果请求的资源已永久删除，服务器就会返回此响应。 411 - 需要有效长度， 服务器不接受不含有效内容长度标头字段的请求。 412 - 未满足前提条件， 服务器未满足请求者在请求中设置的其中一个前提条件。 413 - 请求实体过大，服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 - 请求的 URI 过长， 请求的 URI（通常为网址）过长，服务器无法处理。 415 - 不支持的媒体类型， 请求的格式不受请求页面的支持。 416 - 请求范围不符合要求，如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 - 未满足期望值，服务器未满足”期望”请求标头字段的要求 500 - 内部服务器错误，无法完成请求 501 - 未实现 ，服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码 502 - 网关错误 ，服务器作为网关或代理，从上游服务器收到无效响应 503 - 服务不可用，服务器目前无法使用，通常，这只是暂时状态 504 - 网关超时， 服务器作为网关或代理，但是没有及时从上游服务器收到请求 505 - HTTP 版本不受支持， 服务器不支持请求中所用的 HTTP 协议版本 服务端 2xx - 客户端请求已成功。 200 - 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页 201 - 已创建，请求成功并且服务器创建了新的资源 202 - 已接受，但尚未处理 203 - 非权威性信息，服务器已成功处理了请求，但返回的信息可能来自另一来源 204 - 无内容，服务器成功处理了请求，但没有返回任何内容 205 - 重置内容，服务器成功处理了请求，但没有返回任何内容 206 - 部分内容，服务器成功处理了部分 GET 请求 3xx - 重定向 302 - 对象已移动 304 - 未修改 307 - 临时重定向 附上全部状态码：HTTP response codes","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"javascript循环与闭包","slug":"js/javascript循环与闭包","date":"2017-11-08T18:54:53.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2017/11/08/js/javascript循环与闭包/","link":"","permalink":"https://liangxinwei.github.io/2017/11/08/js/javascript循环与闭包/","excerpt":"","text":"当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。 下面我们来看一段代码，清晰地展示了闭包： 123456789function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 —— 这就是闭包的效果。 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz() ，实际上只是通过不同的标识符引用调用了内部的函数 bar() 。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。 要说明闭包， for 循环是最常见的例子。 12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000);&#125; 正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。 仔细想一下，延迟函数的回调会在循环结束时才执行。事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0) ，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i 。 我们来试一下通过声明并立即执行一个函数来创建作用域 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function () &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000); &#125;)();&#125; 这样不行。但是为什么呢？我们现在显然拥有更多的词法作用域了。的确每个延迟函数都会将 IIFE（立即执行函数表达式） 在每次迭代中创建的作用域封闭起来。如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。它需要有自己的变量，用来在每个迭代中储存 i 的值： 12345678for (var i = 1; i &lt;= 5; i++) &#123; (function () &#123; var j = i; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)();&#125; 行了！它能正常工作了！。 可以对这段代码进行一些改进： 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function (j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)(i);&#125; 在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。 仔细思考我们对前面的解决方案的分析。我们使用 IIFE 在每次迭代时都创建一个新的作用域。换句话说，每次迭代我们都需要一个块作用域。 let 声明，可以用来劫持块作用域，并且在这个块作用域中声明一个变量。本质上这是将一个块转换成一个可以被关闭的作用域。因此，下面的代码可以正常运行了： 123456for (var i = 1; i &lt;= 5; i++) &#123; let j = i; // 是的，闭包的块作用域！ setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000);&#125; 但是，这还不是全部！for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000);&#125; 这样，问题解决了！","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"记一次管理系统和路由系统的整合","slug":"frontend/记一次管理系统和路由系统的整合","date":"2017-09-28T18:58:27.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2017/09/28/frontend/记一次管理系统和路由系统的整合/","link":"","permalink":"https://liangxinwei.github.io/2017/09/28/frontend/记一次管理系统和路由系统的整合/","excerpt":"","text":"需求：整合管理系统和路由系统UI：同 Ant Design Pro \b 分析由于左侧管理菜单内容在运行时才能确定，而且点击菜单要和右侧内容区联动，地址栏也要有相应的改变，而目前已有的路由系统都是要运行之前要确定具体的路由组建，因此采用 h5 的 history 和 传统的 document.location 结合的方式实现路由系统；整个项目的数据管理则因为考虑到左侧菜单对应的组件可能会使用包括 redux/mbox/dva/kao 之类的框架，如果也使用框架的话，可能会引起冲突，故通过 react 的 context 来实现。 路由系统 router.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889let instance = undefined;class Router &#123; constructor() &#123; if (!instance) &#123; this.history = window.history; this.location = window.location; instance = this; &#125; return instance; &#125; goBack = (cb) =&gt; &#123; this.history.back(); cb &amp;&amp; cb(); &#125; goForward = (cb) =&gt; &#123; this.history.forward(); cb &amp;&amp; cb(); &#125; go = (num, cb) =&gt; &#123; this.history.go(num); cb &amp;&amp; cb(); &#125; pushState = (url, state, cb) =&gt; &#123; url = url || ''; // 加 #，以 hash 的方式改变 url；如果不加，直接以 '/abc' 更改，刷新会报错，请求不到资源（js,css,···） url = url[0] === '/' ? `#$&#123;url&#125;` : `/#$&#123;url&#125;`; this.history.pushState(state || null, '', url); cb &amp;&amp; cb(); &#125; replaceState = (url, state, cb) =&gt; &#123; url = url || '/'; url = url[0] === '/' ? `#$&#123;url&#125;` : `/#$&#123;url&#125;`; this.history.replaceState(state || null, '', url); cb &amp;&amp; cb(); &#125; currentState = () =&gt; &#123; return this.history.state; &#125; currentUrl = () =&gt; &#123; let url = this.location.hash.replace('#', ''); if (url[0] === '/') &#123; url = url.replace('/', ''); &#125; return url; &#125; rootUrl = () =&gt; &#123; return this.location.host; &#125; originUrl = () =&gt; &#123; return this.location.origin; &#125; fullUrl = () =&gt; &#123; return this.location.href; &#125; historyLength = () =&gt; &#123; return this.history.length; &#125;&#125;/** * 拦截器 拦截读写权限 */const handler = &#123; set(target, key, value) &#123; throw new Error(`Setting the $&#123;key&#125; prototype is forbidden`); &#125;, deleteProperty(target, key) &#123; throw new Error(`Deleting the $&#123;key&#125; prototype is forbidden`); &#125;, defineProperty (target, key, descriptor) &#123; throw new Error(`Defining the $&#123;key&#125; prototype is forbidden`); &#125;, setPrototypeOf (target, proto) &#123; throw new Error('Changing the prototype is forbidden'); &#125;&#125;;const routerInstance = new Proxy(new Router(), handler); 路由装饰函数 withRouter.js12345678910111213141516171819202122232425262728293031323334353637383940414243const withRouter = (config = &#123;&#125;) =&gt; (WrapComponent) =&gt; &#123; return class Component extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; data: &#123;&#125; &#125;; &#125; componentDidMount() &#123; config.listenPopState === true &amp;&amp; window.addEventListener('popstate', this.handlePopState); &#125; handlePopState = (data) =&gt; &#123; this.setState(&#123;data: data&#125;); &#125; componentWillUnmount() &#123; config.listenPopState === true &amp;&amp; window.removeEventListener('popstate', this.handlePopState); &#125; render() &#123; const router = &#123; go: routerInstance.go, goBack: routerInstance.goBack, fullUrl: routerInstance.fullUrl, rootUrl: routerInstance.rootUrl, originUrl: routerInstance.originUrl, goForward: routerInstance.goForward, pushState: routerInstance.pushState, currentUrl: routerInstance.currentUrl, replaceState: routerInstance.replaceState, currentState: routerInstance.currentState, historyLength: routerInstance.historyLength &#125;; return React.createElement(WrapComponent, &#123; routerData: this.state.data, router: new Proxy(router, handler),// handler 上面定义的拦截器 ...this.props &#125;); &#125; &#125;;&#125;; 入口组建 App.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import React from 'react';import PropTypes from 'prop-types';import &#123;Layout&#125; from 'antd';import GYSider from './GYSider';import GYHeader from './GYHeader';import GYContent from './GYContent';import Test_1 from '../app/Test_1';import Test_2 from '../app/Test_2';import Test_3 from '../app/Test_3';import Test_1_1_1 from '../app/Test_1_1_1';import &#123;withRouter&#125; from '../util/router';import Util from '../util/Util';const &#123;Header, Sider, Content&#125; = Layout;@withRouter()class App extends React.Component &#123; constructor(props) &#123; super(props); const propsState = props.initialState || &#123;&#125;; const initialState = &#123; menuList: [ &#123; path: 'test_1', icon: 'user', text: 'test_1', component: Test_1, children: [ &#123; path: 'test_1/test_1_1', text: 'test_1_1', children: [ &#123; path: 'test_1/test_1_1/test_1_1_1', component: Test_1_1_1, text: 'test_1_1_1' &#125; ] &#125; ] &#125;, &#123; path: 'test_2', icon: 'setting', text: 'test_2', component: Test_2 &#125;, &#123; path: 'test_3', icon: 'logout', text: 'test_3', component: Test_3 &#125; ] &#125;; this.state = &#123; store: &#123; menuList: initialState.menuList.concat(propsState.menuList || []) &#125;, collapsed: false, currentPath: '', currentComponent: GYContent &#125;; this.getAllComponent(this.state.store.menuList); &#125; /** * 保存所有的路由对应的组件 */ getAllComponent = (menuList = []) =&gt; &#123; this.allComponent = this.allComponent || new Map(); menuList.forEach(val =&gt; &#123; if (val.path &amp;&amp; Util.isReactComponent(val.component)) &#123; this.allComponent.set(val.path, val.component); &#125; if (Util.isArray(val.children)) &#123; this.getAllComponent(val.children); &#125; &#125;); &#125; static contextTypes = &#123; store: PropTypes.object, onClickAction: PropTypes.func &#125; static childContextTypes = &#123; store: PropTypes.object.isRequired, onClickAction: PropTypes.func.isRequired &#125; /** * 子组件获取 store */ getChildContext() &#123; return &#123; store: this.state.store, onClickAction: this.handleClickAction &#125;; &#125; /** * 更新 store 时需要返回合并之后的数据 */ handleClickAction = (data) =&gt; &#123; this.setState(Object.assign(this.state, data)); &#125; componentWillMount() &#123; // 刷新浏览器，跳转到相应页面 const currentPath = this.state.currentPath; const documentHref = this.props.router.currentUrl(); if (currentPath !== documentHref &amp;&amp; this.allComponent.has(documentHref)) &#123; this.setState(&#123; currentComponent: this.allComponent.get(documentHref) &#125;); &#125; &#125; onToggle = () =&gt; &#123; this.setState(&#123; collapsed: !this.state.collapsed &#125;); &#125; onCollapse = () =&gt; &#123; console.log('onCollapse'); &#125; render() &#123; const Component = this.state.currentComponent; return ( &lt;Layout className='gy-app-view'&gt; &lt;Sider collapsible breakpoint=\"md\" width=&#123;256&#125; collapsed=&#123;this.state.collapsed&#125; trigger=&#123;null&#125; onCollapse=&#123;this.onCollapse&#125; &gt; &lt;GYSider/&gt; &lt;/Sider&gt; &lt;Layout&gt; &lt;Header className='header'&gt; &lt;GYHeader collapsed=&#123;this.state.collapsed&#125; onToggle=&#123;this.onToggle&#125;/&gt; &lt;/Header&gt; &lt;Content className='gy-content'&gt; &lt;Component/&gt; &lt;/Content&gt; &lt;/Layout&gt; &lt;/Layout&gt; ); &#125;&#125;export default App; 侧边栏组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import React, &#123;Component&#125; from 'react';import &#123;Menu, Icon&#125; from 'antd';const SubMenu = Menu.SubMenu;import Util from '../util/Util';import &#123;withRouter&#125; from '../util/router';import connectStore from '../util/connectStore';@withRouter() // 接入路由@connectStore // 接入 storeclass GYSider extends Component &#123; constructor(props) &#123; super(props); &#125; componentWillReceiveProps(nextProps, nextContext) &#123; console.log('点击 subMenu 更新 store', nextContext.store); &#125; onMenuClick = (&#123;item, key, keyPath&#125;) =&gt; &#123; let self = this; const path = item.props.path; const currentUrl = this.props.router.currentUrl() || ''; path &amp;&amp; path !== currentUrl &amp;&amp; item.props.component &amp;&amp; self.props.router.pushState(`/$&#123;path&#125;`, &#123;path: `/$&#123;path&#125;`&#125;, () =&gt; &#123; self.context.onClickAction(&#123; currentPath: path, currentComponent: item.props.component &#125;); &#125;); &#125; /** * 更新 store 示例 */ onSubMenuClick = (&#123;key, domEvent&#125;) =&gt; &#123; let store = this.context.store; this.context.onClickAction(&#123;store: Object.assign(store, &#123;[key]: key&#125;)&#125;); &#125; createMenu = (arr = []) =&gt; &#123; return arr.map &amp;&amp; arr.map(val =&gt; &#123; if (!val.text) &#123; return undefined; &#125; else &#123; const key = val.path || Util.generateKey(); return Util.isArray(val.children) ? &lt;SubMenu key=&#123;key&#125; onTitleClick=&#123;this.onSubMenuClick&#125; title=&#123;&lt;span&gt;&#123;val.icon &amp;&amp; &lt;Icon type=&#123;`$&#123;val.icon&#125;`&#125;/&gt;&#125; &lt;span&gt; &#123;val.text&#125; &lt;/span&gt; &lt;/span&gt;&#125;&gt; &#123;this.createMenu(val.children)&#125; &lt;/SubMenu&gt; : &lt;Menu.Item path=&#123;val.path&#125; key=&#123;key&#125; component=&#123;val.component&#125;&gt; &#123;val.icon &amp;&amp; &lt;Icon type=&#123;`$&#123;val.icon&#125;`&#125;/&gt;&#125; &lt;span&gt; &#123;val.text&#125; &lt;/span&gt; &lt;/Menu.Item&gt;; &#125; &#125;).filter(val =&gt; val !== undefined); &#125; render() &#123; return ( &lt;div&gt; &lt;div className='logo'&gt;&lt;/div&gt; &lt;Menu theme=\"dark\" mode=\"inline\" onClick=&#123;this.onMenuClick&#125; style=&#123;&#123;margin: '16px 0', width: '100%'&#125;&#125; &gt; &#123;this.createMenu(this.context.store.menuList)&#125; &lt;/Menu&gt; &lt;/div&gt; ); &#125;&#125;export default GYSider; 接入 store 装饰函数 connectStore.js123456789101112import PropTypes from 'prop-types';export default function connectStore(Component) &#123; if (!Component || typeof Component !== 'function') &#123; console.error(`$&#123;Component &amp;&amp; Component.name&#125; is not a class`); return; &#125; Component.contextTypes = &#123; store: PropTypes.object, onClickAction: PropTypes.func &#125;;&#125; 使用示例1234567891011121314151617181920212223242526272829303132333435363738import React, &#123;Component&#125; from 'react';import 上面的入口组建 Appimport UMD from './UMD';class WrapView extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; let initialState = &#123; menuList: [ &#123; path: 'umd', //对应的地址栏 url icon: 'setting', //侧边栏的显示图标 text: 'umd', //侧边栏的显示文字 component: UMD //点击时对应的右侧内容区组件 &#125; ] &#125;; return ( &lt;App initialState=&#123;initialState&#125;/&gt; ); &#125;&#125;export default WrapView;···import React from 'react';import &#123;render&#125; from 'react-dom';import WrapView from './app/components/WrapView';/** * Main App View */render(&lt;WrapView /&gt;, document.getElementById('app')); 核心思路是通过 context 达到类似于 redux 管理数据的目的，App.js 提供 store（存储数据） 和 onClickAction（修改 store）给子组件，子组件通过 connectStore 装饰函数获取到 store 和 onClickAction，点击侧边栏的时候，先取到设置的 path 和 component，然后通过 onCLickAction 设置 currentComponent 和 currentPath，然后 setState 即可实现需求。目前还有一个问题，就是刷新浏览器的时候如何跳转到相应的页面呢？可以在 App.js 里面先获取到所有的 component 和 path 然后保存起来： 1234567891011121314/*** 保存所有的路由对应的组件*/getAllComponent = (menuList = []) =&gt; &#123; this.allComponent = this.allComponent || new Map(); menuList.forEach(val =&gt; &#123; if (val.path &amp;&amp; Util.isReactComponent(val.component)) &#123; this.allComponent.set(val.path, val.component); &#125; if (Util.isArray(val.children)) &#123; this.getAllComponent(val.children); &#125; &#125;);&#125; 再在 App.js 通过以下代码跳转： 12345678910componentWillMount() &#123; // 刷新浏览器，跳转到相应页面 const currentPath = this.state.currentPath; const documentHref = this.props.router.currentUrl(); if (currentPath !== documentHref &amp;&amp; this.allComponent.has(documentHref)) &#123; this.setState(&#123; currentComponent: this.allComponent.get(documentHref) &#125;); &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"fatal: Could not read from remote repository.的解决办法","slug":"git/fatal-Could-not-read-from-remote-repository-的解决办法","date":"2017-07-28T19:01:01.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2017/07/28/git/fatal-Could-not-read-from-remote-repository-的解决办法/","link":"","permalink":"https://liangxinwei.github.io/2017/07/28/git/fatal-Could-not-read-from-remote-repository-的解决办法/","excerpt":"","text":"查看远端地址 git remote –v查看配置 git config --list 1234git add . // 暂存所有的更改git checkout . // 丢弃所有的更改git status // 查看文件状态git commit -m &quot;本次要提交的概要信息&quot; // 提交 设置远端仓库地址 git remote set-url origin 你的远端地址 git remote add origin_new 新的地址 git remote –v查看 git push origin_new master重新推送 下面是设置用户名 Git config –global user.name “用户名” git config –global user.email 邮箱地址 设置代理： git config --global https.proxy http://127.0.0.1:1080 取消设置代理：git config --global --unset https.proxy 取消git init操作时出现 rm: cannot remove ‘.git’: Is a directory是因为输入的命令是： rm -f .git解决办法：rm -rf .git 即删除整个.git目录 failed to push some refs to ‘git@github.com:***.git’ hint: Updates were rejected ···使用git push origin master的时候出现一下错误： 解决办法：git push -f origin master或者git pull下 恢复不小心删除的 git stash 文件： 123git fsck //找到dangling的对象git show id //上面列出的每一条记录的最后一个字符串，按 enter 查看具体信息git stash apply id git 回滚提交 123456//reset将一个分支的末端指向另一个提交。这可以用来移除当前分支的一些提交, 让master分支向后回退了两个提交git checkout mastergit reset HEAD~2//Revert撤销一个提交的同时会创建一个新的提交, 找出倒数第二个提交，然后创建一个新的提交来撤销这些更改，然后把这个提交加入项目中。git revert HEAD~2 错误：Please enter a commit message to explain why this merge is necessary. 解决办法： （可选）按键盘字母 i 进入insert模式 （可选）修改最上面那行黄色合并信息 按键盘左上角”Esc” （退出insert模式） 输入”:wq”,按回车键即可（提交） gitignore notworking： 123git rm -r --cached .git add .git commit -m &quot;fixed untracked files&quot; git Failed to connect to www.google.com port 80: Timed out 可能是因为设置了代理： 12git config --global http.proxy //查看代理git config --global --unset http.proxy //取消代理 HTTP Basic access denied on Git： 123git config --global --unset credential.helpergit clone &apos;···&apos;login username，password rebase 和 merge 区别 1git pull --rebase origin master rebase 选项告诉 Git 把你的提交移到同步了中央仓库修改后的 master 分支的顶部。rebase 操作过程是把本地提交一次一个地迁移到更新了的中央仓库master分支之上。这意味着可能要解决在迁移某个提交时出现的合并冲突，而不是解决包含了所有提交的大型合并时所出现的冲突。这样的方式让你尽可能保持每个提交的聚焦和项目历史的整洁。反过来，简化了哪里引入Bug的分析，如果有必要，回滚修改也可以做到对项目影响最小。 1git pull origin master 如果没有 rebase， pull 操作仍然可以完成，但每次 pull 操作要同步中央仓库中别人修改时，提交历史会以一个多余的『合并提交』结尾。合并玩冲突之后，git rebase --continue，Git 会继续一个一个地合并后面的提交，如其它的提交有冲突就重复这个过程。如果你碰到了冲突，但发现搞不定，不要惊慌。只要执行下面这条命令，就可以回到你执行git pull –rebase命令前的样子：git rebase --abort","categories":[{"name":"git","slug":"git","permalink":"https://liangxinwei.github.io/categories/git/"}],"tags":[]},{"title":"搭建一个包含 redux、router、国际化的前端项目框架","slug":"frontend/搭建一个包含-redux、router、国际化的前端项目框架","date":"2017-06-08T18:57:41.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2017/06/08/frontend/搭建一个包含-redux、router、国际化的前端项目框架/","link":"","permalink":"https://liangxinwei.github.io/2017/06/08/frontend/搭建一个包含-redux、router、国际化的前端项目框架/","excerpt":"","text":"目的搭建一个交互比较多的 react 前端项目框架，数据可预测，可路由跳转，可国际化，数据操作可控制 使用的主要类库 i18next 国际化 react-i18next i18next-browser-languagedetector immutability-helper immutable 处理数据 react react-dom react-redux 管理数据 react-router 路由 react-router-redux 路由接入 store redux说明 因为 router 是异步过程，所以注入到 store 中，通过 action 跳转路由 在 react-redux 原生 action、reducer 之上封装了一层，便于分发、匹配 action、reducer 执行顺序： action -&gt; 前置拦截器（return true）-&gt; reducer（修改 store）-&gt; componentWillReceiveProps -&gt; shouldComponentUpdate（return true）-&gt; render -&gt; 后置拦截器 项目地址：https://github.com/liangxinwei/redux-ele 项目布局12345678910111213141516171819202122232425262728293031323334353637383940├── cfg webpack 配置文件│ ├── base.js webpack 配置│ ├── default.js loader，plugin│ ├── dev.js dev 环境 │ └── dist.js dist 环境├── src 源码目录│ ├── app│ │ ├── component 具体业务组件，配合 routes 目录使用│ │ ├── config store 配置│ │ │ ├── AppActionRouter.js 分发相应 type 的 action│ │ │ ├── AppReducerCreator.js 匹配相应 type 的 action 的 reducer│ │ │ ├── ConfigureStore.js 生成 store│ │ │ └── index.js 统一导出│ │ ├── i18n 国际化配置│ │ │ ├── locales 中英文配置文件│ │ │ │ ├── en 英文配置│ │ │ │ └── zh 中文配置│ │ │ ├── i18n.js i18next 配置│ │ │ └── index.js 统一导出│ │ ├── middleware 中间件│ │ │ ├── AppMiddleWare.js 前置、后置拦截器业务代码│ │ │ ├── ComponentMiddleWare.js 操作拦截器中间件│ │ │ ├── index.js 中间件统一导出│ │ │ └── LoggerMiddleWare.js 日志中间件│ │ ├── routes 路由配置│ │ │ └── index.jsx│ │ └── App.jsx app 入口│ ├── index.ejs ejs 模板文件│ └── index.jsx 挂载 react dom├── test├── .babelrc babel 配置文件├── .editorconfig 跨平台编辑器配置文件├── .eslintignore eslintignore 配置文件├── .eslintrc eslint 配置文件├── .gitignore├── package.json ├── postcss.config.js postcss 配置文件 ├── server.js 本地服务（webpack-dev-server）├── webpack.config.js webpack 配置文件入口└── README.md App.jsx 项目入口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import React, &#123;Component&#125; from &apos;react&apos;;import &#123;Provider&#125; from &apos;react-redux&apos;;import &#123;I18nextProvider&#125; from &apos;react-i18next&apos;;import &#123;syncHistoryWithStore&#125; from &apos;react-router-redux&apos;;import &#123;hashHistory&#125; from &apos;react-router&apos;;import &#123;reducers&#125; from &apos;./components&apos;; //合并之后的 reducerimport &#123;default as Store&#125; from &apos;./config/ConfigureStore&apos;;import appMiddleWares from &apos;./middleware/AppMiddleWare&apos;;import &#123;i18n, locales&#125; from &apos;./i18n&apos;; //见下面 i18n 配置import routes from &apos;./routes&apos;;import &apos;./style/index.scss&apos;;/** * App View */class App extends Component &#123; constructor(props) &#123; super(props); &#125; componentWillMount() &#123; // 添加i18n语言包 for (let ns in locales[&apos;zh&apos;]) &#123; if (locales[&apos;zh&apos;].hasOwnProperty(ns)) &#123; i18n.addResourceBundle(&apos;zh&apos;, ns, locales[&apos;zh&apos;][ns]); i18n.addResourceBundle(&apos;en&apos;, ns, locales[&apos;en&apos;][ns]); &#125; &#125; &#125; render() &#123; let storeOptions = &#123;&#125;; const defaultStates = &#123;&#125;; const allReducers = Object.assign(&#123;&#125;, reducers); //此处可以并入其它模块中的 reducer const preMiddleWares = Object.assign(&#123;&#125;, appMiddleWares.preMiddleWares); //此处可以并入其它模块中的 preMiddleWares const postMiddleWares = Object.assign(&#123;&#125;, appMiddleWares.postMiddleWares); //此处可以并入其它模块中的 postMiddleWares storeOptions.initialStates = defaultStates; storeOptions.reducers = allReducers; storeOptions.preMiddleWares = preMiddleWares; storeOptions.postMiddleWares = postMiddleWares; const store = Store.configureStore(storeOptions); const history = syncHistoryWithStore(hashHistory, store); return ( &lt;Provider store=&#123;store&#125;&gt; &lt;I18nextProvider i18n=&#123;i18n&#125;&gt; &#123;routes(history)&#125; &lt;/I18nextProvider&gt; &lt;/Provider&gt; ); &#125;&#125;export default App; routes 路由配置12345678910111213141516171819import React from &apos;react&apos;;import &#123;Router, Route&#125; from &apos;react-router&apos;;import &#123; HomeView, BusinessDetail&#125; from &apos;../components&apos;;const routes = (history) =&gt; &#123; return ( &lt;Router history=&#123;history&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;HomeView&#125;/&gt; &lt;Route path=&quot;/home&quot; component=&#123;HomeView&#125;/&gt; &lt;Route path=&quot;/business/:id&quot; component=&#123;BusinessDetail&#125;/&gt; &lt;/Router&gt; );&#125;;export default routes; ConfigureStore.js 构建 Store1234567891011121314151617181920212223242526272829303132333435import &#123;applyMiddleware, compose, createStore, combineReducers&#125; from &apos;redux&apos;;import thunk from &apos;redux-thunk&apos;;import &#123;hashHistory&#125; from &apos;react-router&apos;;import &#123;routerReducer, routerMiddleware&#125; from &apos;react-router-redux&apos;;import &#123;componentMiddleWare, logger&#125; from &apos;../middleware&apos;;import appReducerCreator from &apos;./AppReducerCreator&apos;;/** * store 构建器 */export function configureStore(config) &#123; // 合并之后的 preMiddleWares, postMiddleWares, reducers let &#123;initialStates, preMiddleWares, postMiddleWares, reducers&#125; = config; let allReducer = Object.assign(&#123;&#125;, reducers); let appReducer = appReducerCreator(initialStates, allReducer); const finalReducer = combineReducers(&#123;appReducer, routing: routerReducer&#125;); const allMiddleWares = [ thunk, // 异步 action componentMiddleWare(preMiddleWares, postMiddleWares), // 具体业务拦截器 routerMiddleware(hashHistory), // router 注入到 store 中 logger ]; let enhancer = compose( applyMiddleware(...allMiddleWares) ); return createStore(finalReducer, &#123;&#125;, enhancer);&#125;const Store = &#123; configureStore&#125;;export default Store; AppReducerCreator.js123456789101112131415/** * 全局 Reducer 产生器 */function appReducerCreator(wrapInitialState, allReducerMap) &#123; function appReducer(state = wrapInitialState, action) &#123; if (action &amp;&amp; action.type &amp;&amp; allReducerMap[action.type]) &#123; return allReducerMap[action.type](state, action); &#125; else &#123; return state; &#125; &#125; return appReducer;&#125;export default appReducerCreator; ComponentMiddleWare.js action 拦截器1234567891011121314151617181920212223242526/** * 操作拦截器中间件 */export function componentMiddleWare(preMiddleWares, postMiddleWares) &#123; return function (&#123;getState&#125;) &#123; return next =&gt; (action) =&gt; &#123; // 前置拦截校验函数 let preInterceptFunc = preMiddleWares ? preMiddleWares[action.type] : null; // 进行拦截校验操作 if (preInterceptFunc &amp;&amp; !preInterceptFunc.call(this, action, getState())) &#123; console.error(&apos;Invalid action for preMiddleWares intercept!!&apos;); return; &#125; // 调用 middleware 链中下一个 middleware 的 dispatch。 const returnValue = next(action); // 后置拦截函数 let postInterceptFunc = postMiddleWares ? postMiddleWares[action.type] : null; // 进行拦截校验操作 postInterceptFunc &amp;&amp; postInterceptFunc.call(this, action, getState()); return returnValue; &#125;; &#125;;&#125; LoggerMiddleWare.js123456789101112/** * 日志 MiddleWare */export function logger(&#123;getState&#125;) &#123; return next =&gt; (action) =&gt; &#123; console.info(&apos;will dispatch&apos;, action); // 调用 middleware 链中下一个 middleware 的 dispatch。 const returnValue = next(action); console.info(&apos;after dispatch&apos;, getState()); return returnValue; &#125;;&#125; AppMiddleWare.js 具体业务中间件，构建 store 时注入123456789101112131415161718192021222324/** * 前置拦截器 */let preMiddleWares = &#123; TEST: (action, state) =&gt; &#123; return true;// false 则本次 action 无效，数据不会被修改 &#125;&#125;;/** * 后置拦截器 */let postMiddleWares = &#123; TEST: (action, state) =&gt; &#123; ··· // 此处修改之后不会立即在 ui 上体现出来，因为它在 render 之后执行。且因为参数 state 为引用，所以是直接修改，可做一些提示性的操作 &#125;&#125;;let appMiddleWares = &#123; preMiddleWares, postMiddleWares&#125;;export default appMiddleWares; connectToStore.js 组件接入 store decorator1234567891011121314151617181920import &#123;bindActionCreators&#125; from &apos;redux&apos;;import &#123;connect&#125; from &apos;react-redux&apos;;import appConfig from &apos;../config&apos;;// appConfig.router 即下面的 AppActionRouter.jsconst AppActionRouter = appConfig.router;function mapStateToProps(state) &#123; return &#123; store: state.appReducer || &#123;&#125;, routerStore: (state.routing &amp;&amp; state.routing.locationBeforeTransitions) || &#123;&#125; &#125;;&#125;function mapDispatchToProps(dispatch) &#123; return bindActionCreators(AppActionRouter, dispatch);&#125;export default function connectToStore(component) &#123; return connect(mapStateToProps, mapDispatchToProps)(component);&#125; AppActionRouter.js 分发 action1234567891011121314151617181920212223import &#123;actions&#125; from &apos;../components&apos;;// action 为合并之后的所有的 action/** * app action Router */function onClickWithoutCheck(action) &#123; return action;&#125;/** * 如果外部注入 action，那么直接使用 action 的操作即可。 * 如果外部没有注入 action， 使用 dispatch 操作。 */export function onClickAction(action, props) &#123; return function (dispatch, getState) &#123; if (action.type &amp;&amp; actions.hasOwnProperty(action.type)) &#123; actions[action.type].call(this, action, dispatch, props); &#125; else &#123; dispatch(onClickWithoutCheck(action)); &#125; &#125;;&#125; acion 示例1234567let homeActions = &#123;&#125;;homeActions[&apos;TEST&apos;] = function (action, dispatch, state) &#123; dispatch(action);&#125;;export default homeActions; reducer 示例1234567891011import Immutable from &apos;immutable&apos;;let homeReducers = &#123;&#125;;homeReducers[&apos;TEST&apos;] = function (state, action) &#123; let foo = Immutable.fromJS(state); let newArr = foo.mergeDeep(Immutable.fromJS(action.content)); return newArr.toJS();&#125;;export default homeReducers; i18n 配置12345678910111213141516171819202122232425import i18next from &apos;i18next&apos;;import LanguageDetector from &apos;i18next-browser-languagedetector&apos;;const i18n = i18next .use(LanguageDetector) .init(&#123; fallbackLng: &apos;zh&apos;, // have a common namespace used around the full app ns: [&apos;common&apos;], defaultNS: &apos;common&apos;, debug: false, interpolation: &#123; escapeValue: false // not needed for react!! &#125; &#125;, (err) =&gt; &#123; if (err) &#123; console.error(&apos;i18next&apos;, err); &#125; // console.log(&apos;i18next initialized and ready to go!&apos;); &#125;);export default i18n; i18n 英文配置1234const home = &#123; title: &apos;Home Page&apos;&#125;;export default &#123;home&#125;; i18n 中文配置1234const home = &#123; title: &apos;首页&apos;&#125;;export default &#123;home&#125;; i18n 中英文统一导出123456789import zh from &apos;./zh&apos;;import en from &apos;./en&apos;;const locales = &#123; zh: zh, en: en&#125;;export default locales; 组件实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React, &#123;Component&#125; from &apos;react&apos;;import &#123;translate&#125; from &apos;react-i18next&apos;;import i18n from &apos;../i18n&apos;;@translate([&apos;home&apos;], &#123;wait: true&#125;) // 使用多语言@connectToStore // 组件介入 storeclass Test extends Component &#123; constructor(props) &#123; super(props); &#125; // 路由跳转 transformRouter = () =&gt; &#123; const &#123;onClickAction&#125; = this.props; // 见下面路由 acion let gotoAction = &#123; type: &apos;GOTO&apos;, content: &apos;/home&apos; &#125;; onClickAction(gotoAction, this.props); &#125; // 发送 action changeStore = () =&gt; &#123; const &#123;onClickAction, store&#125; = this.props; let action = &#123; type: &apos;TEST&apos;, content: &#123;data: &apos;test&apos;&#125; &#125;; onClickAction(action, this.props); &#125; // 切换语言 setLanguage = () =&gt; &#123; i18n.changeLanguage(&apos;zh&apos;); // or en &#125; render() &#123; const &#123;t, store&#125; = this.props; return ( &lt;div className=&apos;app-home&apos;&gt; &lt;div className=&apos;app-header&apos;&gt; &lt;span&gt;&#123;t(&apos;title&apos;)&#125;&lt;/span&gt; &lt;/div&gt; &lt;div&gt; content &lt;/div&gt; &lt;Footer/&gt; &lt;/div&gt; ); &#125;&#125;export default Test; 路由 acion，不需要 路由 recuder123456789import &#123;push&#125; from &apos;react-router-redux&apos;;let routerActions = &#123;&#125;;routerActions[&apos;GOTO&apos;] = function (action, dispatch, state) &#123; dispatch(push(action[&apos;content&apos;]));&#125;;export default routerActions;","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]},{"title":"一些容易被忽略的 JavaScript 知识点","slug":"js/一些容易被忽略的-javascript-知识点","date":"2017-05-10T18:55:37.000Z","updated":"2021-04-15T14:13:18.557Z","comments":true,"path":"2017/05/10/js/一些容易被忽略的-javascript-知识点/","link":"","permalink":"https://liangxinwei.github.io/2017/05/10/js/一些容易被忽略的-javascript-知识点/","excerpt":"","text":"ReferenceError和TypeError如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError异常。如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError 。ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。 立即执行函数表达式由于函数被包含在一对 () 括号内部，因此成为了一个表达式，通过在末尾加上另外一个()可以立即执行这个函数，比如 (function foo(){ .. })() 。第一个()将函数变成表达式，第二个()执行了这个函数。 letlet 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说， let为其声明的变量隐式地了所在的块作用域。使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在” 。for 循环头部的let不仅将i绑定到了for循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。 提升考虑以下代码： 123a = 2;var a;console.log(a);// 2 考虑另外一段代码： 12console.log(a);// undefinedvar a = 2; 过程： 当你看到 var a = 2; 时，JavaScript 实际上会将其看成两个声明： var a; 和 a = 2; 。第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。第一个代码片段会以如下形式进行处理： 123var a;a = 2;console.log(a); 其中第一部分是编译，而第二部分是执行。第二个代码片段实际是按照以下流程处理的： 123var a;console.log(a);a = 2; 这个过程就叫作提升。但是函数表达式却不会被提升。例如： 1234foo(); // 不是 ReferenceError, 而是 TypeError!var foo = function bar() &#123; // ...&#125;; 这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域） ，因此foo()不会导致 ReferenceError 。但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式，那么就会赋值） 。 foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。同时也要记住，即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用： 12345foo(); // TypeErrorbar(); // ReferenceErrorvar foo = function bar() &#123; // ...&#125;; 这个代码片段经过提升后，实际上会被理解为以下形式： 1234567var foo;foo(); // TypeErrorbar(); // ReferenceErrorfoo = function() &#123; var bar = ...self... // ...&#125; 函数声明和变量声明都会被提升。但是是函数会首先被提升，然后才是变量。考虑以下代码： 12345678foo(); // 1var foo;function foo() &#123; console.log(1);&#125;foo = function() &#123; console.log(2);&#125;; 会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式： 1234567function foo() &#123; console.log(1);&#125;foo(); // 1foo = function() &#123; console.log(2);&#125;; 注意， var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了） ，因为函数声明会被提升到普通变量之前。尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。 作用域闭包定义：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。下面这段代码清晰地展示了闭包： 123456789function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // 2 —— 这就是闭包的效果。 bar() 显然可以被正常执行，但是它在自己定义的词法作用域以外的地方执行。看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。 typeof null = “object”不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“ object ” 。 Array使用 delete 运算符可以将单元从数组中删除，单元删除后，数组的 length 属性并不会发生变化 123456var a = [ ];a[0] = 1;// 此处没有设置 a[1] 单元a[2] = 3;a[1]; // undefineda.length; // 3 上面的代码可以正常运行，但其中的 “ 空白单元 ” （ empty slot ）可能会导致出人意料的结果。另外：如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理 123var a = [ ];a[&quot;13&quot;] = 42;a.length; // 14 Number()对于 . 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。true 转换为 1 ， false 转换为 0 。 undefined 转换为 NaN ， null 转换为 0。为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有 valueOf() 方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。使用 Object.create(null) 创建的对象 [[Prototype]] 属性为 null ，并且没有 valueOf() 和 toString() 方法，因此无法进行强制类型转换。看下面的例子： 12345678910111213141516171819202122232425262728// 无效语法：因为 . 被视为常量 42. 的一部分，所以没有. 属性访问运算符来调用 tofixed 方法42.toFixed(3); // SyntaxError// 下面的语法都有效：(42).toFixed(3); // &quot;42.000&quot;0.42.toFixed(3); // &quot;0.420&quot;42..toFixed(3); // &quot;42.000&quot;42 .toFixed(3); // &quot;42.000&quot;var a = &#123;valueOf: function()&#123; return &quot;42&quot;;&#125;&#125;;var b = &#123; toString: function()&#123; return &quot;42&quot;; &#125;&#125;;var c = [4,2];c.toString = function()&#123; return this.join(&quot;&quot;); // &quot;42&quot;&#125;;Number(a); // 42Number(b); // 42Number(c); // 42Number(&quot;&quot;); // 0Number([]); // 0Number([&quot;abc&quot;]); // NaN Boolean 假值 undefined,null,false,+0,-0,NaN,””。假值列表以外的值都是真值 假值对象12345var a = new Boolean(false);var b = new Number(0);var c = new String(&quot;&quot;);var d = Boolean(a &amp;&amp; b &amp;&amp; c);d; // true 说明 a 、 b 、 c 都为 true 虽然 JavaScript 代码中会出现假值对象，但它实际上并不属于 JavaScript 语言的范畴。浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是 “ 假值对象 ” 。假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false 。最常见的例子是 document.all ，它是一个类数组对象，包含了页面上的所有元素，由 DOM （而不是 JavaScript 引擎）提供给 JavaScript 程序使用。它以前曾是一个真正意义上的对象，布尔强制类型转换结果为 true ，不过现在它是一个假值对象。document.all 并不是一个标准用法，早就被废止了。 奇特的 ~ 运算符1. 类型转换 它首先将值强制类型转换为 32 位数字，然后执行字位操作 “非” （对每一个字位进行反转）。这与!很相像，不仅将值强制类型转换为布尔值&lt;，还对其做字位反转。对~还可以有另外一种诠释，源自早期的计算机科学和离散数学：~返回 2 的补码。~x大致等同于-(x+1)。~和indexOf()一起可以将结果强制类型转换（实际上仅仅是转换）为真 / 假值： 12345678910var a = &quot;Hello World&quot;;~a.indexOf(&quot;lo&quot;); // -4 &lt;-- 真值 !if (~a.indexOf(&quot;lo&quot;)) &#123; // true // 找到匹配！&#125;~a.indexOf(&quot;ol&quot;); // 0 &lt;-- 假值 !!~a.indexOf(&quot;ol&quot;); // trueif (!~a.indexOf(&quot;ol&quot;)) &#123; // true // 没有找到匹配！&#125; 如果 indexOf(..) 返回 -1 ，~将其转换为假值 0，其他情况一律转换为真值。 2. 字位截除 使用 ~~ 来截除数字值的小数部分，以为这和Math.floor(..)的效果一样，实际上并非如此。~~中的第一个~执行ToInt32并反转字位，然后第二个~再进行一次字位反转，即将所有字位反转回原值，最后得到的仍然是ToInt32的结果。~~和!!很相似，它只适用于 32 位数字，更重要的是它对负数的处理与Math.floor(..)不同。 12Math.floor(-49.6); // -50~~-49.6; // -49 ~~x能将值截除为一个 32 位整数，x | 0也可以，而且看起来还更简洁。出于对运算符优先级的考虑，我们可能更倾向于使用 ~~x 。 == 和 ===常见的误区是：“ == 检查值是否相等， === 检查值和类型是否相等 ” 。听起来蛮有道理，然而还不够准确。正确的解释是：“ == 允许在相等比较中进行强制类型转换，而 === 不允许。”两种解释的区别：根据第一种解释（不准确的版本）， === 似乎比 == 做的事情更多，因为它还要检查值的类型。第二种解释中 == 的工作量更大一些，因为如果值的类型不同还需要进行强制类型转换。有人觉得 == 会比 === 慢，实际上虽然强制类型转换确实要多花点时间，但仅仅是微秒级（百万分之一秒）的差别而已。如果进行比较的两个值类型相同，则 == 和 === 使用相同的算法，所以除了 JavaScript 引擎实现上的细微差别之外，它们之间并没有什么不同。== 和 === 都会检查操作数的类型。区别在于操作数类型不同时它们的处理方式不同。 逗号操作符逗号操作符可以在一条语句中执行多个操作，常用于申明多个变量，还可以用于赋值（总会返回表达式中的最后一项）。 12var num1 = 1, num2 = 2, num3 = 3;var num = (5, 1, 4, 8, 0); // num 为 0 抽象关系比较 a &lt; b分为两个部分：比较双方都是字符串（后半部分）和其他情况（前半部分）。比较双方首先调用 ToPrimitive ，如果结果出现非字符串，就根据 ToNumber 规则将双方强制类型转换为数字来进行比较。 1234var a = [ 42 ];var b = [ &quot;43&quot; ];a &lt; b; // trueb &lt; a; // false -0 和 NaN 的相关规则在这里也适用。如果比较双方都是字符串，则按字母顺序来进行比较 123456789101112131415161718192021var a = [ &quot;42&quot; ];var b = [ &quot;043&quot; ];a &lt; b; // falsevar a = [ 4, 2 ];var b = [ 0, 4, 3 ];a &lt; b; // falsevar a = &#123; b: 42 &#125;;var b = &#123; b: 43 &#125;;a &lt; b; // ??// 结果还是 false ，因为 a 是 [object Object] ，b 也是 [object Object]，所以按照字母顺序 a &lt; b 并不成立。// 下面的例子就有些奇怪了:var a = &#123; b: 42 &#125;;var b = &#123; b: 43 &#125;;a &lt; b; // falsea == b; // falsea &gt; b; // falsea &lt;= b; // truea &gt;= b; // true 因为根据规范 a &lt;= b 被处理为 b &lt; a ，然后将结果反转。因为 b &lt; a 的结果是 false ，所以 a &lt;= b 的结果是 true。实际上 JavaScript 中 &lt;= 是 “ 不大于 ” 的意思（即 !(a &gt; b) ，处理为 !(b &lt; a) ）。同理 a &gt;= b 处理为 b &lt;= a 。 比较字符串在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。任何操作数与NaN进行关系比较，结果都是 false。 12&quot;23&quot; &lt; &quot;3&quot; // false “2” 的字符编码是 50，“3” 是 51 &quot;a&quot; &lt; 2 // false 因为 “a” 被转换成了 NaN toString12345[] + &#123;&#125;; // &quot;[object Object]&quot;&#123;&#125; + []; // 0[null].toString() // &quot;&quot;[undefined].toString() // &quot;&quot;[null, undefined].toString() // &quot;,&quot; 第一行代码中， {} 出现在 + 运算符表达式中，因此它被当作一个值（空对象）来处理。 [] 会被强制类型转换为 “” ，而 {} 会被强制类型转换为 “[object Object]” 。但在第二行代码中， {} 被当作一个独立的空代码块（不执行任何操作）。代码块结尾不需要分号，所以这里不存在语法上的问题。最后 + [] 将 [] 显式强制类型转换为 0 。 构造函数123456var Person = function(name) &#123; this.name = name;&#125;;// 实例化一个Personvar alice = new Person(&apos;alice&apos;);// 不要这么做!Person(&apos;bob&apos;); //=&gt; undefined 这个函数只会返回 undefined，并且执行上下文是 window(全局)对象，你无意间创建了一个全局变量 name。调用构造函数时不要丢掉 new 关键字。当使用 new 关键字来调用构造函数时，执行上下文从全局对象(window)变成一个空的 上下文，这个上下文代表了新生成的实例。因此，this 关键字指向当前创建的实例。默认情况下，如果你的构造函数中没有返回任何内容，就会返回 this——当前的上下文。 要不然就返回任意非原始类型的值。 bind 实现12345678910Function.prototype.bind = Function.prototype.bind || function (obj) &#123; var slice = [].slice, args = slice.call(arguments, 1), self = this, nop = function () &#123;&#125;, bound = function () &#123; return self.apply(this instanceof nop ? this : (obj || &#123;&#125;), args.concat(slice.call(arguments))); &#125;; nop.prototype = self.prototype; bound.prototype = new nop(); return bound; &#125;; Object.create() 实现12345Object.create = Object.create || function(o) &#123; function F() &#123;&#125;; F.prototype = o; return new F();&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"}],"tags":[]}],"categories":[{"name":"fund","slug":"fund","permalink":"https://liangxinwei.github.io/categories/fund/"},{"name":"shell","slug":"shell","permalink":"https://liangxinwei.github.io/categories/shell/"},{"name":"css","slug":"css","permalink":"https://liangxinwei.github.io/categories/css/"},{"name":"git","slug":"git","permalink":"https://liangxinwei.github.io/categories/git/"},{"name":"mysql","slug":"mysql","permalink":"https://liangxinwei.github.io/categories/mysql/"},{"name":"随笔","slug":"随笔","permalink":"https://liangxinwei.github.io/categories/随笔/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://liangxinwei.github.io/categories/读书笔记/"},{"name":"前端","slug":"前端","permalink":"https://liangxinwei.github.io/categories/前端/"},{"name":"小程序","slug":"小程序","permalink":"https://liangxinwei.github.io/categories/小程序/"}],"tags":[]}