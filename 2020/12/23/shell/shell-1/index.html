<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Shell笔记一 | 梁新维</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Shell笔记一</h1><a id="logo" href="/.">梁新维</a><p class="description">主业上班，副业理财</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Shell笔记一</h1><div class="post-meta">2020-12-23<span> | </span><span class="category"><a href="/categories/shell/">shell</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Shell 编程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">获取脚本的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.2.</span> <span class="toc-text">文件描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E8%A1%A8%E5%92%8C%E5%86%85%E5%AD%98%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E8%A1%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">理解文件描述符、系统文件表和内存索引节点表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%96%87%E4%BB%B6%E7%9A%84%E5%A6%99%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">特殊文件的妙用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dev-null"><span class="toc-number">1.3.1.</span> <span class="toc-text">&#x2F;dev&#x2F;null</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dev-zero"><span class="toc-number">1.3.2.</span> <span class="toc-text">&#x2F;dev&#x2F;zero</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dev-tty"><span class="toc-number">1.3.3.</span> <span class="toc-text">&#x2F;dev&#x2F;tty</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.</span> <span class="toc-text">一切皆文件\</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E5%85%83%E7%B4%A0"><span class="toc-number">2.</span> <span class="toc-text">编程的基础元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.1.</span> <span class="toc-text">字符串操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text">位置变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">2.3.</span> <span class="toc-text">条件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83"><span class="toc-number">2.3.1.</span> <span class="toc-text">字符串比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">2.3.2.</span> <span class="toc-text">文件属性检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#case"><span class="toc-number">2.3.3.</span> <span class="toc-text">case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.3.4.</span> <span class="toc-text">for 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while-until-%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.3.5.</span> <span class="toc-text">while&#x2F;until 循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%AD%97%E7%AC%A6"><span class="toc-number">3.1.</span> <span class="toc-text">一般字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E7%9A%84-meta-%E5%AD%97%E7%AC%A6"><span class="toc-number">3.2.</span> <span class="toc-text">转义的 meta 字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%8F%B7-%E5%AD%97%E7%AC%A6"><span class="toc-number">3.3.</span> <span class="toc-text">.(点号)字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%8B%AC%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">方括号表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%9F%E5%8F%B7-meta-%E5%AD%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.5.</span> <span class="toc-text">星号 meta 字符的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">3.6.</span> <span class="toc-text">区间表达式的应用</span></a></li></ol></li></ol></div></div><div class="post-content"><h2 id="Shell-编程基础"><a href="#Shell-编程基础" class="headerlink" title="Shell 编程基础"></a>Shell 编程基础</h2><h3 id="获取脚本的参数"><a href="#获取脚本的参数" class="headerlink" title="获取脚本的参数"></a>获取脚本的参数</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $# 代表传入函数的参数个数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$#</span> 个参数&quot;</span></span><br><span class="line"><span class="comment"># 位置参数 。从参数 0 开始</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="comment"># $@ 代表所有参数的内容</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>将脚本加上可执行权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -x ./2.sh</span><br></pre></td></tr></table></figure>

<p>以 &gt; 改变标准输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 &lt; 改变标准输入（这条命令将会复制/tmp/a.txt 文件到/tmp/b.txt）</span></span><br><span class="line">cat &lt; /tmp/a.txt &gt; /tmp/b.txt</span><br></pre></td></tr></table></figure>

<p>以 &gt;&gt; 追加文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat 2.sh &gt;&gt; 3.sh</span><br></pre></td></tr></table></figure>

<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><h4 id="理解文件描述符、系统文件表和内存索引节点表"><a href="#理解文件描述符、系统文件表和内存索引节点表" class="headerlink" title="理解文件描述符、系统文件表和内存索引节点表"></a>理解文件描述符、系统文件表和内存索引节点表</h4><ol>
<li><p>文件描述符表<br>用户区的一部分，除非通过使用文件描述符的函数，否则程序无法对其进行访问。对进程中每个打开的文件，文件描述符表都包含一个条目。</p>
</li>
<li><p>系统文件表<br>为系统中所有的进程共享。对每个活动的 open, 它都包含一个条目。每个系统文件表的条目都包含文件偏移量、访问模式（读、写、或读-写）以及指向它的文件 描述符表的条目计数。每个进程的文件表在系统文件表中的区域都不重合。理由是，这种安排使每个进程都有 它自己的对该文件的当前偏移量。</p>
</li>
<li><p>内存索引节点表<br>对系统中的每个活动的文件（被某个进程打开了），内存中索引节点表都包含一个条目。几个系统文件表条目可能对应于同一个内存索引节点表（不同进程打开同一个文件）。</p>
</li>
</ol>
<p>习惯上，标准输入（Standard Input）的文件描述符是 0，标准输出（Standard Output）是 1， 标准错误（Standard Error）是 2。这也是当我们重定向标准错误时，使用（2&gt;）的原因。</p>
<h3 id="特殊文件的妙用"><a href="#特殊文件的妙用" class="headerlink" title="特殊文件的妙用"></a>特殊文件的妙用</h3><h4 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h4><p>我们可以把/dev/null 想象为一个“黑洞”。它类似于一个只写文件。所有写入它的内容都不可读取。但是，对于命令行和脚本来说，/dev/null 却非常有用。如：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取/tmp/b.txt 文件，但是将读取的内容输出到/dev/null</span></span><br><span class="line">cat /tmp/b.txt &gt;/dev/null</span><br><span class="line"><span class="comment"># 检索/etc 下所有包含 alloy 字符串的文件行，但是如果有错误信息，则输出到/dev/null</span></span><br><span class="line">grep <span class="string">&quot;alloy&quot;</span> /etc/* 2&gt; /dev/null</span><br><span class="line"><span class="comment"># 下面的命令不会产生任何输出</span></span><br><span class="line"><span class="comment"># 如果 b.txt 文件存在，则读取的内容输出到/dev/null</span></span><br><span class="line"><span class="comment"># 如果 b.txt 文件不存在，则错误的信息输出到/dev/null</span></span><br><span class="line">cat /tmp/b.txt &gt;/dev/null 2&gt;/dev/null</span><br><span class="line"><span class="comment"># 这个命令和上一条命令是等效的</span></span><br><span class="line">cat /tmp/b.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="comment"># 清空 messages 和 wtmp 文件中的内容，但是让文件依然存在并且不改变权限</span></span><br><span class="line">cat /dev/null &gt; /var/<span class="built_in">log</span>/messages</span><br><span class="line">cat /dev/null &gt; /var/<span class="built_in">log</span>/wtmp</span><br></pre></td></tr></table></figure>
<p>如果是重定向标准输出，直接使用&gt;就可以了，或者也可以用(1&gt;)表示，而如果是重新向标准错误，则用 2&gt;。如果是标准输入呢?那就要用(0&lt;)表示。而(&amp;&gt;)则代表标准输出和标准错误。</p>
<h4 id="dev-zero"><a href="#dev-zero" class="headerlink" title="/dev/zero"></a>/dev/zero</h4><p>类似于/dev/null，/dev/zero 也是一个伪文件，但事实上它会产生一个 null 流(二进制的 0 流，而不是 ASCII 类型)。如果你想把其他命令的输出写入/dev/zero 文件的话，那么写入的内容会消失，而且如果你想从/dev/zero 文件中读取一连串 null 的话，也非常的困难，/dev/zero 文件的主要用途就是用来创建一个指定长度，并且初始化为空的文件，这种文件一 般都用作临时交换文件。</p>
<h4 id="dev-tty"><a href="#dev-tty" class="headerlink" title="/dev/tty"></a>/dev/tty</h4><p>/dev/tty 是一个很实用的文件。当程序打开这个文件时，UNIX/Linux 会自动将它重定向到当<br>前所处的终端。输出到此的信息只会显示在当前工作的终端显示器上。在某些时候例如，设定了 脚本输出到/dev/null 时，而你又想在当前终端上显示一些很重要的信息，你就可以调用这个设备， 写入重要信息。这样做可以强制信息显示到终端。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>“Enter new passwd:”               <span class="comment"># 提示输入 </span></span><br><span class="line">stty–<span class="built_in">echo</span>                               <span class="comment"># 关闭自动打印输入字符的功能 </span></span><br><span class="line"><span class="built_in">read</span> pass &lt; /dev/tty                    <span class="comment"># 读取密码</span></span><br><span class="line"><span class="built_in">printf</span>“Enter again”</span><br><span class="line"><span class="built_in">read</span> pass2&lt; /dev/tty                    <span class="comment"># 再读一次，以便确认 </span></span><br><span class="line">stty <span class="built_in">echo</span>                               <span class="comment"># 记得重新打开自动打印输入字符功能</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件\"></a>一切皆文件\</h3><p>Linux 文件类型常见的有:普通文件、目录、字符设备文件、块设备文件、符号链接文件等。</p>
<ol>
<li><p>普通文件<br>我们用 ls-lh 来查看某个文件的属性，可以看到有类似-rw-r–r– ，值得注意的，它的第一个符 号是-，这样的文件在 Linux 中就是普通文件。这些文件一般是用一些相关的应用程序创建，例如 图像工具、文档工具、归档工具或 cp 工具等。这类文件的删除方式是用 rm 命令。</p>
</li>
<li><p>目录<br>当我们在某个目录下执行命令，看到有类似 drwxr-xr-x 命令时，这样的文件就是目录，目录 在 Linux 是一个比较特殊的文件。注意，它的第一个字符是 d。创建目录可以用 mkdir 命令或 cp 命令。cp 可以把一个目录复制为另一个目录。删除目录用 rm 或 rmdir 命令。</p>
</li>
<li><p>字符设备或块设备文件<br>如果进入/dev 目录，列一下文件，会看到类似如下的格式:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alloy@ubuntu:~/LinuxShell/ch2$ ls-la /dev/tty</span><br><span class="line">crw-rw-rw-1 root tty 5, 0 5 月 14 16:47 /dev/tty</span><br><span class="line">crw-rw-rw-1 root tty 5, 0 04-19 08:29 /dev/tty</span><br><span class="line">alloy@ubuntu:~/LinuxShell/ch2$ ls-la /dev/sda1</span><br><span class="line">brw-rw----1 root disk 8, 1 5 月 14 11:39 /dev/sda1</span><br></pre></td></tr></table></figure>
<p>看到 /dev/tty 的属性是 crw-rw-rw-。注意，前面第一个字符是 c，表示字符设备文件，如猫等串口设备。<br>看到/dev/sda1 的属性是 brw-r—–。注意，前面的第一个字符是 b，表示块设备，如硬盘、光驱等设备。<br>这种文件，是用 mknode 来创建，用 rm 来删除。目前，在最新的 Linux 发行版本中，一般不用自己来创建设备文件，因为这些文件是和内核是相关联的。</p>
</li>
<li><p>套接口文件<br>当我们启动 MySQL 服务器时，会产生一个 mysql.sock 的文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloy@ubuntu:~/LinuxShell/ch2$ ls-lh /var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure>
<p>注意，这个文件的属性的第一个字符是 s。我们了解一下就行了。</p>
</li>
<li><p>符号链接文件</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alloy@ubuntu:~/LinuxShell/ch2$ ls-lh setup.log</span><br><span class="line">lrwxrwxrwx 1 root root 11 5月14 11:39 setup.log-&gt; install.log</span><br></pre></td></tr></table></figure>
<p>当我们查看文件属性时，会看到有类似 lrwxrwxrwx 的命令。注意，第一个字符是 l，这类文件是链接文件。是通过 ln-s 源文件产生新文件名。这和 Windows 操作系统中的快捷方式有点相似。</p>
<h2 id="编程的基础元素"><a href="#编程的基础元素" class="headerlink" title="编程的基础元素"></a>编程的基础元素</h2><h3 id="字符串操作符"><a href="#字符串操作符" class="headerlink" title="字符串操作符"></a>字符串操作符</h3><ol>
<li>替换运算符</li>
</ol>
<table>
<thead>
<tr>
<th align="center">变量运算符</th>
<th>替换</th>
</tr>
</thead>
<tbody><tr>
<td align="center">${varname:-word}</td>
<td>如果 varname 存在且非 null，则返回 varname 的值;否则，返回 word。用途:如果变量未定义，则返回默认值范例:如果 loginname 未定义，则${loginname:-ollir}的值为 ollir</td>
</tr>
<tr>
<td align="center">${varname:=word}</td>
<td>如果 varname 存在且非 null，则返回 varname 的值;否则将其置为 word，然后返回其值。用途:如果变量未定义，则设置变量为默认值 word。范例:如果 loginname 未定义，则${loginname:-ollir}的值为 ollir，并且 loginname 被设 置为 ollir</td>
</tr>
<tr>
<td align="center">${varname:?message}</td>
<td>如果 varname 存在且非 null，则返回 varname 的值;否则打印message，并退出当前脚 本。省如果省略 message 的话，Shell 返回 parameter null or not set。用途:用于捕捉由于变量未定义而导致的错误。范例:如果 loginname 未定义，则${loginname:”undefined!”}则显示 loginname:undefined!，然后退出</td>
</tr>
<tr>
<td align="center">${varname:+word}</td>
<td>如果 varname 存在且非 null，则返回 word;否则返回 null。用途:用于测试变量存在。范例:如果 loginname 已定义，则${loginname:+1}返回 1</td>
</tr>
</tbody></table>
<ol start="2">
<li>模式匹配运算符</li>
</ol>
<table>
<thead>
<tr>
<th align="center">变量运算符</th>
<th>替换</th>
</tr>
</thead>
<tbody><tr>
<td align="center">${varname#pattern}</td>
<td>如果模式匹配变量取值的开头处，则删除匹配的最短部分，并返回剩下部分。范例:${path#/*/}为 prince/desktop/long.file.name 这个范例删除了字符串开头/的部分</td>
</tr>
<tr>
<td align="center">${varname##pattern}</td>
<td>如果模式匹配变量取值的开头处，则删除匹配的最长部分，并返回剩下部分。范例:${path#/*/}为 long.file.name这个范例提取了文件路径中的文件名</td>
</tr>
<tr>
<td align="center">${varname%pattern}</td>
<td>如果模式匹配变量取值的结尾处，则删除匹配的最短部分，并返回剩下部分。范例:${path%.*}为/home/prince/desktop/long.file 这个范例去除文件路径中最后一个点号(.)之后的部分</td>
</tr>
<tr>
<td align="center">${varname%%pattern}</td>
<td>如果模式匹配变量取值的结尾处，则删除匹配的最长部分，并返回剩下部分。范例:${path%.*}为/home/prince/desktop/long 这个范例去除范例中第一个点号(.)之后的部分</td>
</tr>
<tr>
<td align="center">${varname/pattern/string} ${varname//pattern/string}</td>
<td>将 varname 中匹配模式的最长部分替换为 string。第一种格式中，只有匹配的第一部分 被替换;第二种格式中，varname 中所有匹配的部分都被替换。如果模式以#开头，则 必须匹配varname 的开头，如果模式以%开头，则必须匹配 varname 的结尾。如果 string 为空，匹配部分被删除。如果 varname 为@或*，操作被依次应用于每个位置参数 并且扩展为结果列表。范例:${path//prince/ollir}则为:/home/ollir/desktop/long.file.name 这个范例将字符串 prince 替换成 ollir</td>
</tr>
</tbody></table>
<p>${varname//pattern/string} 例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PATH 以换行符展示</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;PATH//:/&#x27;\n&#x27;&#125;</span>-e   <span class="comment"># -e 选项允许 echo 将\n 解释为一个 LINEFEED</span></span><br></pre></td></tr></table></figure>

<h3 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h3><p>比较多得是 $n，$#，$0，$?。如例所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># 判断运行参数个数，如果不等于 2，显示使用“用法帮助”，其中 $0 表示就是脚本自己。</span></span><br><span class="line"><span class="comment"># NOTE 用中括号做判断时 “[“ 后和 ”]” 前的空格是必须加的</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span>-ne 2 ] ;</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> string file&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 用 grep 在 $2 文件中查找 $1 字符串</span></span><br><span class="line">grep <span class="variable">$1</span> <span class="variable">$2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断前一个命令运行后的返回值(一般成功都会返回 0, 失败都会返回非 0)</span></span><br><span class="line"><span class="keyword">if</span> [ $?-ne 0 ];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">&quot;Not Found \&quot;<span class="variable">$1</span>\&quot; in <span class="variable">$2</span>&quot;</span>;</span><br><span class="line">   <span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># 如果没有成功则显示没找到相关信息，否则显示找到了。</span></span><br><span class="line"><span class="comment"># 其中 \&quot; 表示转义，在 &quot;&quot; 里面还需要显示 &quot; 号，则需要加上转义符 \&quot;。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;found \&quot;<span class="variable">$1</span>\&quot; in <span class="variable">$2</span>&quot;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Shell 内置了一个 shift 命令，shift 命令可以“截去”参数列表最左端的一个。执行了 shift 命 令后，$1 的值将永远丢失，而$2 的旧值会被赋值给$1，依此类推。</p>
</blockquote>
<h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>如果…则为真</th>
</tr>
</thead>
<tbody><tr>
<td>Str1 = str2</td>
<td>str1 匹配 str2</td>
</tr>
<tr>
<td>Str1 != str2</td>
<td>str1 不匹配 str2</td>
</tr>
<tr>
<td>Str1 &lt; str2</td>
<td>str1 小于 str2</td>
</tr>
<tr>
<td>Str1 &gt; str2</td>
<td>str1 大于 str2</td>
</tr>
<tr>
<td>-n str1</td>
<td>str1 为非 null(长度大于 0)</td>
</tr>
<tr>
<td>-z str1</td>
<td>str1 为 null(长度为 0)</td>
</tr>
</tbody></table>
<h4 id="文件属性检查"><a href="#文件属性检查" class="headerlink" title="文件属性检查"></a>文件属性检查</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>如果…则为真</th>
</tr>
</thead>
<tbody><tr>
<td>-b file</td>
<td>file 为块设备文件</td>
</tr>
<tr>
<td>-d file</td>
<td>file 为目录</td>
</tr>
<tr>
<td>-e file</td>
<td>file 存在</td>
</tr>
<tr>
<td>-f file</td>
<td>file 为一般文件</td>
</tr>
<tr>
<td>-r file</td>
<td>file 可读</td>
</tr>
<tr>
<td>-w file</td>
<td>file 可写</td>
</tr>
<tr>
<td>-x file</td>
<td>file 可执行</td>
</tr>
<tr>
<td>-s file</td>
<td>file 非空</td>
</tr>
<tr>
<td>-O file</td>
<td>你是 file 的所有者</td>
</tr>
<tr>
<td>file1 -nt file2</td>
<td>file1 比 file2 新</td>
</tr>
<tr>
<td>file1 -ot file2</td>
<td>file1 比 file2 旧</td>
</tr>
</tbody></table>
<h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p>语法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> expression <span class="keyword">in</span></span><br><span class="line">pattern1)</span><br><span class="line">    statements;;</span><br><span class="line">pattern2)</span><br><span class="line">    statements;;</span><br><span class="line">pattern3 | pattern4)</span><br><span class="line">    statements;;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p>case 语句常常被用于对 单个参数有大量判断语句的情形。一个例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断文件后缀，然后根据文件后缀选择不同的读取方式。</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">*.jpg)</span><br><span class="line">    gqview <span class="variable">$1</span>;;</span><br><span class="line">*.txt)</span><br><span class="line">    gvim <span class="variable">$1</span>;;</span><br><span class="line">*.avi | *.wmv)</span><br><span class="line">    mplayer <span class="variable">$1</span>;;</span><br><span class="line">*.pdf)</span><br><span class="line">    acroread <span class="variable">$1</span>;;</span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span>: Don<span class="string">&#x27;t know how to read this file;;</span></span><br><span class="line"><span class="string">esac</span></span><br></pre></td></tr></table></figure>

<h4 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h4><p>语法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name [<span class="keyword">in</span> list]           <span class="comment"># 遍历list中的所有对象</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">...                          <span class="comment"># able to use $name，执行与$name相关的操作</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>一个例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历当前目录中所有 mp3 文件，mpg123 时命令行程序，播放mp3文件</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `find .-iname</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mpg123 <span class="variable">$file</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，本例中 list 上的两个反单引号(``)。执行反单引号之间的命令，引用结果作为字符串。<br>在 for 循环中，如果 in list 被省略，则默认为 in “$@”，即命令行参数的引用列表。</p>
</blockquote>
<h4 id="while-until-循环"><a href="#while-until-循环" class="headerlink" title="while/until 循环"></a>while/until 循环</h4><p>语法如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">statements...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 至于 until 语句，语法几乎和 while 一样:</span></span><br><span class="line"><span class="comment"># until condition</span></span><br></pre></td></tr></table></figure>
<p>while 语句与 until 语句唯一不同的地方在于，如何判断 condition 的退出状态。在 while 语句中，当 condtion 的退出状态为真时，循环继续运行，否则退出循环。而在 until 中，当 condition 的退出状态为真时，循环退出，否则继续执行循环体。一个例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历 PATH 路径</span></span><br><span class="line">path=<span class="variable">$PATH</span>:             <span class="comment"># 将$PATH 复制到一个参数 path 中，并在末尾加上一个冒号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ -n <span class="variable">$path</span> ];     <span class="comment"># 当path不为空时</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">ls-ld <span class="variable">$&#123;path%%:*&#125;</span>       <span class="comment"># 我们使用ls-ld列出显示path中的第一个目录</span></span><br><span class="line">path=<span class="variable">$&#123;path#*:&#125;</span>         <span class="comment"># 在这里，我们截去 path 中的第一个目录和冒号</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>综合例子：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">author=<span class="literal">false</span></span><br><span class="line">list=<span class="literal">false</span></span><br><span class="line">file=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span>-gt 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">    -f)</span><br><span class="line">        file=<span class="variable">$2</span>         <span class="comment"># 将 -f 参数的下一个参数(file)获取至 file 变量 #截去下一个参数</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">        ;;</span><br><span class="line">    -l)</span><br><span class="line">        list=<span class="literal">true</span></span><br><span class="line">        ;;</span><br><span class="line">    -a)</span><br><span class="line">        author=<span class="literal">true</span></span><br><span class="line">        ;;</span><br><span class="line">    --)                 <span class="comment"># 传统上，以 -- 结束选项</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">        ;;</span><br><span class="line">    -*)</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$0</span>: <span class="variable">$1</span>: unrecognized option</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        <span class="built_in">break</span>           <span class="comment"># 无选项参数时，在循环中跳出</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">shift</span>                   <span class="comment"># 参数偏移</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>在 Shell 中，有 getopt 命令，可以简化选项处理。使用 getopt 重写：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">author=<span class="literal">false</span></span><br><span class="line">list=<span class="literal">false</span></span><br><span class="line">file=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 它的第一个参数是一个字符串，每个字符是命令的一个选项。如果参数后还需要跟其 他参数，则该字符后面接一个冒号(:)，而紧跟的参数则会放入 $OPTARG 变量中。</span></span><br><span class="line"><span class="keyword">while</span> getopt alf: opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">    f)                  <span class="comment"># 将 -f 参数的下一个参数(file)获取至 file 变量 #截去下一个参数</span></span><br><span class="line">        file=<span class="variable">$OPTARG</span></span><br><span class="line">        ;;</span><br><span class="line">    l)</span><br><span class="line">        list=<span class="literal">true</span></span><br><span class="line">        ;;</span><br><span class="line">    a)</span><br><span class="line">        author=<span class="literal">true</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">shift</span> <span class="variable">$&#123;&#123;OPTIND–1&#125;</span>&#125;     <span class="comment">#删除选项，留下参数，变量 OPTIND 包含下一个要处理的参数的索引值。Shell 会 把它初始化为 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以明显看出简化了很多。首先，在 case 中对 $opt 的测试仅仅是字母，开头的 - 被去除了；然后，循环中的 shift 也被 getopt 处理了，不需要自己控制；再次，– 的 case 也不见了，getopt 自动处理；最后，针对不合法选项的处理默认下 getopt 也会显示错误信息。</p>
</blockquote>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="一般字符"><a href="#一般字符" class="headerlink" title="一般字符"></a>一般字符</h3><p>一般字符包括文字和数字字符、空白字符和 标点符号字符。一般字符匹配的就是它们自身。</p>
<h3 id="转义的-meta-字符"><a href="#转义的-meta-字符" class="headerlink" title="转义的 meta 字符"></a>转义的 meta 字符</h3><p>当 meta 字符无法表示自己而我们需要这些字符时，转义符号的作用就体现出来了:在字符前置一个反斜杠 ()。例如，.只表示一个点，而不是任意字符;[匹配左方括号，而\表示反斜杠本身。如果将转义字符置于一般字符前，则转义字符会被忽略。</p>
<h3 id="点号-字符"><a href="#点号-字符" class="headerlink" title=".(点号)字符"></a>.(点号)字符</h3><p>.(点号)字符 点号字符表示“任一字符”。例如，”.hina”正则表达式匹配 china，也匹配 China，但是它也同时匹配 dhina</p>
<h3 id="方括号表达式"><a href="#方括号表达式" class="headerlink" title="方括号表达式"></a>方括号表达式</h3><p>例如，[cC]hina 只匹配 china 和 China。这是最简单的方括号表达式的用法，即直接将字符列表置于方括号中。如果将^符号至于方括号的开头([^abc])，就是取反的意思。即不在方括号中出现的任意字符。例如，[^abd]hina 匹配除了 abd 三个小写字母外的任意字母，加上 hina。</p>
<h3 id="星号-meta-字符的应用"><a href="#星号-meta-字符的应用" class="headerlink" title="星号 meta 字符的应用"></a>星号 meta 字符的应用</h3><p>ab*c 正则表达式匹配如下字符串:ac，abc，abbc，abbbc…你一定看出来了，星号 meta 字符匹配零个或多 个星号前面的单个字符。注意，匹配零个或多个字符并不是任意字母，例如，ab*c 就不匹配 adc。</p>
<p>a.*c 当点号和星号一起用时是表示字母 a 和 c 中匹配任意长度的字符串，例如，ac, abc, adc, abbc, acccc 等。</p>
<p>a.c 它的含义是字母 a 和字母 c 之间匹配任意一个字母，但是只能是一个，不能多也不能少。例如，acc, abc, aac, a!c等。</p>
<h3 id="区间表达式的应用"><a href="#区间表达式的应用" class="headerlink" title="区间表达式的应用"></a>区间表达式的应用</h3><p>ab{3}c a 字母和 c 字母之间的 b 字母重现 3 次，即，ab{3}c 正则表达式匹配 abbbc。</p>
<p>ab{3,}c a 字母和 c 字母之间的 b 字母重现至少 3 次，即，ab{3}c 正则表达式匹配 abbbc，abbbbc， abbbbbc…</p>
<p>ab{3,5}c a 字母和 c 字母之间的 b 字母重现 3~5 次，即，ab{3}c 正则表达式匹配 abbbc，abbbbc， abbbbbc。</p>
<p>ab?c 只匹配两种：ac 和 abc。</p>
<p>ab+c 匹配 abc，abbc，abbbc。。。但不匹配 ac。</p>
<p>^abc 匹配字符串开头的 3 个字母 abc，例如，abcxxxABCabcxxxefg。</p>
<p>efg$ 匹配结尾处的 efg。和开头一样，$符号锚定了字符串的结尾，即 abcxxxABCabcxxxefg。</p>
<p>如果将字符^和$一起使用，则两者之间的正则表达式就匹配了整个或整行正则表达式。有时 我们使用^$来匹配空的字符串或者空行。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2021/04/15/fund/note/%E8%AF%81%E5%88%B8%E5%88%86%E6%9E%90%E4%B8%8A/">证券分析上-笔记</a><a class="next" href="/2020/12/23/fund/note/%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85/">聪明的投资者笔记（格雷厄姆投资指南）-笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%A7%E5%93%81/">产品</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E9%87%91/">基金</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/08/12/pm/%E4%BF%9E%E5%86%9B%E4%BA%A7%E5%93%81%E6%96%B9%E6%B3%95%E8%AE%BA%E7%AC%94%E8%AE%B0/">俞军产品方法论-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/08/pm/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E7%AC%94%E8%AE%B0/">用户体验要素-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/08/pm/%E4%BA%A7%E5%93%81%E4%B9%A6%E7%B1%8D/">产品书籍</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/29/fund/note/%E5%BD%BC%E5%BE%97%E6%9E%97%E5%A5%87%E7%9A%84%E6%88%90%E5%8A%9F%E6%8A%95%E8%B5%84/">彼得林奇的成功投资-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/22/fund/%E8%B0%83%E4%BB%93%E8%AE%B0%E5%BD%95%E8%A1%A8/">天天基金【10年之后】组合调仓记录表</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/22/fund/note/%E8%B6%85%E9%A2%9D%E6%94%B6%E7%9B%8A%EF%BC%9A%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E5%9C%A8%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">超额收益：价值投资在中国的最佳实践.刘哲（502的牛）-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/19/fund/note/%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E8%AE%A9%E8%B4%A2%E5%AF%8C%E6%BB%9A%E9%9B%AA%E7%90%83/">基金定投让财富滚雪球.老罗-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/14/fund/note/%E6%8A%95%E8%B5%84%E4%B8%AD%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B/">投资中最简单的事.邱国鹭-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/27/fund/note/%E5%BD%BC%E5%BE%97%E6%9E%97%E5%A5%87%E6%95%99%E4%BD%A0%E7%90%86%E8%B4%A2/">彼得林奇教你理财-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/fund/note/%E8%AF%81%E5%88%B8%E5%88%86%E6%9E%90%E4%B8%8A/">证券分析上-笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/liangxinwei" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">梁新维</a></div></div></div><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>