<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MySQL笔记（一） | 梁新维</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">MySQL笔记（一）</h1><a id="logo" href="/.">梁新维</a><p class="description">主业上班，副业理财</p></div><div id="nav-menu"><a href="/"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">MySQL笔记（一）</h1><div class="post-meta">2020-04-22<span> | </span><span class="category"><a href="/categories/mysql/">mysql</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E6%93%8E"><span class="toc-number">1.</span> <span class="toc-text">引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-REGEXP%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">使用 REGEXP：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Concat-%E6%8B%BC%E6%8E%A5%E4%B8%B2%EF%BC%8C%E5%8D%B3%E6%8A%8A%E5%A4%9A%E4%B8%AA%E4%B8%B2%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%E5%BD%A2%E6%88%90%E4%B8%80%E4%B8%AA%E8%BE%83%E9%95%BF%E7%9A%84%E4%B8%B2"><span class="toc-number">3.</span> <span class="toc-text">Concat() 拼接串，即把多个串连接起来形成一个较长的串</span></a></li></ol></div></div><div class="post-content"><h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><ol>
<li>InnoDB 是一个可靠的事务处理引擎，它不支持全文本搜索</li>
<li>MEMORY在功能等同于MyISAM，但由于数据存储在内存(不是磁盘) 中，速度很快(特别适合于临时表)</li>
<li>MyISAM是一个性能极高的引擎，它支持全文本搜索(参见第18章)， 但不支持事务处理。</li>
<li>外键不能跨引擎混用引擎类型有一个大缺陷。外键(用于强制实施引用完整性)不能跨引擎，即使用一 个引擎的表不能引用具有使用不同引擎的表的外键。</li>
</ol>
<h2 id="使用-REGEXP："><a href="#使用-REGEXP：" class="headerlink" title="使用 REGEXP："></a>使用 REGEXP：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// shop_name 是测试数据，包含 --，比如 商家--1</span><br><span class="line">SELECT `shop_name` FROM business WHERE `shop_name` REHEXP &#x27;--1|--2&#x27;;</span><br><span class="line">SELECT `shop_name` FROM business WHERE `shop_name` REHEXP &#x27;--[0-9]&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="Concat-拼接串，即把多个串连接起来形成一个较长的串"><a href="#Concat-拼接串，即把多个串连接起来形成一个较长的串" class="headerlink" title="Concat() 拼接串，即把多个串连接起来形成一个较长的串"></a>Concat() 拼接串，即把多个串连接起来形成一个较长的串</h2><p>Trim() 删除数据多余的空格，RTrim() 函数去掉值右边的所有空格，LTrim() 去掉串左边的空格<br>常见的情景：报表中的名字按照name(location)的格式，而表中数据存储在两个列name和country中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT Concat(Trim(`shop_name`), Trim(&#x27; ( &#x27;), Trim(`mail_type`), &#x27; )&#x27;) AS format_title</span><br><span class="line">FROM business;</span><br><span class="line">// 标题--1(中通)</span><br><span class="line">````</span><br><span class="line">但是拼接串它没有名字，它只是一个值，客户机没有办法引用它（一个未命名的列），解决办法是*别名(alias)*，是一个字段或值的替换名。别名用AS关键字赋予。</span><br><span class="line"></span><br><span class="line">## 执行算术计算</span><br></pre></td></tr></table></figure>
<p>SELECT <code>shop_name</code>, <code>mail_type</code>， <code>distance</code>, <code>service_time</code>, <code>service_time</code> * <code>distance</code> as <code>total_price</code><br>FROM business<br>WHERE <code>mail_type</code> LIKE ‘_通’<br>ORDER BY <code>distance</code><br>DESC;<br>// 标题–9 中通 980 59 57820</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 常用的文本处理函数：</span><br><span class="line">1. Left() 返回串左边的字符，Right() 返回串右边的字符</span><br><span class="line">2. Length() 返回串的长度</span><br><span class="line">3. Locate() 找出串的一个子串</span><br><span class="line">4. Lower() 将串转换为小写，Upper() 将串转换为大写</span><br><span class="line">5. LTrim() 去掉串左边的空格，RTrim() 去掉串右边的空格</span><br><span class="line">6. Soundex() 返回串的SOUNDEX值（SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法，如：Y.Lee -&gt; Y.Lie，</span><br><span class="line">`SELECT shop_name FROM business WHERE Soundex(shop_name) = Soundex(&#x27;Y.Lie&#x27;)`）</span><br><span class="line">7. SubString() 返回子串的字符</span><br><span class="line"></span><br><span class="line">## 常用的日期处理函数</span><br><span class="line">1. AddDate() 增加一个日期(天、周等)</span><br><span class="line">2. AddTime()增加一个时间(时、分等) </span><br><span class="line">3. CurDate()返回当前日期</span><br><span class="line">4. CurTime()返回当前时间 </span><br><span class="line">5. Date()返回日期时间的日期部分</span><br><span class="line">6. DateDiff()计算两个日期之差</span><br><span class="line">7. Date_Add()高度灵活的日期运算函数</span><br><span class="line">8. Date_Format()返回一个格式化的日期或时间串</span><br><span class="line">9. Day()返回一个日期的天数部分</span><br><span class="line">10. DayOfWeek()对于一个日期，返回对应的星期几</span><br><span class="line">11. Hour()返回一个时间的小时部分</span><br><span class="line">12. Minute()返回一个时间的分钟部分</span><br><span class="line">13. Month()返回一个日期的月份部分 </span><br><span class="line">14. Now()返回当前日期和时间</span><br><span class="line">15. Second()返回一个时间的秒部分</span><br><span class="line">16. Time()返回一个日期时间的时间部分</span><br><span class="line">17. Year()返回一个日期的年份部分</span><br><span class="line"></span><br><span class="line">## 聚焦函数</span><br></pre></td></tr></table></figure>
<p>– street 的行数<br>SELECT COUNT(*) AS <code>street_count</code> FROM street;<br>– 最大值<br>SELECT MAX(<code>distance</code>) AS max_distance,<br>– 最小值<br>MIN(<code>distance</code>) AS min_distance,<br>– 平均值<br>AVG(<code>distance</code>) AS avg_distance,<br>– 所有值的和<br>SUM(<code>distance</code>) AS total_distance,<br>– 所有不同值的和（去重）<br>SUM(DISTINCT <code>distance</code>) AS total_distance_distinct<br>FROM business;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## GROUP BY</span><br><span class="line">1. GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套， 为数据分组提供更细致的控制。</span><br><span class="line">2. 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算(所以不能从个别的列取回数据)。</span><br><span class="line">3. GROUP BY子句中列出的每个列都必须是检索列或有效的表达式(但不能是聚集函数)。如果在SELECT中使用表达式，则必须在 GROUP BY子句中指定相同的表达式。不能使用别名。</span><br><span class="line">4. 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子 句中给出。</span><br><span class="line">5. 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列 中有多行NULL值，它们将分为一组。</span><br><span class="line">6. GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</span><br><span class="line">7. 使用WITH ROLLUP关键字，可以得到每个分组以 及每个分组汇总级别(针对每个分组)的值</span><br></pre></td></tr></table></figure>
<p>SELECT <code>mail_type</code>, COUNT(*) AS <code>num_mail_type</code><br>FROM <code>business</code><br>GROUP BY <code>mail_type</code>;</p>
<p>SELECT <code>mail_type</code>, COUNT(*) AS <code>num_mail_type</code><br>FROM <code>business</code><br>GROUP BY <code>mail_type</code><br>WITH ROLLUP;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## HAVING和WHERE的差别:</span><br><span class="line">WHERE过滤指定的是行而不是分组。事实上，WHERE没有分组的概念。WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。</span><br><span class="line"></span><br><span class="line">## 联结表</span><br></pre></td></tr></table></figure>
<p>// 在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。<br>// WHERE子句作为 过滤条件，它只包含那些匹配给定条件(这里是联结条件)的行。<br>// 没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。<br>SELECT p.name, c.name, d.name, s.name<br>FROM <code>province</code> p, <code>city</code> c, <code>district</code> d, <code>street</code> s<br>WHERE s.parent_code = d.code<br>AND d.parent_code = c.code<br>AND c.parent_code = p.code<br>AND p.name = ‘山西省’<br>ORDER BY c.name;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## UNION操作符来组合数条SQL查询，将它们的结果组合成单个结果集。规则：</span><br><span class="line">1. UNION必须由两条或两条以上的SELECT语句组成，语句之间用关 键字UNION分隔</span><br><span class="line">2. UNION中的每个查询必须包含相同的列、表达式或聚集函数(不过各个列不需要以相同的次序列出)。</span><br><span class="line">3. 列数据类型必须兼容:类型不必完全相同，但必须是DBMS可以隐含地转换的类型(例如，不同的数值类型或不同的日期类型)。</span><br><span class="line">4. UNION ALL返回所有匹配行，不取消重复的行</span><br></pre></td></tr></table></figure>
<p>// 查询 <code>distance</code> &lt; 400 ｜｜ <code>mail_type</code> IN (‘顺丰’, ‘圆通’)<br>SELECT <code>shop_name</code>, <code>distance</code><br>FROM <code>business</code><br>WHERE <code>distance</code> &lt; 400<br>UNION<br>SELECT <code>shop_name</code>, <code>distance</code><br>FROM <code>business</code><br>WHERE <code>mail_type</code> IN (‘顺丰’, ‘圆通’)<br>ORDER BY <code>distance</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 更新表：</span><br></pre></td></tr></table></figure>
<p>UPDATE <code>business</code><br>SET <code>service_time</code> = round(rand() * 100)<br>WHERE <code>service_time</code> &lt; 60;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 创建用户</span><br></pre></td></tr></table></figure>
<p>SELECT * FROM mysql.user;<br>—- <code>hotdog</code>@<code>%</code>：用户名 hotdog，% 表示允许任何ip地址，IDENTIFIEDBY 指定的口令为纯文本，MySQL 将在保存到user表之前对其进行加密。<br>CREATE USER <code>hotdog</code>@<code>%</code> IDENTIFIED BY ‘123456’;<br>—- 配置权限：对 hotdog 数据库有所有权限，不能访问其他数据库，GRANT 的反操作为 REVOKE<br>GRANT ALL PRIVILEGES ON hotdog.* TO <code>hotdog</code>@<code>%</code> IDENTIFIED BY ‘123456’;<br>—- 删除用户<br>DROP USER <code>hotdog</code>@<code>localhost</code>;<br>—- 配置完权限之后刷新MySQL的系统权限相关表方可生效<br>FLUSH PRIVILEGES;<br>—- 删除用户<br>DROP USER <code>username</code>;<br>—- 查看赋予用户账号的权限<br>SHOW GRANT FOR <code>username</code>;<br>—- 更改口令，新口令必须传递到Password()函 数进行加密。<br>SET PASSWORD FOR <code>username</code> = Password(<code>new_password</code>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## created_at字段与updated_at字段关于自动更新与自动插入时间戳</span><br></pre></td></tr></table></figure>
<p>ALTER TABLE <code>user</code> ADD COLUMN <code>create_at</code> TIMESTAMP NOT NULL;<br>ALTER TABLE <code>user</code> ADD COLUMN <code>update_at</code> TIMESTAMP NOT NULL;<br>—- TIMESTAMP DEFAULT CURRENT_TIMESTAMP 表示插入的时候自动获取当前时间（格式为YY-mm-dd HH:ii:ss）<br>ALTER TABLE <code>user</code> MODIFY <code>create_at</code> TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL;<br>—- TIMESTAMP ON UPDATE CURRENT_TIMESTAMP 表示更新的时候自动获取当前时间（格式为YY-mm-dd HH:ii:ss）<br>ALTER TABLE <code>user</code> MODIFY <code>update_at</code> TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP NOT NULL;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 新增外键</span><br></pre></td></tr></table></figure>
<p>ALTER  TABLE <code>products</code> ADD CONSTRAINT <code>fk_orders_customs</code> FOREIGN KEY (vend_id) REFERENCES <code>vendors</code> (vend_id);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 视图</span><br><span class="line">1. 规则和限制</span><br><span class="line">    1. 与表一样，视图必须唯一命名(不能给视图取与别的视图或表相 同的名字)。</span><br><span class="line">    2. 对于可以创建的视图数目没有限制。</span><br><span class="line">    3. 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。</span><br><span class="line">    4. 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。</span><br><span class="line">    5. ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。</span><br><span class="line">    6. 视图不能索引，也不能有关联的触发器或默认值。</span><br><span class="line">    7. 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。</span><br><span class="line">2. 性能问题：因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。</span><br><span class="line">3. 一些常见应用</span><br><span class="line">    1. 重用SQL语句。</span><br><span class="line">    2. 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</span><br><span class="line">    3. 使用表的组成部分而不是整个表。</span><br><span class="line">    4. 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</span><br><span class="line">    5. 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</span><br><span class="line"></span><br><span class="line">## 数据库维护</span><br></pre></td></tr></table></figure>
<p>// 1. 用来检查表键是否正确<br>ANALYZE TABLE <code>table_name</code>;<br>// 2. CHECK TABLE用来针对许多问题对表进行检查。在MyISAM表上还对 索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。 CHANGED检查自最后一次检查以来改动过的表。EXTENDED执行最 彻底的检查，FAST只检查未正常关闭的表，MEDIUM检查所有被删 除的链接并进行键检验，QUICK只进行快速扫描。如下所示，CHECK TABLE发现和修复问题<br>CHECK TABLE <code>table_name</code>;<br>// 3. 如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能。<br>OPTIMIZE TABLE <code>table_name</code>;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 字符集</span><br></pre></td></tr></table></figure>
<p>// 查看所支持的字符集完整列表<br>SHOW CHARACTER SET;<br>// 查看所支持校对的完整列表<br>SHOW COLLATION;<br>SHOW FULL COLUMNS FROM <code>village</code>;<br>SHOW VARIABLES LIKE ‘%char%’;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 改善性能</span><br></pre></td></tr></table></figure>
<ol>
<li>但过一段时间后你可能需要调整内存分配、缓冲区大 小等。查看当前设置：<br>SHOW VARIABLES;<br>SHOW STATUS;</li>
<li>显示所有活动进程(以及它们的线程ID和执行时间)<br>SHOW PROCESSLIST；</li>
<li>KILL命令终结某个特定的进程(使用这个命令需要作为管理员登录)。</li>
<li>LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。</li>
<li>索引改善数据检索的性能，但损害数据插入、删除和更新的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。(索引可根据需要添加和删除。)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">21. MySQL不允许对变长列(或一个列的可变部分)进行索引</span><br><span class="line">22. MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2)</span><br><span class="line"></span><br><span class="line">## MySQL 数据类型</span><br><span class="line">1. 串数据类型</span><br><span class="line">![串数据类型](/images/7EA9F5A0D8F1.png)</span><br><span class="line">2. 数值数据类型 </span><br><span class="line">![数值数据类型](/images/5D37349650BC.png)</span><br><span class="line">3. 日期和时间数据类型</span><br><span class="line">![日期和时间数据类型](/images/5BC46C7A9A76.png)</span><br><span class="line">4. 二进制数据类型</span><br><span class="line">![二进制数据类型](/images/7058C7294EBE.png)</span><br><span class="line"></span><br><span class="line">## 触发器</span><br><span class="line">&gt; 想要某条语句（或某些语句）在事件发生时自动执行。MySQL响应以下任意语句而 自动执行的一条MySQL语句(或位于BEGIN和END语句之间的一组语 句):DELETE; NSERT; UPDATE。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 只有表才支持触发器，每个表最多支持6个触发器（每条INSERT、UPDATE 和DELETE的之前和之后），单一触发器不能与多个事件或多个表关联。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
// 触发器将在INSERT语句成功执行后执行。从 NEW.order_num 取得这个值并返回它，此触发器必须按照AFTER INSERT执行<br>CREATE TRIGGER <code>new_order</code> AFTER INSERT ON <code>orders</code> FOR EACH ROW SELECT NEW.order_num;<br>// 删除触发器<br>DROP TRIGGER <code>new_product</code>;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1. *INSERT触发器*（在INSERT语句执行之前或之后执行）：</span><br><span class="line">  1. 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被 插入的行;</span><br><span class="line">  2. 在BEFORE INSERT触发器中，NEW中的值也可以被更新(允许更改 被插入的值);</span><br><span class="line">  3. 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT 执行之后包含新的自动生成值。</span><br><span class="line"></span><br><span class="line">2. *DELETE触发器*（在DELETE语句执行之前或之后执行）：</span><br><span class="line">  1. 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访 问被删除的行;</span><br><span class="line">  2. OLD中的值全都是只读的，不能更新。</span><br></pre></td></tr></table></figure>
// 在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值(要被删除的订单)<br>// 保存到一个名为archive_ orders的存档表中<br>CREATE TRIGGER <code>delete_order</code> BEFORE DELETE ON <code>orders</code> FOR EACH ROW<br>BEGIN<br> INSERT INTO <code>archive_orders</code>(<code>order_num</code>, <code>order_date</code>, <code>cust_id</code>)<br> VALUES(OLD.order_num, OLD.order_date, OLD.cust_id);<br>END;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. *UPDATE触发器*（在UPDATE语句执行之前或之后执行）：</span><br><span class="line">  1. 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问 以前(UPDATE语句前)的值，引用一个名为NEW的虚拟表访问新更新的值;</span><br><span class="line">  2. 在BEFORE UPDATE触发器中，NEW中的值可能也被更新(允许更改 将要用于UPDATE语句中的值);</span><br><span class="line">  3. OLD中的值全都是只读的，不能更新。</span><br></pre></td></tr></table></figure>
// 保证州名缩写总是大写<br>CREATE TRIGGER <code>upper_vendor</code> BEFORE UPDATE ON <code>vendors</code> FOR EACH ROW<br>SET NEW.vend_state = Upper(NEW.vend_state);<br>```</li>
</ol>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2020/04/26/git/SourceTree%E8%AE%BE%E7%BD%AE%E5%A4%9A%E4%B8%AA%E8%B4%A6%E6%88%B7/">SourceTree设置多个账户</a><a class="next" href="/2020/01/01/other/2020Flag/">2020Flag</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%A7%E5%93%81/">产品</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E9%87%91/">基金</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a><span class="category-list-count">2</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/08/12/pm/%E4%BF%9E%E5%86%9B%E4%BA%A7%E5%93%81%E6%96%B9%E6%B3%95%E8%AE%BA%E7%AC%94%E8%AE%B0/">俞军产品方法论-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/08/pm/%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E7%AC%94%E8%AE%B0/">用户体验要素-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/08/08/pm/%E4%BA%A7%E5%93%81%E4%B9%A6%E7%B1%8D/">产品书籍</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/29/fund/note/%E5%BD%BC%E5%BE%97%E6%9E%97%E5%A5%87%E7%9A%84%E6%88%90%E5%8A%9F%E6%8A%95%E8%B5%84/">彼得林奇的成功投资-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/22/fund/%E8%B0%83%E4%BB%93%E8%AE%B0%E5%BD%95%E8%A1%A8/">天天基金【10年之后】组合调仓记录表</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/22/fund/note/%E8%B6%85%E9%A2%9D%E6%94%B6%E7%9B%8A%EF%BC%9A%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%E5%9C%A8%E4%B8%AD%E5%9B%BD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">超额收益：价值投资在中国的最佳实践.刘哲（502的牛）-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/19/fund/note/%E5%9F%BA%E9%87%91%E5%AE%9A%E6%8A%95%E8%AE%A9%E8%B4%A2%E5%AF%8C%E6%BB%9A%E9%9B%AA%E7%90%83/">基金定投让财富滚雪球.老罗-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/07/14/fund/note/%E6%8A%95%E8%B5%84%E4%B8%AD%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B/">投资中最简单的事.邱国鹭-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/27/fund/note/%E5%BD%BC%E5%BE%97%E6%9E%97%E5%A5%87%E6%95%99%E4%BD%A0%E7%90%86%E8%B4%A2/">彼得林奇教你理财-笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/04/15/fund/note/%E8%AF%81%E5%88%B8%E5%88%86%E6%9E%90%E4%B8%8A/">证券分析上-笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/liangxinwei" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">梁新维</a></div></div></div><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>